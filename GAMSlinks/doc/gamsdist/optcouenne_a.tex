\printoption{2mir\_cuts}%
{$-100\leq\textrm{integer}$}%
{$0$}%
{Frequency k (in terms of nodes) for generating 2mir\_cuts cuts in branch-and-cut.\\
If k $>$ 0, cuts are generated every k nodes, if -99 $<$ k $<$ 0 cuts are generated every -k nodes but Cbc may decide to stop generating cuts, if not enough are generated at the root node, if k=-99 generate cuts only at the root node, if k=0 or 100 do not generate cuts.}%
{}

\printoption{Gomory\_cuts}%
{$-100\leq\textrm{integer}$}%
{$0$}%
{Frequency k (in terms of nodes) for generating Gomory\_cuts cuts in branch-and-cut.\\
See option \texttt{2mir\_cuts} for the meaning of k.}%
{}

\printoption{aggressive\_fbbt}%
{no, yes}%
{yes}%
{Aggressive feasibility-based bound tightening (to use with NLP points)\\
Aggressive FBBT is a version of probing that also allows to reduce the solution set, although it is not as quick as FBBT. It can be applied up to a certain depth of the B\&B tree -- see ``log\_num\_abt\_per\_level''. In general, this option is useful but can be switched off if a problem is too large and seems not to benefit from it.}%
{}

\printoption{art\_cutoff}%
{$\textrm{real}$}%
{$\infty$}%
{Artificial cutoff.}%
{}

\printoption{art\_lower}%
{$\textrm{real}$}%
{$-\infty$}%
{Artificial lower bound.}%
{}

\printoption{boundtightening\_print\_level}%
{$-2\leq\textrm{integer}\leq12$}%
{$0$}%
{Output level for bound tightening code in Couenne}%
{}

\printoption{branch\_conv\_cuts}%
{no, yes}%
{yes}%
{Apply convexification cuts before branching (for now only within strong branching)\\
After applying a branching rule and before resolving the subproblem, generate a round of linearization cuts with the new bounds enforced by the rule.}%
{}

\printoption{branch\_fbbt}%
{no, yes}%
{yes}%
{Apply bound tightening before branching\\
After applying a branching rule and before re-solving the subproblem, apply Bound Tightening.}%
{}

\printoption{branch\_lp\_clamp}%
{$0\leq\textrm{real}\leq1$}%
{$0.2$}%
{Defines safe interval percentage for using LP point as a branching point.}%
{}

\printoption{branch\_lp\_clamp\_cube}%
{$0\leq\textrm{real}\leq0.5$}%
{$0.2$}%
{Defines safe interval percentage [0,0.5] for using LP point as a branching point.}%
{}

\printoption{branch\_lp\_clamp\_div}%
{$0\leq\textrm{real}\leq0.5$}%
{$0.2$}%
{Defines safe interval percentage [0,0.5] for using LP point as a branching point.}%
{}

\printoption{branch\_lp\_clamp\_exp}%
{$0\leq\textrm{real}\leq0.5$}%
{$0.2$}%
{Defines safe interval percentage [0,0.5] for using LP point as a branching point.}%
{}

\printoption{branch\_lp\_clamp\_log}%
{$0\leq\textrm{real}\leq0.5$}%
{$0.2$}%
{Defines safe interval percentage [0,0.5] for using LP point as a branching point.}%
{}

\printoption{branch\_lp\_clamp\_negpow}%
{$0\leq\textrm{real}\leq0.5$}%
{$0.2$}%
{Defines safe interval percentage [0,0.5] for using LP point as a branching point.}%
{}

\printoption{branch\_lp\_clamp\_pow}%
{$0\leq\textrm{real}\leq0.5$}%
{$0.2$}%
{Defines safe interval percentage [0,0.5] for using LP point as a branching point.}%
{}

\printoption{branch\_lp\_clamp\_prod}%
{$0\leq\textrm{real}\leq0.5$}%
{$0.2$}%
{Defines safe interval percentage [0,0.5] for using LP point as a branching point.}%
{}

\printoption{branch\_lp\_clamp\_sqr}%
{$0\leq\textrm{real}\leq0.5$}%
{$0.2$}%
{Defines safe interval percentage [0,0.5] for using LP point as a branching point.}%
{}

\printoption{branch\_lp\_clamp\_trig}%
{$0\leq\textrm{real}\leq0.5$}%
{$0.2$}%
{Defines safe interval percentage [0,0.5] for using LP point as a branching point.}%
{}

\printoption{branch\_midpoint\_alpha}%
{$0\leq\textrm{real}\leq1$}%
{$0.25$}%
{Defines convex combination of mid point and current LP point: b = alpha x\_lp + (1-alpha) (lb+ub)/2.}%
{}

\printoption{branch\_pt\_select}%
{lp-clamped, lp-central, balanced, min-area, mid-point, no-branch}%
{mid-point}%
{Chooses branching point selection strategy}%
{\begin{list}{}{
\setlength{\parsep}{0em}
\setlength{\leftmargin}{5ex}
\setlength{\labelwidth}{2ex}
\setlength{\itemindent}{0ex}
\setlength{\topsep}{0pt}}
\item[\texttt{lp-clamped}] LP point clamped in [k,1-k] of the bound intervals (k defined by lp\_clamp)
\item[\texttt{lp-central}] LP point if within [k,1-k] of the bound intervals, middle point otherwise(k defined by branch\_lp\_clamp)
\item[\texttt{balanced}] minimizes max distance from curve to convexification
\item[\texttt{min-area}] minimizes total area of the two convexifications
\item[\texttt{mid-point}] convex combination of current point and mid point
\item[\texttt{no-branch}] do not branch, return null infeasibility; for testing purposes only
\end{list}
}

\printoption{branch\_pt\_select\_cube}%
{common, lp-clamped, lp-central, balanced, min-area, mid-point, no-branch}%
{common}%
{Chooses branching point selection strategy for operator cube.
Default is to use the value of \texttt{branch\_pt\_select} (value \texttt{common}).}%
{}

\printoption{branch\_pt\_select\_div}%
{common, lp-clamped, lp-central, balanced, min-area, mid-point, no-branch}%
{common}%
{Chooses branching point selection strategy for operator div.
Default is to use the value of \texttt{branch\_pt\_select} (value \texttt{common}).}%
{}

\printoption{branch\_pt\_select\_exp}%
{common, lp-clamped, lp-central, balanced, min-area, mid-point, no-branch}%
{common}%
{Chooses branching point selection strategy for operator exp.
Default is to use the value of \texttt{branch\_pt\_select} (value \texttt{common}).}%
{}

\printoption{branch\_pt\_select\_log}%
{common, lp-clamped, lp-central, balanced, min-area, mid-point, no-branch}%
{common}%
{Chooses branching point selection strategy for operator log.
Default is to use the value of \texttt{branch\_pt\_select} (value \texttt{common}).}%
{}

\printoption{branch\_pt\_select\_negpow}%
{common, lp-clamped, lp-central, balanced, min-area, mid-point, no-branch}%
{common}%
{Chooses branching point selection strategy for operator negpow.
Default is to use the value of \texttt{branch\_pt\_select} (value \texttt{common}).}%
{}

\printoption{branch\_pt\_select\_pow}%
{common, lp-clamped, lp-central, balanced, min-area, mid-point, no-branch}%
{common}%
{Chooses branching point selection strategy for operator pow.
Default is to use the value of \texttt{branch\_pt\_select} (value \texttt{common}).}%
{}

\printoption{branch\_pt\_select\_prod}%
{common, lp-clamped, lp-central, balanced, min-area, mid-point, no-branch}%
{common}%
{Chooses branching point selection strategy for operator prod.
Default is to use the value of \texttt{branch\_pt\_select} (value \texttt{common}).}%
{}

\printoption{branch\_pt\_select\_sqr}%
{common, lp-clamped, lp-central, balanced, min-area, mid-point, no-branch}%
{common}%
{Chooses branching point selection strategy for operator sqr.
Default is to use the value of \texttt{branch\_pt\_select} (value \texttt{common}).}%
{}

\printoption{branch\_pt\_select\_trig}%
{common, lp-clamped, lp-central, balanced, min-area, mid-point, no-branch}%
{common}%
{Chooses branching point selection strategy for operator trig.
Default is to use the value of \texttt{branch\_pt\_select} (value \texttt{common}).}%
{}

\printoption{branching\_object}%
{vt\_obj, var\_obj, expr\_obj}%
{var\_obj}%
{type of branching object for variable selection}%
{\begin{list}{}{
\setlength{\parsep}{0em}
\setlength{\leftmargin}{5ex}
\setlength{\labelwidth}{2ex}
\setlength{\itemindent}{0ex}
\setlength{\topsep}{0pt}}
\item[\texttt{vt\_obj}] use Violation Transfer from Tawarmalani and Sahinidis
\item[\texttt{var\_obj}] use one object for each variable
\item[\texttt{expr\_obj}] use one object for each nonlinear expression
\end{list}
}

\printoption{branching\_print\_level}%
{$-2\leq\textrm{integer}\leq12$}%
{$0$}%
{Output level for braching code in Couenne}%
{}

\printoption{check\_lp}%
{no, yes}%
{no}%
{Check all LPs through an independent call to OsiClpSolverInterface::initialSolve()}%
{}

\printoption{clique\_cuts}%
{$-100\leq\textrm{integer}$}%
{$0$}%
{Frequency k (in terms of nodes) for generating clique\_cuts cuts in branch-and-cut.\\
See option \texttt{2mir\_cuts} for the meaning of k.}%
{}

\printoption{cont\_var\_priority}%
{$1\leq\textrm{integer}$}%
{$2000$}%
{Priority of continuous variable branching\\
When branching, this is compared to the priority of integer variables, whose priority is fixed to 1000, and SOS, whose priority is 10. Higher values mean smaller priority, so if this parameter is set to 1001 or higher, if a branch-and-bound node has at least one integer variable whose value is fractional, then branching will be performed on that variable.}%
{}

\printoption{convexification\_cuts}%
{$-99\leq\textrm{integer}$}%
{$1$}%
{Specify the frequency (in terms of nodes) at which couenne ecp cuts are generated.\\
A frequency of 0 amounts to never solve the NLP relaxation.}%
{}

\printoption{convexification\_points}%
{$0\leq\textrm{integer}$}%
{$4$}%
{Specify the number of points at which to convexify when convexification type is uniform-grid or around-current-point.}%
{}

\printoption{convexification\_type}%
{current-point-only, uniform-grid, around-current-point}%
{current-point-only}%
{Determines in which point the linear over/under-estimator are generated\\
For the lower envelopes of convex functions, this is the number of points where a supporting hyperplane is generated. This only holds for the initial linearization, as all other linearizations only add at most one cut per expression.}%
{\begin{list}{}{
\setlength{\parsep}{0em}
\setlength{\leftmargin}{5ex}
\setlength{\labelwidth}{2ex}
\setlength{\itemindent}{0ex}
\setlength{\topsep}{0pt}}
\item[\texttt{current-point-only}] Only at current optimum of relaxation
\item[\texttt{uniform-grid}] Points chosen in a uniform grid between the bounds of the problem
\item[\texttt{around-current-point}] At points around current optimum of relaxation
\end{list}
}

\printoption{convexifying\_print\_level}%
{$-2\leq\textrm{integer}\leq12$}%
{$0$}%
{Output level for convexifying code in Couenne}%
{}

\printoption{cover\_cuts}%
{$-100\leq\textrm{integer}$}%
{$0$}%
{Frequency k (in terms of nodes) for generating cover\_cuts cuts in branch-and-cut.\\
See option \texttt{2mir\_cuts} for the meaning of k.}%
{}

\printoption{delete\_redundant}%
{no, yes}%
{yes}%
{Eliminate redundant variables, which appear in the problem as x\_k = x\_h}%
{\begin{list}{}{
\setlength{\parsep}{0em}
\setlength{\leftmargin}{5ex}
\setlength{\labelwidth}{2ex}
\setlength{\itemindent}{0ex}
\setlength{\topsep}{0pt}}
\item[\texttt{no}] Keep redundant variables, making the problem a bit larger
\item[\texttt{yes}] Eliminate redundant variables (the problem will be equivalent, only smaller)
\end{list}
}

\printoption{disj\_active\_cols}%
{yes, no}%
{no}%
{Only include violated variable bounds in the Cut Generating LP (CGLP).\\
This reduces the size of the CGLP, but may produce less efficient cuts.}%
{}

\printoption{disj\_active\_rows}%
{yes, no}%
{no}%
{Only include violated linear inequalities in the CGLP.\\
This reduces the size of the CGLP, but may produce less efficient cuts.}%
{}

\printoption{disj\_cumulative}%
{yes, no}%
{no}%
{Add previous disjunctive cut to current CGLP.\\
When generating disjunctive cuts on a set of disjunctions 1, 2, ..., k, introduce the cut relative to the previous disjunction i-1 in the CGLP used for disjunction i. Notice that, although this makes the cut generated more efficient, it increases the rank of the disjunctive cut generated.}%
{}

\printoption{disj\_depth\_level}%
{$-1\leq\textrm{integer}$}%
{$5$}%
{Depth of the B\&B tree when to start decreasing the number of objects that generate disjunctions.\\
This has a similar behavior as log\_num\_obbt\_per\_level. A value of -1 means that generation can be done at all nodes.}%
{}

\printoption{disj\_depth\_stop}%
{$-1\leq\textrm{integer}$}%
{$20$}%
{Depth of the B\&B tree where separation of disjunctive cuts is stopped.\\
A value of -1 means that generation can be done at all nodes}%
{}

\printoption{disj\_init\_number}%
{$-1\leq\textrm{integer}$}%
{$10$}%
{Maximum number of disjunction to consider at each iteration.\\
-1 means no limit.}%
{}

\printoption{disj\_init\_perc}%
{$0\leq\textrm{real}\leq1$}%
{$0.5$}%
{The maximum fraction of all disjunctions currently violated by the problem to consider for generating disjunctions.}%
{}

\printoption{disjcuts\_print\_level}%
{$-2\leq\textrm{integer}\leq12$}%
{$0$}%
{Output level for disjunctive cuts in Couenne}%
{}

\printoption{display\_stats}%
{yes, no}%
{no}%
{display statistics at the end of the run}%
{}

\printoption{enable\_lp\_implied\_bounds}%
{no, yes}%
{no}%
{Enable OsiSolverInterface::tightenBounds () -- warning: it has caused some trouble to Couenne}%
{}

\printoption{estimate\_select}%
{normal, product}%
{normal}%
{How the min/max estimates of the subproblems' bounds are used in strong branching}%
{\begin{list}{}{
\setlength{\parsep}{0em}
\setlength{\leftmargin}{5ex}
\setlength{\labelwidth}{2ex}
\setlength{\itemindent}{0ex}
\setlength{\topsep}{0pt}}
\item[\texttt{normal}] as usual in literature
\item[\texttt{product}] use their product
\end{list}
}

\printoption{feas\_tolerance}%
{$\textrm{real}$}%
{$10^{- 5}$}%
{Tolerance for constraints/auxiliary variables\\
Default value is zero.}%
{}

\printoption{feasibility\_bt}%
{no, yes}%
{yes}%
{Feasibility-based (cheap) bound tightening (FBBT)\\
A pre-processing technique to reduce the bounding box, before the generation of linearization cuts. This is a quick and effective way to reduce the solution set, and it is highly recommended to keep it active.}%
{}

\printoption{flow\_covers\_cuts}%
{$-100\leq\textrm{integer}$}%
{$0$}%
{Frequency k (in terms of nodes) for generating flow\_covers\_cuts cuts in branch-and-cut.\\
See option \texttt{2mir\_cuts} for the meaning of k.}%
{}

\printoption{lift\_and\_project\_cuts}%
{$-100\leq\textrm{integer}$}%
{$0$}%
{Frequency k (in terms of nodes) for generating lift\_and\_project\_cuts cuts in branch-and-cut.\\
See option \texttt{2mir\_cuts} for the meaning of k.}%
{}

\printoption{local\_optimization\_heuristic}%
{no, yes}%
{yes}%
{Do we search for local solutions of NLP's\\
If enabled, a heuristic based on Ipopt is used to find feasible solutions for the problem. It is highly recommended that this option is left enabled, as it would be difficult to find feasible solutions otherwise.}%
{}

\printoption{log\_num\_abt\_per\_level}%
{$-1\leq\textrm{integer}$}%
{$2$}%
{Specify the frequency (in terms of nodes) for aggressive bound tightening.\\
If -1, apply at every node (expensive!). If 0, apply at root node only. If k$>$=0, apply with probability $2^{(k - level)}$, level being the current depth of the B\&B tree.}%
{}

\printoption{log\_num\_local\_optimization\_per\_level}%
{$-1\leq\textrm{integer}$}%
{$2$}%
{Specify the logarithm of the number of local optimizations to perform on average for each level of given depth of the tree.\\
Solve as many nlp's at the nodes for each level of the tree. Nodes are randomly selected. If for a given level there are less nodes than this number nlp are solved for every nodes. For example if parameter is 8, nlp's are solved for all node until level 8, then for half the node at level 9, 1/4 at level 10.... Value -1 specify to perform at all nodes.}%
{}

\printoption{log\_num\_obbt\_per\_level}%
{$-1\leq\textrm{integer}$}%
{$1$}%
{Specify the frequency (in terms of nodes) for optimality-based bound tightening.\\
If -1, apply at every node (expensive!). If 0, apply at root node only. If k$>$=0, apply with probability $2^{(k - level)}$, level being the current depth of the B\&B tree.}%
{}

\printoption{minlp\_disj\_cuts}%
{$-99\leq\textrm{integer}$}%
{$0$}%
{The frequency (in terms of nodes) at which Couenne disjunctive cuts are generated.\\
A frequency of 0 (default) means these cuts are never generated. Any positive number n instructs Couenne to generate them at every n nodes of the B\&B tree. A negative number -n means that generation should be attempted at the root node, and if successful it can be repeated at every n nodes, otherwise it is stopped altogether.}%
{}

\printoption{mir\_cuts}%
{$-100\leq\textrm{integer}$}%
{$0$}%
{Frequency k (in terms of nodes) for generating mir\_cuts cuts in branch-and-cut.\\
See option \texttt{2mir\_cuts} for the meaning of k.}%
{}

\printoption{nlpheur\_print\_level}%
{$-2\leq\textrm{integer}\leq12$}%
{$0$}%
{Output level for NLP heuristic in Couenne}%
{}

\printoption{opt\_window}%
{$\textrm{real}$}%
{$\infty$}%
{Window around known optimum.}%
{}

\printoption{optimality\_bt}%
{no, yes}%
{yes}%
{Optimality-based (expensive) bound tightening (OBBT)\\
This is another bound reduction technique aiming at reducing the solution set by looking at the initial LP relaxation. This technique is computationally expensive, and should be used only when necessary.}%
{}

\printoption{orbital\_branching}%
{yes, no}%
{no}%
{detect symmetries and apply orbital branching}%
{}

\printoption{probing\_cuts}%
{$-100\leq\textrm{integer}$}%
{$0$}%
{Frequency k (in terms of nodes) for generating probing\_cuts cuts in branch-and-cut.\\
See option \texttt{2mir\_cuts} for the meaning of k.}%
{}

\printoption{problem\_print\_level}%
{$-2\leq\textrm{integer}\leq12$}%
{$1$}%
{Output level for problem manipulation code in Couenne}%
{}

\printoption{pseudocost\_mult}%
{infeasibility, projectDist, interval\_lp, interval\_lp\_rev, interval\_br, interval\_br\_rev}%
{interval\_br\_rev}%
{Multipliers of pseudocosts for estimating and update estimation of bound}%
{\begin{list}{}{
\setlength{\parsep}{0em}
\setlength{\leftmargin}{5ex}
\setlength{\labelwidth}{2ex}
\setlength{\itemindent}{0ex}
\setlength{\topsep}{0pt}}
\item[\texttt{infeasibility}] infeasibility returned by object
\item[\texttt{projectDist}] distance between current LP point and resulting branches' LP points
\item[\texttt{interval\_lp}] width of the interval between bound and current lp point
\item[\texttt{interval\_lp\_rev}] similar to interval\_lp, reversed
\item[\texttt{interval\_br}] width of the interval between bound and branching point
\item[\texttt{interval\_br\_rev}] similar to interval\_br, reversed
\end{list}
}

\printoption{pseudocost\_mult\_lp}%
{yes, no}%
{no}%
{Use distance between LP points to update multipliers of pseudocosts after simulating branching}%
{}

\printoption{red\_cost\_branching}%
{no, yes}%
{no}%
{Apply Reduced Cost Branching (instead of the Violation Transfer) -- MUST have vt\_obj enabled}%
{\begin{list}{}{
\setlength{\parsep}{0em}
\setlength{\leftmargin}{5ex}
\setlength{\labelwidth}{2ex}
\setlength{\itemindent}{0ex}
\setlength{\topsep}{0pt}}
\item[\texttt{no}] Use Violation Transfer with $\sum |\pi\_i a\_{ij}|$
\item[\texttt{yes}] Use Reduced cost branching with $|\sum \pi\_i a\_{ij}|$
\end{list}
}

\printoption{redcost\_bt}%
{no, yes}%
{yes}%
{Reduced cost bound tightening\\
This bound reduction technique uses the reduced costs of the LP in order to infer better variable bounds.}%
{}

\printoption{reduce\_split\_cuts}%
{$-100\leq\textrm{integer}$}%
{$0$}%
{Frequency k (in terms of nodes) for generating reduce\_split\_cuts cuts in branch-and-cut.\\
See option \texttt{2mir\_cuts} for the meaning of k.}%
{}

\printoption{reformulate\_print\_level}%
{$-2\leq\textrm{integer}\leq12$}%
{$0$}%
{Output level for reformulating problems in Couenne}%
{}

\printoption{use\_quadratic}%
{no, yes}%
{no}%
{Use quadratic expressions and related exprQuad class\\
If enabled, then quadratic forms are not reformulated and therefore decomposed as a sum of auxiliary variables, each associated with a bilinear term, but rather taken as a whole expression. Envelopes for these expressions are generated through alpha-convexification.}%
{\begin{list}{}{
\setlength{\parsep}{0em}
\setlength{\leftmargin}{5ex}
\setlength{\labelwidth}{2ex}
\setlength{\itemindent}{0ex}
\setlength{\topsep}{0pt}}
\item[\texttt{no}] Use an auxiliary for each bilinear term
\item[\texttt{yes}] Create only one auxiliary for a quadratic expression
\end{list}
}

\printoption{violated\_cuts\_only}%
{no, yes}%
{yes}%
{Yes if only violated convexification cuts should be added}%
{}

