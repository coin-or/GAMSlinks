\subsubsection{General Options}

\begin{description}

\item[\label{iterlim}\hypertarget{iterlim}
{\textbf{iterlim (\slshape{integer})}}]\hspace{1.0in}

For an LP, this is the maximum number of iterations to solve the LP.
For a MIP, this option is ignored.

\textsl{(default = GAMS iterlim)}

\item[\label{names}\hypertarget{names}
{\textbf{names (\slshape{integer})}}]\hspace{1.0in}

This option causes GAMS names for the variables and equations to be loaded into Cbc.
These names will then be used for error messages, log entries, and so forth.
Turning names off may help if memory is very tight.

\textsl{(default = 0)}
\begin{itemize}
\item[0] Do not load variable and equation names.
\item[1] Load variable and equation names.
\end{itemize}

\item[\label{reslim}\hypertarget{reslim}
{\textbf{reslim (\slshape{real})}}]\hspace{1.0in}

Maximum CPU time in seconds.

\textsl{(default = GAMS reslim)}

\item[\label{writemps}\hypertarget{writemps}
{\textbf{writemps (\slshape{string})}}]\hspace{1.0in}

Write the problem formulation in MPS format.
The parameter value is the name of the MPS file.

\item[\label{special}\hypertarget{special}
{\textbf{special (\slshape{string})}}]\hspace{1.0in}

This parameter let you specify CBC options which are not supported by the GAMS/CBC interface.

The string value given to this parameter is split up into parts at each space and added to the array of parameters given to CBC (in front of the -solve command).
Hence, you can use it like the command line parameters for the CBC standalone version.

\end{description}

\subsubsection{LP Options}

\begin{description}

\item[\label{idiotcrash}\hypertarget{idiotcrash}
{\textbf{idiotcrash (\slshape{integer})}}]\hspace{1.0in}

This is a type of `crash' which works well on some homogeneous problems.
It works best on problems with unit elements and right hand sides but will do something to any model.
It should only be used before the primal simplex algorithm.

A positive number determines the number of passes that idiotcrash is called.

\textsl{(default = -1)}
\begin{itemize}
\item[-1] 
Let CLP decide by itself whether to use it.
\item[0] 
Switch this method off.
\end{itemize}

\item[\label{sprintcrash}\hypertarget{sprintcrash}
{\textbf{sprintcrash (\slshape{integer})}}]\hspace{1.0in}

For long and thin problems this method may solve a series of small problems created by taking a subset of the columns.
Cplex calls it `sifting'.

A positive number determines the number of passes that sprintcrash is called.

\textsl{(default = -1)}
\begin{itemize}
\item[-1] 
Let CLP decide by itself whether to use it.
\item[0] 
Switch this method off.
\end{itemize}

\item[\label{sifting}\hypertarget{sifting}
{\textbf{sifting (\slshape{integer})}}]\hspace{1.0in}

Synonym for \hyperlink{sprintcrash}{sprintcrash}.

\textsl{(default = -1)}

\item[\label{crash}\hypertarget{crash}
{\textbf{crash (\slshape{string})}}]\hspace{1.0in}

Determines whether CLP should use a crash algorithm to find a dual feasible basis.

\textsl{(default = off)}
\begin{itemize}
\item[off] 
Switch off the creation of dual feasible basis by the crash method.
\item[on] 
Switch on the creation of dual feasible basis by the crash method.
\item[solow\_halim] 
Switch on a crash variant due to Solow and Halim.
\item[halim\_solow] 
Switch on a crash variant due to Solow and Halim with modifications of John J. Forrest.
\end{itemize}

\item[\label{maxfactor}\hypertarget{maxfactor}
{\textbf{maxfactor (\slshape{integer})}}]\hspace{1.0in}

Maximum number of iterations between refactorizations in CLP.

If this is left at the default value of 200 then CLP will guess at a value to use.
CLP may decide to refactorize earlier for accuracy.

\textsl{(default = 200)}

\item[\label{crossover}\hypertarget{crossover}
{\textbf{crossover (\slshape{integer})}}]\hspace{1.0in}

Determines whether CLP should crossover to the simplex algorithm after the barrier algorithm finished.

Interior point algorithms do not obtain a basic solution.
This option will crossover to a basic solution suitable for ranging or branch and cut.

\textsl{(default = 1)}
\begin{itemize}
\item[0] 
Turn off crossover to simplex algorithm after barrier algorithm finished.
\item[1] 
Turn on crossover to simplex algorithm after barrier algorithm finished.
\end{itemize}

\item[\label{dualpivot}\hypertarget{dualpivot}
{\textbf{dualpivot (\slshape{string})}}]\hspace{1.0in}

Choice of the pivoting strategy in the dual simplex algorithm.

\textsl{(default = auto)}
\begin{itemize}
\item[auto] 
Let CLP use a variant of the steepest choice method which starts like partial, i.e., scans only a subset of the primal infeasibilities,
and later changes to full pricing when the factorization becomes denser.
\item[dantzig] 
Let CLP use the pivoting strategy due to Dantzig.
\item[steepest] 
Let CLP use the steepest choice method.
\item[partial] 
Let CLP use a variant of the steepest choice method which scans only a subset of the primal infeasibilities to select the pivot step.
\end{itemize}

\item[\label{primalpivot}\hypertarget{primalpivot}
{\textbf{primalpivot (\slshape{string})}}]\hspace{1.0in}

Choice of the pivoting strategy in the primal simplex algorithm.

\textsl{(default = auto)}
\begin{itemize}
\item[auto] 
Let CLP use a variant of the exact devex method.
\item[dantzig] 
Let CLP use the pivoting strategy due to Dantzig.
\item[steepest] 
Let CLP use the steepest choice method.
\item[partial] 
Let CLP use a variant of the exact devex method which scans only a subset of the primal infeasibilities to select the pivot step.
\item[exact] 
Let CLP use the exact devex method.
\item[change] 
Let CLP initially use Dantzig pivot method until the factorization becomes denser.
\end{itemize}

\item[\label{perturbation}\hypertarget{perturbation}
{\textbf{perturbation (\slshape{integer})}}]\hspace{1.0in}

Determines whether CLP should perturb the problem before starting.
Perturbation helps to stop cycling, but CLP uses other measures for this.
However, large problems and especially ones with unit elements and unit right hand sides or costs benefit from perturbation.
Normally CLP tries to be intelligent, but you can switch this off.

\textsl{(default = 1)}
\begin{itemize}
\item[0] 
Turns off perturbation of LP.
\item[1] 
Turns on perturbation of LP.
\end{itemize}

\item[\label{scaling}\hypertarget{scaling}
{\textbf{scaling (\slshape{string})}}]\hspace{1.0in}

Scaling can help in solving problems which might otherwise fail because of lack of accuracy.
It can also reduce the number of iterations.
It is not applied if the range of elements is small.
Both methods do several passes alternating between rows and columns using current scale factors from one and applying them to the other.

\textsl{(default = auto)}
\begin{itemize}
\item[off] 
Turns off scaling.
\item[auto] 
Let CLP choose the scaling method automatically.
It decides for one of these methods depending on which gives the better ratio of the largest element to the smallest one.
\item[equilibrium] 
Let CLP use an equilibrium based scaling method which uses the largest scaled element.
\item[geometric] 
Let CLP use a geometric based scaling method which uses the squareroot of the product of largest and smallest element.
\end{itemize}

\item[\label{presolve}\hypertarget{presolve}
{\textbf{presolve (\slshape{integer})}}]\hspace{1.0in}

Presolve analyzes the model to find such things as redundant constraints, constraints which fix some variables, constraints which can be transformed into bounds, etc.
For the initial solve of any problem this is worth doing unless you know that it will have no effect.

\textsl{(default = 1)}
\begin{itemize}
\item[0] 
Turns off the initial presolve.
\item[1] 
Turns on the initial presolve.
\end{itemize}

\item[\label{tol_dual}\hypertarget{tol_dual}
{\textbf{tol\_dual (\slshape{real})}}]\hspace{1.0in}

The maximum amount the dual constraints can be violated and still be considered feasible.

\textsl{(default = 1e-7)}

\item[\label{tol_primal}\hypertarget{tol_primal}
{\textbf{tol\_primal (\slshape{real})}}]\hspace{1.0in}

The maximum amount the primal constraints can be violated and still be considered feasible.

\textsl{(default = 1e-7)}

\item[\label{tol_presolve}\hypertarget{tol_presolve}
{\textbf{tol\_presolve (\slshape{real})}}]\hspace{1.0in}

The tolerance used in presolve.

\textsl{(default = 1e-8)}

\item[\label{passpresolve}\hypertarget{passpresolve}
{\textbf{passpresolve (\slshape{integer})}}]\hspace{1.0in}

Normally Presolve does 5 passes but you may want to do less to make
it more lightweight or do more if improvements are still being made.
As Presolve will return if nothing is being taken out, you should
not normally need to use this fine tuning.

\textsl{(default = 5)}

\item[\label{startalg}\hypertarget{startalg}
{\textbf{startalg (\slshape{string})}}]\hspace{1.0in}

Determines the algorithm to use for an LP or the initial LP relaxation if the problem is a MIP.

\textsl{(default = dual)}
\begin{itemize}
\item[primal] 
Let CLP use the primal simplex algorithm.
\item[dual] 
Let CLP use the dual simplex algorithm.
\item[barrier] 
Let CLP use a primal dual predictor corrector algorithm.
\end{itemize}

\end{description}

\subsubsection{MIP Options}

\begin{description}

\item[\label{mipstart}\hypertarget{mipstart}
{\textbf{mipstart (\slshape{integer})}}]\hspace{1.0in}

This option controls the use of advanced starting values for mixed integer programs.
A setting of 1 indicates that the variable level values should be checked to see if they provide an integer feasible solution before starting optimization.

\textsl{(default = 0)}
\begin{itemize}
\item[0] 
Do not use the initial variable levels.
\item[1] 
Try to use the initial variable levels as a MIP starting solution.
\end{itemize}

\item[\label{strategy}\hypertarget{strategy}
{\textbf{strategy (\slshape{integer})}}]\hspace{1.0in}

Setting strategy to 1 (the default) uses Gomory cuts using tolerance of 0.01 at root,
does a possible restart after 100 nodes if Cbc can fix many variables and activates
a diving and RINS heuristic and makes feasibility pump more aggressive.

\textsl{(default = 1)}
\begin{itemize}
\item[0] 
Use this setting for easy problems.
\item[1] 
This is the default setting.
\item[2]
Use this setting for difficult problems.
\end{itemize}

\item[\label{tol_integer}\hypertarget{tol_integer}
{\textbf{tol\_integer (\slshape{real})}}]\hspace{1.0in}

For an optimal solution, no integer variable may be farther than this from an integer value.

\textsl{(default = 1e-6)}

\item[\label{sollim}\hypertarget{sollim}
{\textbf{sollim (\slshape{integer})}}]\hspace{1.0in}

A limit on number of feasible solutions that CBC should find for a MIP.

\textsl{(default = -1)}
\begin{itemize}
\item[-1] 
No limit on the number of feasible solutions.
\end{itemize}

\item[\label{strongbranching}\hypertarget{strongbranching}
{\textbf{strongbranching (\slshape{integer})}}]\hspace{1.0in}

Determines the number of variables to look at in strong branching.

In order to decide which variable to branch on, the code will choose up to this number of unsatisfied variables and try minimal up and down branches.
The most effective one is chosen.
If a variable is branched on many times then the previous average up and down costs may be used - see the option \hyperlink{trustpseudocosts}{trustpseudocosts}.

\textsl{(default = 5)}

\item[\label{trustpseudocosts}\hypertarget{trustpseudocosts}
{\textbf{trustpseudocosts (\slshape{integer})}}]\hspace{1.0in}

Using strong branching computes pseudo-costs.
This parameter determines after how many branches for a variable we just trust the pseudo costs and do not do any more strong branching.

\textsl{(default = 5)}

\item[\label{coststrategy}\hypertarget{coststrategy}
{\textbf{coststrategy (\slshape{string})}}]\hspace{1.0in}

This parameter influence the branching variable selection.

If turned on, then the variables are sorted in order of their absolute costs, and branching is done first on variables with largest cost.
This primitive strategy can be surprisingly effective.

\textsl{(default = off)}
\begin{itemize}
\item[off] 
Turns off a specific cost strategy.
\item[priorities] 
Assigns highest priority to variables with largest absolute cost.
\item[columnorder] 
Assigns the priorities 1, 2, 3,.. with respect to the column ordering.
\item[binaryfirst] 
Handles two sets of priorities such that binary variables get high priority.
\item[binarylast] 
Handles two sets of priorities such that binary variables get low priority.
\item[length] 
Assigns high priority to variables that are at most nonzero.
\end{itemize}

\item[\label{nodestrategy}\hypertarget{nodestrategy}
{\textbf{nodestrategy (\slshape{string})}}]\hspace{1.0in}

This determines the strategy used to select the next node from the branch and cut tree.

\textsl{(default = fewest)}
\begin{itemize}
\item[hybrid] 
Let CBC do first a breath search on nodes with a small depth in the tree and then switch to choose nodes with fewest infeasibilities.
\item[fewest] 
This will let CBC choose the node with the fewest infeasibilities.
\item[depth] 
This will let CBC always choose the node deepest in tree.
It gives minimum tree size but may take a long time to find the best solution.
\item[upfewest] 
This will let CBC choose the node with the fewest infeasibilities and do up branches first.
\item[downfewest] 
This will let CBC choose the node with the fewest infeasibilities and do down branches first.
\item[updepth] 
This will let CBC choose the node deepest in tree and do up branches first.
\item[downdepth] 
This will let CBC choose the node deepest in tree and do down branches first.
\end{itemize}

\item[\label{preprocess}\hypertarget{preprocess}
{\textbf{preprocess (\slshape{string})}}]\hspace{1.0in}

This option controls the MIP specific presolve routines.
They try to reduce the size of the model in a similar way to presolve and also try to strengthen the model.
This can be very useful and is worth trying.

\textsl{(default = on)}
\begin{itemize}
\item[off] 
Turns off the presolve routines.
\item[on] 
Turns on the presolve routines.
\item[equal] 
Turns on the presolve routines and let CBC turn inequalities with more than 5 elements into equalities (cliques) by adding slack variables.
\item[equalall] 
Turns on the presolve routines and let CBC turn all inequalities into equalities by adding slack variables.
\item[sos] 
This option let CBC search for rows with upper bound 1 and where all nonzero coefficients are 1 and creates special ordered sets if the sets are not overlapping and all integer variables (except for at most one) are in the sets.
\item[trysos] 
This option is similar to sos, but allows any number integer variables to be outside of the sets.
\end{itemize}

\item[\label{threads}\hypertarget{threads}
{\textbf{threads (\slshape{integer})}}]\hspace{1.0in}

This option controls the multithreading feature of CBC, which is currently available only on Unix variants.

\textsl{(default = GAMS threads)}

A number between 1 and 100 sets the number of threads used for parallel branch and bound.
A number $100+n$ with $n$ between 1 and 100 says that $n$ threads are used to parallelize the branch and bound, but also heuristics such as RINS which do branch and bound on a reduced model also use threads.
A number $200+n$ with $n$ between 1 and 100 says that $n$ threads are used to parallelize the branch and bound, but also the cut generators at the root node (i.e., before threads are useful) are run in parallel.
A number $300+n$ with $n$ between 1 and 100 combines the $100+n$ and $200+n$ options.
A number $400+n$ with $n$ between 1 and 100 says that $n$ threads are used in sub-trees.
Thus, $n$ threads are used to parallelize the branch and bound, but also heuristics use threads and the cut generators at the root node are run in parallel.
The $100+n$, $200+n$, and $300+n$ options are experimental.


\item[\label{printfrequency}\hypertarget{printfrequency}
{\textbf{printfrequency (\slshape{integer})}}]\hspace{1.0in}

Controls the number of nodes that are evaluated between status prints.

\textsl{(default = 0)}
\begin{itemize}
\item[0] 
Automatic choice, which is 100 for large problems and 1000 for small problems.
\end{itemize}

\item[\label{increment}\hypertarget{increment}
{\textbf{increment (\slshape{real})}}]\hspace{1.0in}

A valid solution must be at least this much better than last integer solution.

If this option is not set then it CBC will try and work one out.
E.g., if all objective coefficients are multiples of 0.01 and only integer variables have entries in objective then this can be set to 0.01.

\textsl{(default = GAMS cheat)}

\item[\label{solvefinal}\hypertarget{solvefinal}
{\textbf{solvefinal (\slshape{integer})}}]\hspace{1.0in}

whether the MIP with discrete variables fixed to solution values should be solved after CBC finished

\textsl{(default = 1)}

\item[\label{miptrace}\hypertarget{miptrace}
{\textbf{miptrace (\slshape{string})}}]\hspace{1.0in}

Name of file for writing branch-and-bound progress information during solve.


\item[\label{miptracenodefreq}\hypertarget{miptracenodefreq}
{\textbf{miptracenodefreq (\slshape{integer})}}]\hspace{1.0in}

frequency in number of nodes for writing branch-and-bound progress information

\textsl{(default = 100)}

\item[\label{miptracetimefreq}\hypertarget{miptracetimefreq}
{\textbf{miptracetimefreq (\slshape{real})}}]\hspace{1.0in}

frequency in seconds for writing branch-and-bound progress information

\textsl{(default = 5)}

\item[\label{nodelim}\hypertarget{nodelim}
{\textbf{nodelim (\slshape{integer})}}]\hspace{1.0in}

Maximum number of nodes that are considered in the Branch and Bound.

\textsl{(default = GAMS nodlim)}

\item[\label{nodlim}\hypertarget{nodlim}
{\textbf{nodlim (\slshape{integer})}}]\hspace{1.0in}

Maximum number of nodes that are considered in the Branch and Bound.
This option is overwritten by nodelim, if set.

\textsl{(default = GAMS nodlim)}

\item[\label{optca}\hypertarget{optca}
{\textbf{optca (\slshape{real})}}]\hspace{1.0in}

Absolute optimality criterion for a MIP.
CBC stops if the gap between the best known solution and the best possible solution is less than this value.

\textsl{(default = GAMS optca)}

\item[\label{optcr}\hypertarget{optcr}
{\textbf{optcr (\slshape{real})}}]\hspace{1.0in}

Relative optimality criterion for a MIP.
CBC stops if the relative gap between the best known solution and the best possible solution is less than this value.

\textsl{(default = GAMS optcr)}

\item[\label{cutoff}\hypertarget{cutoff}
{\textbf{cutoff (\slshape{real})}}]\hspace{1.0in}

CBC stops if the objective function values exceeds (in case of maximization) or falls below (in case of minimization) this value.

\textsl{(default = GAMS cutoff)}

\end{description}

\subsubsection{MIP Options for Cutting Plane Generators}

\begin{description}


\item[\label{cutdepth}\hypertarget{cutdepth}
{\textbf{cutdepth (\slshape{integer})}}]\hspace{1.0in}

If the depth in the tree is a multiple of cutdepth, then cut generators are applied.

Cut generators may be off, on only at the root, on if they look useful, or on at some interval.
Setting this option to a positive value K let CBC call a cutgenerator on a node whenever the depth in the tree is a multiple of K.

\textsl{(default = -1)}
\begin{itemize}
\item[-1]
Does not turn on cut generators because the depth of the tree is a multiple of a value.
\end{itemize}

\item[\label{cut_passes_root}\hypertarget{cut_passes_root}
{\textbf{cut\_passes\_root (\slshape{integer})}}]\hspace{1.0in}

Determines the number of rounds that the cut generators are applied in the root node.

A negative value $-n$ means that $n$ passes are also applied if the objective does not drop.

\textsl{(default = 100 passes if the MIP has less than 500 columns, 100 passes (but stop if the drop in the objective function value is small) if it has less than 5000 columns, and 20 passes otherwise)}


\item[\label{cut_passes_tree}\hypertarget{cut_passes_tree}
{\textbf{cut\_passes\_tree (\slshape{integer})}}]\hspace{1.0in}

Determines the number of rounds that the cut generators are applied in the nodes of the tree other than the root node.

A negative value $-n$ means that $n$ passes are also applied if the objective does not drop.

\textsl{(default = 1)}

\item[\label{cuts}\hypertarget{cuts}
{\textbf{cuts (\slshape{string})}}]\hspace{1.0in}

A global switch to turn on or off the cutgenerators.

This can be used to switch on or off all default cut generators.
Then you can set individual ones off or on using the specific options.

\textsl{(default = on)}
\begin{itemize}
\item[off] 
Turns off all cut generators.
\item[on] 
Turns on all default cut generators and CBC will try them in the branch and cut tree (see the option \hyperlink{cutdepth}{cutdepth} on how to fine tune the behaviour).
\item[root] 
Let CBC generate cuts only at the root node.
\item[ifmove] 
Let CBC use cut generators in the tree if they look as if they are doing some good and moving the objective value.
\item[forceon] 
Turns on all default cut generators and force CBC to use the cut generator at every node.
\end{itemize}

\item[\label{cliquecuts}\hypertarget{cliquecuts}
{\textbf{cliquecuts (\slshape{string})}}]\hspace{1.0in}

Determines whether and when CBC should try to generate clique cuts.
See the option \hyperlink{cuts}{cuts} for an explanation on the different values.

Clique cuts are of the form ``sum of a set of variables $<=$ 1''.

Reference: M. Eso, Parallel branch and cut for set partitioning, Cornell University, 1999.

\textsl{(default = ifmove)}

\item[\label{flowcovercuts}\hypertarget{flowcovercuts}
{\textbf{flowcovercuts (\slshape{string})}}]\hspace{1.0in}

Determines whether and when CBC should try to generate flow cover cuts.

See the option \hyperlink{cuts}{cuts} for an explanation on the different values.

The flow cover cut generator generates lifted simple generalized flow cover inequalities.
Since flow cover inequalities are generally not facet-defining, they are lifted to obtain stronger inequalities.
Although flow cover inequalities requires a special problem structure to be generated, they are quite useful for solving general mixed integer linear programs.

Reference: Z. Gu, G.L. Nemhauser, M.W.P. Savelsbergh, Lifted flow cover inequalities for mixed 0-1 integer programs, Math. Programming A 85 (1999) 439-467.

\textsl{(default = ifmove)}

\item[\label{gomorycuts}\hypertarget{gomorycuts}
{\textbf{gomorycuts (\slshape{string})}}]\hspace{1.0in}

Determines whether and when CBC should try to generate mixed-integer Gomory cuts.

See the option \hyperlink{cuts}{cuts} for an explanation on the different values.

Reference: Laurence A. Wolsey, Integer Programming, Wiley, John \& Sons, (1998) 124-132.

\textsl{(default = ifmove)}

\item[\label{knapsackcuts}\hypertarget{knapsackcuts}
{\textbf{knapsackcuts (\slshape{string})}}]\hspace{1.0in}

Determines whether and when CBC should try to generate knapsack cover cuts.

See the option \hyperlink{cuts}{cuts} for an explanation on the different values.

The knapsack cover cut generator looks for a series of different types of minimal covers.
If a minimal cover is found, it lifts the associated minimal cover inequality and adds the lifted cut to the cut set.

Reference: S. Martello, and P. Toth, Knapsack Problems, Wiley, 1990, p30.

\textsl{(default = ifmove)}

\item[\label{liftandprojectcuts}\hypertarget{liftandprojectcuts}
{\textbf{liftandprojectcuts (\slshape{string})}}]\hspace{1.0in}

Determines whether and when CBC should try to generate lift and project cuts.
They might be expensive to compute, thus they are switched off by default.

See the option \hyperlink{cuts}{cuts} for an explanation on the different values.

Reference: E. Balas and M. Perregaard, A precise correspondence between lift-and-project cuts, simple disjunctive cuts, and mixed integer Gomory cuts for 0-1 programming. Math. Program., 94(203,Ser. B):221-245,2003.

\textsl{(default = off)}

\item[\label{mircuts}\hypertarget{mircuts}
{\textbf{mircuts (\slshape{string})}}]\hspace{1.0in}

Determines whether and when CBC should try to generate mixed integer rounding cuts.

See the option \hyperlink{cuts}{cuts} for an explanation on the different values.

Reference: H. Marchand and L. A. Wolsey, Aggregation and Mixed Integer Rounding to Solve MIPs, Operations Research, 49(3), (2001).

\textsl{(default = ifmove)}

\item[\label{twomircuts}\hypertarget{twomircuts}
{\textbf{twomircuts (\slshape{string})}}]\hspace{1.0in}

Determines whether and when CBC should try to generate two phase mixed integer rounding cuts.

See the option \hyperlink{cuts}{cuts} for an explanation on the different values.

Reference: S. Dash, and O. Guenluek, Valid Inequalities Based on Simple Mixed-integer Sets, to appear in Math. Programming.

\textsl{(default = root)}

\item[\label{probingcuts}\hypertarget{probingcuts}
{\textbf{probingcuts (\slshape{string})}}]\hspace{1.0in}

Determines whether and when CBC should try to generate cuts based on probing.

Additional to the values for the option \hyperlink{cuts}{cuts} three more values are possible here.

Reference: M. Savelsbergh, Preprocessing and Probing Techniques for Mixed Integer Programming Problems, ORSA Journal on Computing 6 (1994), 445.

\textsl{(default = ifmove)}
\begin{itemize}
\item[off] 
Turns off Probing.
\item[on] 
Turns on Probing and CBC will try it in the branch and cut tree (see the option \hyperlink{cutdepth}{cutdepth} how to fine tune this behaviour).
\item[root] 
Let CBC do Probing only at the root node.
\item[ifmove] 
Let CBC do Probing in the tree if it looks as if it is doing some good and moves the objective value.
\item[forceon] 
Turns on Probing and forces CBC to do Probing at every node.
\item[forceonbut] 
Turns on Probing and forces CBC to call the cut generator at every node, but does only probing, not strengthening etc.
\item[forceonstrong] 
If CBC is forced to turn Probing on at every node (by setting this option to force), but this generator produces no cuts, then it is actually turned on only weakly (i.e., just every now and then).
Setting forceonstrong forces CBC strongly to do probing at every node.
\item[forceonbutstrong] 
This is like forceonstrong, but does only probing (column fixing) and turns off row strengthening, so the matrix will not change inside the branch and bound.
\end{itemize}

\item[\label{reduceandsplitcuts}\hypertarget{reduceandsplitcuts}
{\textbf{reduceandsplitcuts (\slshape{string})}}]\hspace{1.0in}

Determines whether and when CBC should try to generate reduced and split cuts.

See the option \hyperlink{cuts}{cuts} for an explanation on the different values.

Reduce and split cuts are variants of Gomory cuts.
Starting from the current optimal tableau, linear combinations of the rows of the current optimal simplex tableau are used for generating Gomory cuts.
The choice of the linear combinations is driven by the objective of reducing the coefficients of the non basic continuous variables in the resulting row.

Reference: K. Anderson, G. Cornuejols, and Yanjun Li, Reduce-and-Split Cuts: Improving the Performance of Mixed Integer Gomory Cuts, Management Science 51 (2005).

\textsl{(default = off)}

\item[\label{residualcapacitycuts}\hypertarget{residualcapacitycuts}
{\textbf{residualcapacitycuts (\slshape{string})}}]\hspace{1.0in}

Determines whether and when CBC should try to generate residual capacity cuts.

See the option \hyperlink{cuts}{cuts} for an explanation on the different values.

These inequalities are particularly useful for Network Design and Capacity Planning models.

References:\\
T.L. Magnanti, P. Mirchandani, and R. Vachani, The convex hull of two core capacitated network design problems, Math. Programming, 60 (1993), pp. 233-250.\\
A. Atamturk and D. Rajan, On splittable and unsplittable flow capacitated network design arc-set polyhedra, Math. Programming, 92 (2002), pp. 315-333.

\textsl{(default = off)}

\end{description}

\subsubsection{MIP Options for Heuristics}

\begin{description}

\item[\label{heuristics}\hypertarget{heuristics}
{\textbf{heuristics (\slshape{integer})}}]\hspace{1.0in}

This parameter can be used to switch on or off all heuristics, except for the local tree search as it dramatically alters the search.
Then you can set individual ones off or on.

\textsl{(default = 1)}
\begin{itemize}
\item[0] 
Turns all MIP heuristics off.
\item[1] 
Turns all MIP heuristics on (except \hyperlink{localtreesearch}{local tree search}).
\end{itemize}

\item[\label{combinesolutions}\hypertarget{combinesolutions}
{\textbf{combinesolutions (\slshape{integer})}}]\hspace{1.0in}

This parameter control the use of a heuristic which does branch and cut on the given problem by just using variables which have appeared in one or more solutions.
It is obviously only tried after two or more solutions.

\textsl{(default = 1)}
\begin{itemize}
\item[0] 
Turns the combine solutions heuristic off.
\item[1] 
Turns the combine solutions heuristic on.
\end{itemize}

\item[\label{dins}\hypertarget{dins}
{\textbf{dins (\slshape{integer})}}]\hspace{1.0in}

This parameter control the use of the distance induced neighborhood search heuristic.

\textsl{(default = 0)}
\begin{itemize}
\item[0] 
Turns the distance induced neighborhood search off.
\item[1] 
Turns the distance induced neighborhood search on.
\end{itemize}

\item[\label{divingrandom}\hypertarget{divingrandom}
{\textbf{divingrandom (\slshape{integer})}}]\hspace{1.0in}

This switches on a random diving heuristic at various times.

\textsl{(default = 0)}
\begin{itemize}
\item[0]
Turns the random diving heuristics off.
\item[1]
Turns the random diving heuristics on.
\end{itemize}

\item[\label{divingcoefficient}\hypertarget{divingcoefficient}
{\textbf{divingcoefficient (\slshape{integer})}}]\hspace{1.0in}

This switches on the coefficient diving heuristic.

\textsl{(default = 1)}
\begin{itemize}
\item[0]
Turns the coefficient diving heuristics off.
\item[1]
Turns the coefficient diving heuristics on.
\end{itemize}

\item[\label{divingfractional}\hypertarget{divingfractional}
{\textbf{divingfractional (\slshape{integer})}}]\hspace{1.0in}

This switches on the fractional diving heuristic.

\textsl{(default = 0)}
\begin{itemize}
\item[0]
Turns the fractional diving heuristics off.
\item[1]
Turns the fractional diving heuristics on.
\end{itemize}

\item[\label{divingguided}\hypertarget{divingguided}
{\textbf{divingguided (\slshape{integer})}}]\hspace{1.0in}

This switches on the guided diving heuristic.

\textsl{(default = 0)}
\begin{itemize}
\item[0]
Turns the guided diving heuristics off.
\item[1]
Turns the guided diving heuristics on.
\end{itemize}

\item[\label{divinglinesearch}\hypertarget{divinglinesearch}
{\textbf{divinglinesearch (\slshape{integer})}}]\hspace{1.0in}

This switches on the line search diving heuristic.

\textsl{(default = 0)}
\begin{itemize}
\item[0]
Turns the line search diving heuristics off.
\item[1]
Turns the linesearch diving heuristics on.
\end{itemize}

\item[\label{divingpseudocost}\hypertarget{divingpseudocost}
{\textbf{divingpseudocost (\slshape{integer})}}]\hspace{1.0in}

This switches on the pseudo costs diving heuristic.

\textsl{(default = 0)}
\begin{itemize}
\item[0]
Turns the pseudo costs diving heuristics off.
\item[1]
Turns the pseudo costs diving heuristics on.
\end{itemize}

\item[\label{divingvectorlength}\hypertarget{divingvectorlength}
{\textbf{divingvectorlength (\slshape{integer})}}]\hspace{1.0in}

This switches on the vector length diving heuristic.

\textsl{(default = 0)}
\begin{itemize}
\item[0]
Turns the vector length diving heuristics off.
\item[1]
Turns the vector length diving heuristics on.
\end{itemize}

\item[\label{feaspump}\hypertarget{feaspump}
{\textbf{feaspump (\slshape{integer})}}]\hspace{1.0in}

This parameter control the use of the feasibility pump heuristic at the root.

This is due to Fischetti and Lodi and uses a sequence of LPs to try and get an integer feasible solution.
Some fine tuning is available by the option \hyperlink{feaspump_passes}{feaspump\_passes}.
Reference: M. Fischetti, F. Glover, and A. Lodi, The feasibility pump, Math. Programming, 104 (2005), pp. 91-104.

\textsl{(default = 1)}
\begin{itemize}
\item[0] 
Turns the feasibility pump off.
\item[1] 
Turns the feasibility pump on.
\end{itemize}

\item[\label{feaspump_passes}\hypertarget{feaspump_passes}
{\textbf{feaspump\_passes (\slshape{integer})}}]\hspace{1.0in}

This fine tunes the feasibility pump heuristic by setting the number of passes.

\textsl{(default = 20)}

\item[\label{greedyheuristic}\hypertarget{greedyheuristic}
{\textbf{greedyheuristic (\slshape{string})}}]\hspace{1.0in}

This parameter control the use of a pair of greedy heuristic which will try to obtain a solution.
It may just fix a percentage of variables and then try a small branch and cut run.

\textsl{(default = on)}
\begin{itemize}
\item[off] 
Turns off the greedy heuristic.
\item[on] 
Turns on the greedy heuristic.
\item[root] 
Turns on the greedy heuristic only for the root node.
\end{itemize}

\item[\label{localtreesearch}\hypertarget{localtreesearch}
{\textbf{localtreesearch (\slshape{integer})}}]\hspace{1.0in}

This parameter control the use of a local search algorithm when a solution is found.

It is from Fischetti and Lodi and is not really a heuristic although it can be used as one (with limited functionality).
This heuristic is not controlled by the option \hyperlink{heuristics}{heuristics}.

Reference: M. Fischetti and A. Lodi, Local Branching, Math. Programming B, 98 (2003), pp. 23-47.

\textsl{(default = 0)}
\begin{itemize}
\item[0] 
Turns the local tree search off.
\item[1] 
Turns the local tree search on.
\end{itemize}

\item[\label{naiveheuristics}\hypertarget{naiveheuristics}
{\textbf{naiveheuristics (\slshape{integer})}}]\hspace{1.0in}

This parameter controls the use of some naive heuristics, e.g., fixing of all integers with costs to zero.<BR$>$

\textsl{(default = 0)}
\begin{itemize}
\item[0] 
Turns the naive heuristics off.
\item[1] 
Turns the naive heuristics on.
\end{itemize}

\item[\label{randomizedrounding}\hypertarget{randomizedrounding}
{\textbf{randomizedrounding (\slshape{integer})}}]\hspace{1.0in}

This parameter controls the use of the randomized rounding heuristic.

\textsl{(default = 0)}
\begin{itemize}
\item[0] 
Turns the randomized rounding heuristic off.
\item[1] 
Turns the randomized rounding heuristic on.
\end{itemize}

\item[\label{rens}\hypertarget{rens}
{\textbf{rens (\slshape{integer})}}]\hspace{1.0in}

This parameter controls the use of the relaxation enforced neighborhood search heuristic.

\textsl{(default = 0)}
\begin{itemize}
\item[0] 
Turns the relaxation enforced neighborhood search off.
\item[1] 
Turns the relaxation enforced neighborhood search on.
\end{itemize}

\item[\label{pivotandfix}\hypertarget{pivotandfix}
{\textbf{pivotandfix (\slshape{integer})}}]\hspace{1.0in}

This parameter controls the use of the pivot and fix heuristic.

\textsl{(default = 0)}
\begin{itemize}
\item[0] 
Turns the naive pivot and fix heuristic off.
\item[1] 
Turns the naive pivot and fix heuristic on.
\end{itemize}

\item[\label{rins}\hypertarget{rins}
{\textbf{rins (\slshape{integer})}}]\hspace{1.0in}

This parameter control the use of the relaxed induced neighborhood search heuristic.

This heuristic compares the current solution with the best incumbent, fixes all discrete variables with the same value, presolves the problem, and does a branch and bound for 200 nodes.

Reference: E. Danna, E. Rothberg, and C. Le Pape, Exploring relaxation induced neighborhoods to improve MIP solutions, Math. Programming, 102 (1) (2005), pp. 71-91.

\textsl{(default = 0)}
\begin{itemize}
\item[0] 
Turns the relaxed induced neighborhood search off.
\item[1] 
Turns the relaxed induced neighborhood search on.
\end{itemize}

\item[\label{roundingheuristic}\hypertarget{roundingheuristic}
{\textbf{roundingheuristic (\slshape{integer})}}]\hspace{1.0in}

This parameter control the use of a simple (but effective) rounding heuristic at each node of tree.

\textsl{(default = 1)}
\begin{itemize}
\item[0] 
Turns the rounding heuristic off.
\item[1] 
Turns the rounding heuristic on.
\end{itemize}

\item[\label{vubheuristic}\hypertarget{vubheuristic}
{\textbf{vubheuristic (\slshape{integer})}}]\hspace{1.0in}

This parameter control the use of the VUB heuristic.
If it is set (between -2 and 20), Cbc will try  and fix some integer variables

\textsl{(default = -1)}

\end{description}

% \subsubsection{MIP Options for the GAMS Branch Cut and Heuristic Facility}
% 
% \begin{description}
% \item[\label{usercutcall}\hypertarget{usercutcall}
% {\textbf{usercutcall (\slshape{string})}}]\hspace{1.0in}
% 
% The GAMS command line (minus the gams executable name) to call the cut generator.
% 
% 
% \item[\label{usercutfirst}\hypertarget{usercutfirst}
% {\textbf{usercutfirst (\slshape{integer})}}]\hspace{1.0in}
% 
% Calls the cut generator for the first $n$ nodes.
% 
% \textsl{(default = 10)}
% 
% \item[\label{usercutfreq}\hypertarget{usercutfreq}
% {\textbf{usercutfreq (\slshape{integer})}}]\hspace{1.0in}
% 
% Determines the frequency of the cut generator model calls.
% 
% \textsl{(default = 10)}
% 
% \item[\label{usercutinterval}\hypertarget{usercutinterval}
% {\textbf{usercutinterval (\slshape{integer})}}]\hspace{1.0in}
% 
% Determines the interval when to apply the multiplier for the frequency of the cut generator model calls.
% See userheurinterval for details.
% 
% \textsl{(default = 100)}
% 
% \item[\label{usercutmult}\hypertarget{usercutmult}
% {\textbf{usercutmult (\slshape{integer})}}]\hspace{1.0in}
% 
% Determines the multiplier for the frequency of the cut generator model calls.
% 
% \textsl{(default = 2)}
% 
% \item[\label{usercutnewint}\hypertarget{usercutnewint}
% {\textbf{usercutnewint (\slshape{integer})}}]\hspace{1.0in}
% 
% Calls the cut generator if the solver found a new integer feasible solution.
% 
% \textsl{(default = 1)}
% \begin{itemize}
% \item[0]
% Do not call cut generator because a new integer feasible solution is found.
% \item[1]
% Let CBC call the cut generator if a new integer feasible solution is found.
% \end{itemize}
% 
% \item[\label{usergdxin}\hypertarget{usergdxin}
% {\textbf{usergdxin (\slshape{string})}}]\hspace{1.0in}
% 
% The name of the GDX file read back into CBC.
% 
% \textsl{(default =} \verb=bchin.gdx=)
% 
% \item[\label{usergdxname}\hypertarget{usergdxname}
% {\textbf{usergdxname (\slshape{string})}}]\hspace{1.0in}
% 
% The name of the GDX file exported from the solver with the solution at the node.
% 
% \textsl{(default =} \verb=bchout.gdx=)
% 
% \item[\label{usergdxnameinc}\hypertarget{usergdxnameinc}
% {\textbf{usergdxnameinc (\slshape{string})}}]\hspace{1.0in}
% 
% The name of the GDX file exported from the solver with the incumbent solution.
% 
% \textsl{(default =} \verb=bchout_i.gdx=)
% 
% \item[\label{usergdxprefix}\hypertarget{usergdxprefix}
% {\textbf{usergdxprefix (\slshape{string})}}]\hspace{1.0in}
% 
% Prefixes to use for usergdxin, usergdxname, and usergdxnameinc.
% 
% 
% \item[\label{userheurcall}\hypertarget{userheurcall}
% {\textbf{userheurcall (\slshape{string})}}]\hspace{1.0in}
% 
% The GAMS command line (minus the gams executable name) to call the heuristic.
% 
% 
% \item[\label{userheurfirst}\hypertarget{userheurfirst}
% {\textbf{userheurfirst (\slshape{integer})}}]\hspace{1.0in}
% 
% Calls the heuristic for the first n nodes.
% 
% \textsl{(default = 10)}
% 
% \item[\label{userheurfreq}\hypertarget{userheurfreq}
% {\textbf{userheurfreq (\slshape{integer})}}]\hspace{1.0in}
% 
% Determines the frequency of the heuristic model calls.
% 
% \textsl{(default = 10)}
% 
% \item[\label{userheurinterval}\hypertarget{userheurinterval}
% {\textbf{userheurinterval (\slshape{integer})}}]\hspace{1.0in}
% 
% Determines the interval when to apply the multiplier for the frequency of the heuristic model calls.
% For example, for the first 100 (userheurinterval) nodes, the solver call every 10th (userheurfreq) node
% the heuristic.
% After 100 nodes, the frequency gets multiplied by 10 (userheurmult), so that for the next 100 node the solver calls the heuristic every 20th node.
% For nodes 200-300, the heuristic get called every 40th node, for nodes 300-400 every 80th node and after node 400 every 100th node.
% 
% \textsl{(default = 100)}
% 
% \item[\label{userheurmult}\hypertarget{userheurmult}
% {\textbf{userheurmult (\slshape{integer})}}]\hspace{1.0in}
% 
% Determines the multiplier for the frequency of the heuristic model calls.
% 
% \textsl{(default = 2)}
% 
% \item[\label{userheurnewint}\hypertarget{userheurnewint}
% {\textbf{userheurnewint (\slshape{integer})}}]\hspace{1.0in}
% 
% Calls the heuristic if the solver found a new integer feasible solution.
% 
% \textsl{(default = 1)}
% \begin{itemize}
% \item[0]
% Do not call heuristic because a new integer feasible solution is found.
% \item[1]
% Let CBC call the heuristic if a new integer feasible solution is found.
% \end{itemize}
% 
% \item[\label{userheurobjfirst}\hypertarget{userheurobjfirst}
% {\textbf{userheurobjfirst (\slshape{integer})}}]\hspace{1.0in}
% 
% Similar to userheurfirst but only calls the heuristic if the relaxed objective value promises a significant improvement of the current incumbent, i.e., the LP value of the node has to be closer to the best bound than the current incumbent.
% 
% \textsl{(default = 0)}
% 
% \item[\label{userjobid}\hypertarget{userjobid}
% {\textbf{userjobid (\slshape{string})}}]\hspace{1.0in}
% 
% Postfixes to use for gdxname, gdxnameinc, and gdxin.
% 
% 
% \item[\label{userkeep}\hypertarget{userkeep}
% {\textbf{userkeep (\slshape{integer})}}]\hspace{1.0in}
% 
% Calls gamskeep instead of gams
% 
% \textsl{(default = 0)}
% 
% \end{description}
