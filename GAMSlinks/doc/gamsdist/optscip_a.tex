\printoptioncategory{GAMS interface specific options}
\printoption{gams/dumpsolutions}%
{string}%
{}%
{name of solutions index gdx file for writing all solutions}%
{}

\printoption{gams/indicatorfile}%
{string}%
{}%
{name of GAMS options file that contains definitions on indicators}%
{}

\printoption{gams/interactive}%
{string}%
{}%
{command to be issued to the SCIP shell instead of issuing a solve command}%
{}

\printoption{gams/mipstart}%
{boolean}%
{TRUE}%
{whether to try GAMS variable level values as initial primal solution}%
{}

\printoption{gams/resolvenlp}%
{boolean}%
{TRUE}%
{whether to resolve MINLP with fixed discrete variables if best solution violates some constraints}%
{}

\printoption{gams/solvetrace/file}%
{string}%
{}%
{name of file where to write branch-and-bound trace information too}%
{}

\printoption{gams/solvetrace/nodefreq}%
{$0\leq\textrm{integer}$}%
{$100$}%
{frequency in number of nodes when to write branch-and-bound trace information, 0 to disable}%
{}

\printoption{gams/solvetrace/timefreq}%
{$0\leq\textrm{real}$}%
{$5$}%
{frequency in seconds when to write branch-and-bound trace information, 0.0 to disable}%
{}

\printoptioncategory{Branching}
\printoption{branching/allfullstrong/maxbounddist}%
{$0\leq\textrm{real}\leq1$}%
{$1$}%
{maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying branching rule (0.0: only on current best node, 1.0: on all nodes)}%
{}

\printoption{branching/allfullstrong/maxdepth}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal depth level, up to which branching rule $<$allfullstrong$>$ should be used (-1 for no limit)}%
{}

\printoption{branching/allfullstrong/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$-1000$}%
{priority of branching rule $<$allfullstrong$>$}%
{}

\printoption{branching/clamp}%
{$0\leq\textrm{real}\leq0.5$}%
{$0.2$}%
{minimal relative distance of branching point to bounds when branching on a continuous variable}%
{}

\printoption{branching/delaypscostupdate}%
{boolean}%
{TRUE}%
{should updating pseudo costs for continuous variables be delayed to the time after separation?}%
{}

\printoption{branching/fullstrong/maxbounddist}%
{$0\leq\textrm{real}\leq1$}%
{$1$}%
{maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying branching rule (0.0: only on current best node, 1.0: on all nodes)}%
{}

\printoption{branching/fullstrong/maxdepth}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal depth level, up to which branching rule $<$fullstrong$>$ should be used (-1 for no limit)}%
{}

\printoption{branching/fullstrong/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$0$}%
{priority of branching rule $<$fullstrong$>$}%
{}

\printoption{branching/inference/maxbounddist}%
{$0\leq\textrm{real}\leq1$}%
{$1$}%
{maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying branching rule (0.0: only on current best node, 1.0: on all nodes)}%
{}

\printoption{branching/inference/maxdepth}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal depth level, up to which branching rule $<$inference$>$ should be used (-1 for no limit)}%
{}

\printoption{branching/inference/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$1000$}%
{priority of branching rule $<$inference$>$}%
{}

\printoption{branching/inference/useweightedsum}%
{boolean}%
{TRUE}%
{should a weighted sum of inference, conflict and cutoff weights be used?}%
{}

\printoption{branching/leastinf/maxbounddist}%
{$0\leq\textrm{real}\leq1$}%
{$1$}%
{maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying branching rule (0.0: only on current best node, 1.0: on all nodes)}%
{}

\printoption{branching/leastinf/maxdepth}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal depth level, up to which branching rule $<$leastinf$>$ should be used (-1 for no limit)}%
{}

\printoption{branching/leastinf/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$50$}%
{priority of branching rule $<$leastinf$>$}%
{}

\printoption{branching/lpgainnormalize}%
{character}%
{s}%
{strategy for normalization of LP gain when updating pseudocosts of continuous variables (divide by movement of 'l'p value, reduction in 'd'omain width, or reduction in domain width of 's'ibling)}%
{}

\printoption{branching/mostinf/maxbounddist}%
{$0\leq\textrm{real}\leq1$}%
{$1$}%
{maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying branching rule (0.0: only on current best node, 1.0: on all nodes)}%
{}

\printoption{branching/mostinf/maxdepth}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal depth level, up to which branching rule $<$mostinf$>$ should be used (-1 for no limit)}%
{}

\printoption{branching/mostinf/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$100$}%
{priority of branching rule $<$mostinf$>$}%
{}

\printoption{branching/preferbinary}%
{boolean}%
{FALSE}%
{should branching on binary variables be preferred?}%
{}

\printoption{branching/pscost/maxbounddist}%
{$0\leq\textrm{real}\leq1$}%
{$1$}%
{maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying branching rule (0.0: only on current best node, 1.0: on all nodes)}%
{}

\printoption{branching/pscost/maxdepth}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal depth level, up to which branching rule $<$pscost$>$ should be used (-1 for no limit)}%
{}

\printoption{branching/pscost/narymaxdepth}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal depth where to do n-ary branching, -1 to turn off}%
{}

\printoption{branching/pscost/naryminwidth}%
{$0\leq\textrm{real}\leq1$}%
{$0.001$}%
{minimal domain width in children when doing n-ary branching, relative to global bounds}%
{}

\printoption{branching/pscost/narywidthfactor}%
{$1\leq\textrm{real}$}%
{$2$}%
{factor of domain width in n-ary branching when creating nodes with increasing distance from branching value}%
{}

\printoption{branching/pscost/nchildren}%
{$2\leq\textrm{integer}$}%
{$2$}%
{number of children to create in n-ary branching}%
{}

\printoption{branching/pscost/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$2000$}%
{priority of branching rule $<$pscost$>$}%
{}

\printoption{branching/pscost/strategy}%
{character}%
{u}%
{strategy for utilizing pseudo-costs of external branching candidates (multiply as in pseudo costs 'u'pdate rule, or by 'd'omain reduction, or by domain reduction of 's'ibling, or by 'v'ariable score)}%
{}

\printoption{branching/random/maxbounddist}%
{$0\leq\textrm{real}\leq1$}%
{$1$}%
{maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying branching rule (0.0: only on current best node, 1.0: on all nodes)}%
{}

\printoption{branching/random/maxdepth}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal depth level, up to which branching rule $<$random$>$ should be used (-1 for no limit)}%
{}

\printoption{branching/random/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$-100000$}%
{priority of branching rule $<$random$>$}%
{}

\printoption{branching/random/seed}%
{$0\leq\textrm{integer}$}%
{$0$}%
{initial random seed value}%
{}

\printoption{branching/relpscost/initcand}%
{$0\leq\textrm{integer}$}%
{$100$}%
{maximal number of candidates initialized with strong branching per node}%
{}

\printoption{branching/relpscost/inititer}%
{$0\leq\textrm{integer}$}%
{$0$}%
{iteration limit for strong branching initializations of pseudo cost entries (0: auto)}%
{}

\printoption{branching/relpscost/maxbounddist}%
{$0\leq\textrm{real}\leq1$}%
{$1$}%
{maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying branching rule (0.0: only on current best node, 1.0: on all nodes)}%
{}

\printoption{branching/relpscost/maxdepth}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal depth level, up to which branching rule $<$relpscost$>$ should be used (-1 for no limit)}%
{}

\printoption{branching/relpscost/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$10000$}%
{priority of branching rule $<$relpscost$>$}%
{}

\printoption{branching/relpscost/sbiterofs}%
{$0\leq\textrm{integer}$}%
{$100000$}%
{additional number of allowed strong branching LP iterations}%
{}

\printoption{branching/relpscost/sbiterquot}%
{$0\leq\textrm{real}$}%
{$0.5$}%
{maximal fraction of strong branching LP iterations compared to node relaxation LP iterations}%
{}

\printoptioncategory{Branching (advanced options)}
\printoption{branching/fullstrong/reevalage}%
{$0\leq\textrm{integer}$}%
{$10$}%
{number of intermediate LPs solved to trigger reevaluation of strong branching value for a variable that was already evaluated at the current node}%
{}

\printoption{branching/inference/conflictweight}%
{$0\leq\textrm{real}$}%
{$1000$}%
{weight in score calculations for conflict score}%
{}

\printoption{branching/inference/cutoffweight}%
{$0\leq\textrm{real}$}%
{$1$}%
{weight in score calculations for cutoff score}%
{}

\printoption{branching/inference/fractionals}%
{boolean}%
{TRUE}%
{should branching on LP solution be restricted to the fractional variables?}%
{}

\printoption{branching/inference/inferenceweight}%
{$\textrm{real}$}%
{$1$}%
{weight in score calculations for inference score}%
{}

\printoption{branching/pscost/maxscoreweight}%
{$\textrm{real}$}%
{$1.3$}%
{weight for maximum of scores of a branching candidate when building weighted sum of min/max/sum of scores}%
{}

\printoption{branching/pscost/minscoreweight}%
{$\textrm{real}$}%
{$0.8$}%
{weight for minimum of scores of a branching candidate when building weighted sum of min/max/sum of scores}%
{}

\printoption{branching/pscost/sumscoreweight}%
{$\textrm{real}$}%
{$0.1$}%
{weight for sum of scores of a branching candidate when building weighted sum of min/max/sum of scores}%
{}

\printoption{branching/relpscost/conflictlengthweight}%
{$\textrm{real}$}%
{$0$}%
{weight in score calculations for conflict length score}%
{}

\printoption{branching/relpscost/conflictweight}%
{$\textrm{real}$}%
{$0.01$}%
{weight in score calculations for conflict score}%
{}

\printoption{branching/relpscost/cutoffweight}%
{$\textrm{real}$}%
{$0.0001$}%
{weight in score calculations for cutoff score}%
{}

\printoption{branching/relpscost/inferenceweight}%
{$\textrm{real}$}%
{$0.0001$}%
{weight in score calculations for inference score}%
{}

\printoption{branching/relpscost/maxbdchgs}%
{$-1\leq\textrm{integer}$}%
{$5$}%
{maximal number of bound tightenings before the node is reevaluated (-1: unlimited)}%
{}

\printoption{branching/relpscost/maxlookahead}%
{$1\leq\textrm{integer}$}%
{$8$}%
{maximal number of further variables evaluated without better score}%
{}

\printoption{branching/relpscost/maxreliable}%
{$0\leq\textrm{real}$}%
{$8$}%
{maximal value for minimum pseudo cost size to regard pseudo cost value as reliable}%
{}

\printoption{branching/relpscost/minreliable}%
{$0\leq\textrm{real}$}%
{$1$}%
{minimal value for minimum pseudo cost size to regard pseudo cost value as reliable}%
{}

\printoption{branching/relpscost/pscostweight}%
{$\textrm{real}$}%
{$1$}%
{weight in score calculations for pseudo cost score}%
{}

\printoption{branching/scorefac}%
{$0\leq\textrm{real}\leq1$}%
{$0.167$}%
{branching score factor to weigh downward and upward gain prediction in sum score function}%
{}

\printoption{branching/scorefunc}%
{character}%
{p}%
{branching score function ('s'um, 'p'roduct)}%
{}

\printoptioncategory{Conflict analysis}
\printoption{conflict/bounddisjunction/continuousfrac}%
{$0\leq\textrm{real}\leq1$}%
{$0.4$}%
{maximal percantage of continuous variables within a conflict}%
{}

\printoption{conflict/enable}%
{boolean}%
{TRUE}%
{should conflict analysis be enabled?}%
{}

\printoption{conflict/preferbinary}%
{boolean}%
{FALSE}%
{should binary conflicts be preferred?}%
{}

\printoption{conflict/restartfac}%
{$0\leq\textrm{real}$}%
{$1.5$}%
{factor to increase restartnum with after each restart}%
{}

\printoption{conflict/restartnum}%
{$0\leq\textrm{integer}$}%
{$0$}%
{number of successful conflict analysis calls that trigger a restart (0: disable conflict restarts)}%
{}

\printoption{conflict/useboundlp}%
{boolean}%
{FALSE}%
{should bound exceeding LP conflict analysis be used?}%
{}

\printoption{conflict/useinflp}%
{boolean}%
{TRUE}%
{should infeasible LP conflict analysis be used?}%
{}

\printoption{conflict/useprop}%
{boolean}%
{TRUE}%
{should propagation conflict analysis be used?}%
{}

\printoption{conflict/usepseudo}%
{boolean}%
{TRUE}%
{should pseudo solution conflict analysis be used?}%
{}

\printoption{conflict/usesb}%
{boolean}%
{FALSE}%
{should infeasible/bound exceeding strong branching conflict analysis be used?}%
{}

\printoptioncategory{Conflict analysis (advanced options)}
\printoption{conflict/allowlocal}%
{boolean}%
{TRUE}%
{should conflict constraints be generated that are only valid locally?}%
{}

\printoption{conflict/bounddisjunction/priority}%
{$\textrm{integer}$}%
{$-3000000$}%
{priority of conflict handler $<$bounddisjunction$>$}%
{}

\printoption{conflict/depthscorefac}%
{$\textrm{real}$}%
{$1$}%
{score factor for depth level in bound relaxation heuristic of LP analysis}%
{}

\printoption{conflict/dynamic}%
{boolean}%
{TRUE}%
{should the conflict constraints be subject to aging?}%
{}

\printoption{conflict/fuiplevels}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{number of depth levels up to which first UIP's are used in conflict analysis (-1: use All-FirstUIP rule)}%
{}

\printoption{conflict/ignorerelaxedbd}%
{boolean}%
{FALSE}%
{should relaxed bounds be ignored?}%
{}

\printoption{conflict/indicatorconflict/priority}%
{$\textrm{integer}$}%
{$200000$}%
{priority of conflict handler $<$indicatorconflict$>$}%
{}

\printoption{conflict/interconss}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal number of intermediate conflict constraints generated in conflict graph (-1: use every intermediate constraint)}%
{}

\printoption{conflict/keepreprop}%
{boolean}%
{TRUE}%
{should constraints be kept for repropagation even if they are too long?}%
{}

\printoption{conflict/linear/priority}%
{$\textrm{integer}$}%
{$-1000000$}%
{priority of conflict handler $<$linear$>$}%
{}

\printoption{conflict/logicor/priority}%
{$\textrm{integer}$}%
{$800000$}%
{priority of conflict handler $<$logicor$>$}%
{}

\printoption{conflict/lpiterations}%
{$-1\leq\textrm{integer}$}%
{$10$}%
{maximal number of LP iterations in each LP resolving loop (-1: no limit)}%
{}

\printoption{conflict/maxconss}%
{$-1\leq\textrm{integer}$}%
{$10$}%
{maximal number of conflict constraints accepted at an infeasible node (-1: use all generated conflict constraints)}%
{}

\printoption{conflict/maxlploops}%
{$-1\leq\textrm{integer}$}%
{$2$}%
{maximal number of LP resolving loops during conflict analysis (-1: no limit)}%
{}

\printoption{conflict/maxvarsfac}%
{$0\leq\textrm{real}$}%
{$0.1$}%
{maximal fraction of variables involved in a conflict constraint}%
{}

\printoption{conflict/minmaxvars}%
{$0\leq\textrm{integer}$}%
{$30$}%
{minimal absolute maximum of variables involved in a conflict constraint}%
{}

\printoption{conflict/reconvlevels}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{number of depth levels up to which UIP reconvergence constraints are generated (-1: generate reconvergence constraints in all depth levels)}%
{}

\printoption{conflict/removable}%
{boolean}%
{TRUE}%
{should the conflict's relaxations be subject to LP aging and cleanup?}%
{}

\printoption{conflict/repropagate}%
{boolean}%
{TRUE}%
{should earlier nodes be repropagated in order to replace branching decisions by deductions?}%
{}

\printoption{conflict/scorefac}%
{$10^{- 6}\leq\textrm{real}\leq1$}%
{$0.98$}%
{factor to decrease importance of variables' earlier conflict scores}%
{}

\printoption{conflict/separate}%
{boolean}%
{TRUE}%
{should the conflict constraints be separated?}%
{}

\printoption{conflict/setppc/priority}%
{$\textrm{integer}$}%
{$700000$}%
{priority of conflict handler $<$setppc$>$}%
{}

\printoption{conflict/settlelocal}%
{boolean}%
{FALSE}%
{should conflict constraints be attached only to the local subtree where they can be useful?}%
{}

\printoptioncategory{Constraints}
\printoption{constraints/abspower/branchminconverror}%
{boolean}%
{FALSE}%
{whether to compute branching point such that the convexification error is minimized (after branching on 0.0)}%
{}

\printoption{constraints/abspower/cutmaxrange}%
{$0\leq\textrm{real}$}%
{$10^{  7}$}%
{maximal coef range of a cut (maximal coefficient divided by minimal coefficient) in order to be added to LP relaxation}%
{}

\printoption{constraints/abspower/dualpresolve}%
{boolean}%
{TRUE}%
{should dual presolve be applied?}%
{}

\printoption{constraints/abspower/linfeasshift}%
{boolean}%
{TRUE}%
{whether to try to make solutions in check function feasible by shifting the linear variable z}%
{}

\printoption{constraints/abspower/minefficacyenfofac}%
{$1\leq\textrm{real}$}%
{$2$}%
{minimal target efficacy of a cut in order to add it to relaxation during enforcement as factor of feasibility tolerance (may be ignored)}%
{}

\printoption{constraints/abspower/minefficacysepa}%
{$0\leq\textrm{real}$}%
{$0.0001$}%
{minimal efficacy for a cut to be added to the LP during separation; overwrites separating/efficacy}%
{}

\printoption{constraints/abspower/preferzerobranch}%
{$0\leq\textrm{integer}\leq3$}%
{$1$}%
{how much to prefer branching on 0.0 when sign of variable is not fixed yet: 0 no preference, 1 prefer if LP solution will be cutoff in both child nodes, 2 prefer always, 3 ensure always}%
{}

\printoption{constraints/abspower/projectrefpoint}%
{boolean}%
{TRUE}%
{whether to project the reference point when linearizing an absolute power constraint in a convex region}%
{}

\printoption{constraints/abspower/propfreq}%
{$-1\leq\textrm{integer}$}%
{$1$}%
{frequency for propagating domains (-1: never, 0: only in root node)}%
{}

\printoption{constraints/abspower/sepafreq}%
{$-1\leq\textrm{integer}$}%
{$1$}%
{frequency for separating cuts (-1: never, 0: only in root node)}%
{}

\printoption{constraints/abspower/sepainboundsonly}%
{boolean}%
{FALSE}%
{whether to separate linearization cuts only in the variable bounds (does not affect enforcement)}%
{}

\printoption{constraints/abspower/sepanlpmincont}%
{$0\leq\textrm{real}\leq2$}%
{$1$}%
{minimal required fraction of continuous variables in problem to use solution of NLP relaxation in root for separation}%
{}

\printoption{constraints/and/propfreq}%
{$-1\leq\textrm{integer}$}%
{$1$}%
{frequency for propagating domains (-1: never, 0: only in root node)}%
{}

\printoption{constraints/and/sepafreq}%
{$-1\leq\textrm{integer}$}%
{$1$}%
{frequency for separating cuts (-1: never, 0: only in root node)}%
{}

\printoption{constraints/bivariate/linfeasshift}%
{boolean}%
{TRUE}%
{whether to try to make solutions in check function feasible by shifting a linear variable (esp. useful if constraint was actually objective function)}%
{}

\printoption{constraints/bivariate/maxproprounds}%
{$0\leq\textrm{integer}$}%
{$1$}%
{limit on number of propagation rounds for a single constraint within one round of SCIP propagation}%
{}

\printoption{constraints/bivariate/minefficacyenfo}%
{$0\leq\textrm{real}$}%
{$2 \cdot 10^{- 6}$}%
{minimal target efficacy of a cut in order to add it to relaxation during enforcement (may be ignored)}%
{}

\printoption{constraints/bivariate/minefficacysepa}%
{$0\leq\textrm{real}$}%
{$0.0001$}%
{minimal efficacy for a cut to be added to the LP during separation; overwrites separating/efficacy}%
{}

\printoption{constraints/bivariate/ninitlprefpoints}%
{$0\leq\textrm{integer}$}%
{$3$}%
{number of reference points in each direction where to compute linear support for envelope in LP initialization}%
{}

\printoption{constraints/bivariate/propfreq}%
{$-1\leq\textrm{integer}$}%
{$1$}%
{frequency for propagating domains (-1: never, 0: only in root node)}%
{}

\printoption{constraints/bivariate/sepafreq}%
{$-1\leq\textrm{integer}$}%
{$1$}%
{frequency for separating cuts (-1: never, 0: only in root node)}%
{}

\printoption{constraints/bounddisjunction/propfreq}%
{$-1\leq\textrm{integer}$}%
{$1$}%
{frequency for propagating domains (-1: never, 0: only in root node)}%
{}

\printoption{constraints/bounddisjunction/sepafreq}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{frequency for separating cuts (-1: never, 0: only in root node)}%
{}

\printoption{constraints/indicator/maxsepacuts}%
{$0\leq\textrm{integer}$}%
{$100$}%
{maximal number of cuts separated per separation round}%
{}

\printoption{constraints/indicator/maxsepacutsroot}%
{$0\leq\textrm{integer}$}%
{$2000$}%
{maximal number of cuts separated per separation round in the root node}%
{}

\printoption{constraints/indicator/propfreq}%
{$-1\leq\textrm{integer}$}%
{$1$}%
{frequency for propagating domains (-1: never, 0: only in root node)}%
{}

\printoption{constraints/indicator/sepafreq}%
{$-1\leq\textrm{integer}$}%
{$10$}%
{frequency for separating cuts (-1: never, 0: only in root node)}%
{}

\printoption{constraints/integral/propfreq}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{frequency for propagating domains (-1: never, 0: only in root node)}%
{}

\printoption{constraints/integral/sepafreq}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{frequency for separating cuts (-1: never, 0: only in root node)}%
{}

\printoption{constraints/knapsack/maxrounds}%
{$-1\leq\textrm{integer}$}%
{$5$}%
{maximal number of separation rounds per node (-1: unlimited)}%
{}

\printoption{constraints/knapsack/maxroundsroot}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal number of separation rounds per node in the root node (-1: unlimited)}%
{}

\printoption{constraints/knapsack/maxsepacuts}%
{$0\leq\textrm{integer}$}%
{$50$}%
{maximal number of cuts separated per separation round}%
{}

\printoption{constraints/knapsack/maxsepacutsroot}%
{$0\leq\textrm{integer}$}%
{$200$}%
{maximal number of cuts separated per separation round in the root node}%
{}

\printoption{constraints/knapsack/propfreq}%
{$-1\leq\textrm{integer}$}%
{$1$}%
{frequency for propagating domains (-1: never, 0: only in root node)}%
{}

\printoption{constraints/knapsack/sepafreq}%
{$-1\leq\textrm{integer}$}%
{$0$}%
{frequency for separating cuts (-1: never, 0: only in root node)}%
{}

\printoption{constraints/linear/maxrounds}%
{$-1\leq\textrm{integer}$}%
{$5$}%
{maximal number of separation rounds per node (-1: unlimited)}%
{}

\printoption{constraints/linear/maxroundsroot}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal number of separation rounds per node in the root node (-1: unlimited)}%
{}

\printoption{constraints/linear/maxsepacuts}%
{$0\leq\textrm{integer}$}%
{$50$}%
{maximal number of cuts separated per separation round}%
{}

\printoption{constraints/linear/maxsepacutsroot}%
{$0\leq\textrm{integer}$}%
{$200$}%
{maximal number of cuts separated per separation round in the root node}%
{}

\printoption{constraints/linear/propfreq}%
{$-1\leq\textrm{integer}$}%
{$1$}%
{frequency for propagating domains (-1: never, 0: only in root node)}%
{}

\printoption{constraints/linear/sepafreq}%
{$-1\leq\textrm{integer}$}%
{$0$}%
{frequency for separating cuts (-1: never, 0: only in root node)}%
{}

\printoption{constraints/linear/separateall}%
{boolean}%
{FALSE}%
{should all constraints be subject to cardinality cut generation instead of only the ones with non-zero dual value?}%
{}

\printoption{constraints/linear/upgrade/knapsack}%
{boolean}%
{TRUE}%
{enable linear upgrading for constraint handler $<$knapsack$>$}%
{}

\printoption{constraints/linear/upgrade/logicor}%
{boolean}%
{TRUE}%
{enable linear upgrading for constraint handler $<$logicor$>$}%
{}

\printoption{constraints/linear/upgrade/setppc}%
{boolean}%
{TRUE}%
{enable linear upgrading for constraint handler $<$setppc$>$}%
{}

\printoption{constraints/linear/upgrade/varbound}%
{boolean}%
{TRUE}%
{enable linear upgrading for constraint handler $<$varbound$>$}%
{}

\printoption{constraints/logicor/propfreq}%
{$-1\leq\textrm{integer}$}%
{$1$}%
{frequency for propagating domains (-1: never, 0: only in root node)}%
{}

\printoption{constraints/logicor/sepafreq}%
{$-1\leq\textrm{integer}$}%
{$0$}%
{frequency for separating cuts (-1: never, 0: only in root node)}%
{}

\printoption{constraints/nonlinear/cutmaxrange}%
{$0\leq\textrm{real}$}%
{$10^{  7}$}%
{maximal coef range of a cut (maximal coefficient divided by minimal coefficient) in order to be added to LP relaxation}%
{}

\printoption{constraints/nonlinear/linfeasshift}%
{boolean}%
{TRUE}%
{whether to try to make solutions in check function feasible by shifting a linear variable (esp. useful if constraint was actually objective function)}%
{}

\printoption{constraints/nonlinear/maxproprounds}%
{$0\leq\textrm{integer}$}%
{$1$}%
{limit on number of propagation rounds for a single constraint within one round of SCIP propagation}%
{}

\printoption{constraints/nonlinear/propfreq}%
{$-1\leq\textrm{integer}$}%
{$1$}%
{frequency for propagating domains (-1: never, 0: only in root node)}%
{}

\printoption{constraints/nonlinear/reformulate}%
{boolean}%
{TRUE}%
{whether to reformulate expression graph}%
{}

\printoption{constraints/nonlinear/sepafreq}%
{$-1\leq\textrm{integer}$}%
{$1$}%
{frequency for separating cuts (-1: never, 0: only in root node)}%
{}

\printoption{constraints/nonlinear/sepanlpmincont}%
{$0\leq\textrm{real}\leq2$}%
{$1$}%
{minimal required fraction of continuous variables in problem to use solution of NLP relaxation in root for separation}%
{}

\printoption{constraints/nonlinear/upgrade/abspower}%
{boolean}%
{TRUE}%
{enable nonlinear upgrading for constraint handler $<$abspower$>$}%
{}

\printoption{constraints/nonlinear/upgrade/and}%
{boolean}%
{TRUE}%
{enable nonlinear upgrading for constraint handler $<$and$>$}%
{}

\printoption{constraints/nonlinear/upgrade/bivariate}%
{boolean}%
{FALSE}%
{enable nonlinear upgrading for constraint handler $<$bivariate$>$}%
{}

\printoption{constraints/nonlinear/upgrade/linear}%
{boolean}%
{TRUE}%
{enable nonlinear upgrading for constraint handler $<$linear$>$}%
{}

\printoption{constraints/nonlinear/upgrade/quadratic}%
{boolean}%
{TRUE}%
{enable nonlinear upgrading for constraint handler $<$quadratic$>$}%
{}

\printoption{constraints/quadratic/checkcurvature}%
{boolean}%
{TRUE}%
{whether multivariate quadratic functions should be checked for convexity/concavity}%
{}

\printoption{constraints/quadratic/empathy4and}%
{$0\leq\textrm{integer}\leq2$}%
{$0$}%
{empathy level for using the AND constraint handler: 0 always avoid using AND; 1 use AND sometimes; 2 use AND as often as possible}%
{}

\printoption{constraints/quadratic/propfreq}%
{$-1\leq\textrm{integer}$}%
{$1$}%
{frequency for propagating domains (-1: never, 0: only in root node)}%
{}

\printoption{constraints/quadratic/replacebinaryprod}%
{$0\leq\textrm{integer}$}%
{$\infty$}%
{max. length of linear term which when multiplied with a binary variables is replaced by an auxiliary variable and a linear reformulation (0 to turn off)}%
{}

\printoption{constraints/quadratic/sepafreq}%
{$-1\leq\textrm{integer}$}%
{$1$}%
{frequency for separating cuts (-1: never, 0: only in root node)}%
{}

\printoption{constraints/quadratic/sepanlpmincont}%
{$0\leq\textrm{real}\leq2$}%
{$1$}%
{minimal required fraction of continuous variables in problem to use solution of NLP relaxation in root for separation}%
{}

\printoption{constraints/quadratic/upgrade/abspower}%
{boolean}%
{TRUE}%
{enable quadratic upgrading for constraint handler $<$abspower$>$}%
{}

\printoption{constraints/quadratic/upgrade/bivariate}%
{boolean}%
{FALSE}%
{enable quadratic upgrading for constraint handler $<$bivariate$>$}%
{}

\printoption{constraints/quadratic/upgrade/bounddisjunction}%
{boolean}%
{TRUE}%
{enable quadratic upgrading for constraint handler $<$bounddisjunction$>$}%
{}

\printoption{constraints/quadratic/upgrade/linear}%
{boolean}%
{TRUE}%
{enable quadratic upgrading for constraint handler $<$linear$>$}%
{}

\printoption{constraints/quadratic/upgrade/soc}%
{boolean}%
{TRUE}%
{enable quadratic upgrading for constraint handler $<$soc$>$}%
{}

\printoption{constraints/setppc/propfreq}%
{$-1\leq\textrm{integer}$}%
{$1$}%
{frequency for propagating domains (-1: never, 0: only in root node)}%
{}

\printoption{constraints/setppc/sepafreq}%
{$-1\leq\textrm{integer}$}%
{$0$}%
{frequency for separating cuts (-1: never, 0: only in root node)}%
{}

\printoption{constraints/soc/glineur}%
{boolean}%
{TRUE}%
{whether the Glineur Outer Approximation should be used instead of Ben-Tal Nemirovski}%
{}

\printoption{constraints/soc/linfeasshift}%
{boolean}%
{TRUE}%
{whether to try to make solutions feasible in check by shifting the variable on the right hand side}%
{}

\printoption{constraints/soc/minefficacy}%
{$0\leq\textrm{real}$}%
{$0.0001$}%
{minimal efficacy of a cut to be added to LP in separation}%
{}

\printoption{constraints/soc/nauxvars}%
{$0\leq\textrm{integer}$}%
{$0$}%
{number of auxiliary variables to use when creating a linear outer approx. of a SOC3 constraint; 0 to turn off}%
{}

\printoption{constraints/soc/nlpform}%
{character}%
{a}%
{which formulation to use when adding a SOC constraint to the NLP (a: automatic, q: nonconvex quadratic form, s: convex sqrt form, e: convex exponential-sqrt form, d: convex division form)}%
{}

\printoption{constraints/soc/propfreq}%
{$-1\leq\textrm{integer}$}%
{$1$}%
{frequency for propagating domains (-1: never, 0: only in root node)}%
{}

\printoption{constraints/soc/sepafreq}%
{$-1\leq\textrm{integer}$}%
{$1$}%
{frequency for separating cuts (-1: never, 0: only in root node)}%
{}

\printoption{constraints/soc/sepanlpmincont}%
{$0\leq\textrm{real}\leq2$}%
{$1$}%
{minimal required fraction of continuous variables in problem to use solution of NLP relaxation in root for separation}%
{}

\printoption{constraints/SOS1/branchnonzeros}%
{boolean}%
{FALSE}%
{Branch on SOS constraint with most number of nonzeros?}%
{}

\printoption{constraints/SOS1/branchsos}%
{boolean}%
{TRUE}%
{Use SOS1 branching in enforcing (otherwise leave decision to branching rules)?}%
{}

\printoption{constraints/SOS1/branchweight}%
{boolean}%
{FALSE}%
{Branch on SOS cons. with highest nonzero-variable weight for branching (needs branchnonzeros = false)?}%
{}

\printoption{constraints/SOS1/propfreq}%
{$-1\leq\textrm{integer}$}%
{$1$}%
{frequency for propagating domains (-1: never, 0: only in root node)}%
{}

\printoption{constraints/SOS1/sepafreq}%
{$-1\leq\textrm{integer}$}%
{$0$}%
{frequency for separating cuts (-1: never, 0: only in root node)}%
{}

\printoption{constraints/SOS2/propfreq}%
{$-1\leq\textrm{integer}$}%
{$1$}%
{frequency for propagating domains (-1: never, 0: only in root node)}%
{}

\printoption{constraints/SOS2/sepafreq}%
{$-1\leq\textrm{integer}$}%
{$0$}%
{frequency for separating cuts (-1: never, 0: only in root node)}%
{}

\printoption{constraints/varbound/propfreq}%
{$-1\leq\textrm{integer}$}%
{$1$}%
{frequency for propagating domains (-1: never, 0: only in root node)}%
{}

\printoption{constraints/varbound/sepafreq}%
{$-1\leq\textrm{integer}$}%
{$0$}%
{frequency for separating cuts (-1: never, 0: only in root node)}%
{}

\printoption{constraints/varbound/usebdwidening}%
{boolean}%
{TRUE}%
{should bound widening be used in conflict analysis?}%
{}

\printoptioncategory{Constraints (advanced options)}
\printoption{constraints/abspower/addvarboundcons}%
{boolean}%
{TRUE}%
{should variable bound constraints be added for derived variable bounds?}%
{}

\printoption{constraints/abspower/delaypresol}%
{boolean}%
{FALSE}%
{should presolving method be delayed, if other presolvers found reductions?}%
{}

\printoption{constraints/abspower/delayprop}%
{boolean}%
{FALSE}%
{should propagation method be delayed, if other propagators found reductions?}%
{}

\printoption{constraints/abspower/delaysepa}%
{boolean}%
{FALSE}%
{should separation method be delayed, if other separators found cuts?}%
{}

\printoption{constraints/abspower/eagerfreq}%
{$-1\leq\textrm{integer}$}%
{$100$}%
{frequency for using all instead of only the useful constraints in separation, propagation and enforcement (-1: never, 0: only in first evaluation)}%
{}

\printoption{constraints/abspower/enfocutsremovable}%
{boolean}%
{FALSE}%
{are cuts added during enforcement removable from the LP in the same node?}%
{}

\printoption{constraints/abspower/maxprerounds}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal number of presolving rounds the constraint handler participates in (-1: no limit)}%
{}

\printoption{constraints/abspower/timingmask}%
{$1\leq\textrm{integer}\leq15$}%
{$15$}%
{timing when constraint propagation should be called (1:BEFORELP, 2:DURINGLPLOOP, 4:AFTERLPLOOP, 15:ALWAYS))}%
{}

\printoption{constraints/agelimit}%
{$-1\leq\textrm{integer}$}%
{$0$}%
{maximum age an unnecessary constraint can reach before it is deleted (0: dynamic, -1: keep all constraints)}%
{}

\printoption{constraints/and/aggrlinearization}%
{boolean}%
{FALSE}%
{should an aggregated linearization be used?}%
{}

\printoption{constraints/and/delaypresol}%
{boolean}%
{FALSE}%
{should presolving method be delayed, if other presolvers found reductions?}%
{}

\printoption{constraints/and/delayprop}%
{boolean}%
{FALSE}%
{should propagation method be delayed, if other propagators found reductions?}%
{}

\printoption{constraints/and/delaysepa}%
{boolean}%
{FALSE}%
{should separation method be delayed, if other separators found cuts?}%
{}

\printoption{constraints/and/dualpresolving}%
{boolean}%
{TRUE}%
{should dual presolving be performed?}%
{}

\printoption{constraints/and/eagerfreq}%
{$-1\leq\textrm{integer}$}%
{$100$}%
{frequency for using all instead of only the useful constraints in separation, propagation and enforcement (-1: never, 0: only in first evaluation)}%
{}

\printoption{constraints/and/enforcecuts}%
{boolean}%
{TRUE}%
{should cuts be separated during LP enforcing?}%
{}

\printoption{constraints/and/linearize}%
{boolean}%
{FALSE}%
{should the "and" constraint get linearized and removed (in presolving)?}%
{}

\printoption{constraints/and/maxprerounds}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal number of presolving rounds the constraint handler participates in (-1: no limit)}%
{}

\printoption{constraints/and/presolpairwise}%
{boolean}%
{TRUE}%
{should pairwise constraint comparison be performed in presolving?}%
{}

\printoption{constraints/and/presolusehashing}%
{boolean}%
{TRUE}%
{should hash table be used for detecting redundant constraints in advance}%
{}

\printoption{constraints/and/timingmask}%
{$1\leq\textrm{integer}\leq15$}%
{$1$}%
{timing when constraint propagation should be called (1:BEFORELP, 2:DURINGLPLOOP, 4:AFTERLPLOOP, 15:ALWAYS))}%
{}

\printoption{constraints/bivariate/cutmaxrange}%
{$0\leq\textrm{real}$}%
{$10^{  7}$}%
{maximal coef range of a cut (maximal coefficient divided by minimal coefficient) in order to be added to LP relaxation}%
{}

\printoption{constraints/bivariate/delaypresol}%
{boolean}%
{FALSE}%
{should presolving method be delayed, if other presolvers found reductions?}%
{}

\printoption{constraints/bivariate/delayprop}%
{boolean}%
{FALSE}%
{should propagation method be delayed, if other propagators found reductions?}%
{}

\printoption{constraints/bivariate/delaysepa}%
{boolean}%
{FALSE}%
{should separation method be delayed, if other separators found cuts?}%
{}

\printoption{constraints/bivariate/eagerfreq}%
{$-1\leq\textrm{integer}$}%
{$100$}%
{frequency for using all instead of only the useful constraints in separation, propagation and enforcement (-1: never, 0: only in first evaluation)}%
{}

\printoption{constraints/bivariate/enfocutsremovable}%
{boolean}%
{FALSE}%
{are cuts added during enforcement removable from the LP in the same node?}%
{}

\printoption{constraints/bivariate/maxprerounds}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal number of presolving rounds the constraint handler participates in (-1: no limit)}%
{}

\printoption{constraints/bivariate/timingmask}%
{$1\leq\textrm{integer}\leq15$}%
{$1$}%
{timing when constraint propagation should be called (1:BEFORELP, 2:DURINGLPLOOP, 4:AFTERLPLOOP, 15:ALWAYS))}%
{}

\printoption{constraints/bounddisjunction/delaypresol}%
{boolean}%
{FALSE}%
{should presolving method be delayed, if other presolvers found reductions?}%
{}

\printoption{constraints/bounddisjunction/delayprop}%
{boolean}%
{FALSE}%
{should propagation method be delayed, if other propagators found reductions?}%
{}

\printoption{constraints/bounddisjunction/delaysepa}%
{boolean}%
{FALSE}%
{should separation method be delayed, if other separators found cuts?}%
{}

\printoption{constraints/bounddisjunction/eagerfreq}%
{$-1\leq\textrm{integer}$}%
{$100$}%
{frequency for using all instead of only the useful constraints in separation, propagation and enforcement (-1: never, 0: only in first evaluation)}%
{}

\printoption{constraints/bounddisjunction/maxprerounds}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal number of presolving rounds the constraint handler participates in (-1: no limit)}%
{}

\printoption{constraints/bounddisjunction/timingmask}%
{$1\leq\textrm{integer}\leq15$}%
{$1$}%
{timing when constraint propagation should be called (1:BEFORELP, 2:DURINGLPLOOP, 4:AFTERLPLOOP, 15:ALWAYS))}%
{}

\printoption{constraints/disableenfops}%
{boolean}%
{FALSE}%
{should enforcement of pseudo solution be disabled?}%
{}

\printoption{constraints/indicator/addcoupling}%
{boolean}%
{TRUE}%
{Add coupling constraints if big-M is small enough?}%
{}

\printoption{constraints/indicator/addcouplingcons}%
{boolean}%
{FALSE}%
{Add initial coupling inequalities as linear constraints, if 'addcoupling' is true?}%
{}

\printoption{constraints/indicator/addopposite}%
{boolean}%
{FALSE}%
{Add opposite inequality in nodes in which the binary variable has been fixed to 0?}%
{}

\printoption{constraints/indicator/branchindicators}%
{boolean}%
{FALSE}%
{Branch on indicator constraints in enforcing?}%
{}

\printoption{constraints/indicator/conflictsupgrade}%
{boolean}%
{FALSE}%
{Try to upgrade bounddisjunction conflicts by replacing slack variables?}%
{}

\printoption{constraints/indicator/delaypresol}%
{boolean}%
{FALSE}%
{should presolving method be delayed, if other presolvers found reductions?}%
{}

\printoption{constraints/indicator/delayprop}%
{boolean}%
{FALSE}%
{should propagation method be delayed, if other propagators found reductions?}%
{}

\printoption{constraints/indicator/delaysepa}%
{boolean}%
{FALSE}%
{should separation method be delayed, if other separators found cuts?}%
{}

\printoption{constraints/indicator/dualreductions}%
{boolean}%
{TRUE}%
{should dual reduction steps be performed?}%
{}

\printoption{constraints/indicator/eagerfreq}%
{$-1\leq\textrm{integer}$}%
{$100$}%
{frequency for using all instead of only the useful constraints in separation, propagation and enforcement (-1: never, 0: only in first evaluation)}%
{}

\printoption{constraints/indicator/enforcecuts}%
{boolean}%
{FALSE}%
{In enforcing try to generate cuts (only if sepaalternativelp is true)?}%
{}

\printoption{constraints/indicator/forcerestart}%
{boolean}%
{FALSE}%
{force restart if we have a max FS instance and gap is 1?}%
{}

\printoption{constraints/indicator/generatebilinear}%
{boolean}%
{FALSE}%
{Do not generate indicator constraint, but a bilinear constraint instead?}%
{}

\printoption{constraints/indicator/genlogicor}%
{boolean}%
{FALSE}%
{Generate logicor constraints instead of cuts?}%
{}

\printoption{constraints/indicator/maxconditionaltlp}%
{$0\leq\textrm{real}$}%
{$0$}%
{maximum estimated condition of the solution basis matrix of the alternative LP to be trustworthy (0.0 to disable check)}%
{}

\printoption{constraints/indicator/maxcouplingvalue}%
{$0\leq\textrm{real}\leq10^{  9}$}%
{$10000$}%
{maximum coefficient for binary variable in coupling constraint}%
{}

\printoption{constraints/indicator/maxprerounds}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal number of presolving rounds the constraint handler participates in (-1: no limit)}%
{}

\printoption{constraints/indicator/nolinconscont}%
{boolean}%
{FALSE}%
{decompose problem - do not generate linear constraint if all variables are continuous}%
{}

\printoption{constraints/indicator/removeindicators}%
{boolean}%
{FALSE}%
{Remove indicator constraint if corresponding variable bound constraint has been added?}%
{}

\printoption{constraints/indicator/restartfrac}%
{$0\leq\textrm{real}\leq1$}%
{$0.9$}%
{fraction of binary variables that need to be fixed before restart occurs (in forcerestart)}%
{}

\printoption{constraints/indicator/sepaalternativelp}%
{boolean}%
{FALSE}%
{Separate using the alternative LP?}%
{}

\printoption{constraints/indicator/sepacouplingcuts}%
{boolean}%
{FALSE}%
{Should the coupling inequalities be separated dynamically?}%
{}

\printoption{constraints/indicator/sepacouplinglocal}%
{boolean}%
{FALSE}%
{Allow to use local bounds in order to separated coupling inequalities?}%
{}

\printoption{constraints/indicator/sepacouplingvalue}%
{$0\leq\textrm{real}\leq10^{  9}$}%
{$10000$}%
{maximum coefficient for binary variable in separated coupling constraint}%
{}

\printoption{constraints/indicator/timingmask}%
{$1\leq\textrm{integer}\leq15$}%
{$1$}%
{timing when constraint propagation should be called (1:BEFORELP, 2:DURINGLPLOOP, 4:AFTERLPLOOP, 15:ALWAYS))}%
{}

\printoption{constraints/indicator/trysolutions}%
{boolean}%
{TRUE}%
{Try to make solutions feasible by setting indicator variables?}%
{}

\printoption{constraints/indicator/updatebounds}%
{boolean}%
{FALSE}%
{Update bounds of original variables for separation?}%
{}

\printoption{constraints/integral/delaypresol}%
{boolean}%
{FALSE}%
{should presolving method be delayed, if other presolvers found reductions?}%
{}

\printoption{constraints/integral/delayprop}%
{boolean}%
{FALSE}%
{should propagation method be delayed, if other propagators found reductions?}%
{}

\printoption{constraints/integral/delaysepa}%
{boolean}%
{FALSE}%
{should separation method be delayed, if other separators found cuts?}%
{}

\printoption{constraints/integral/eagerfreq}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{frequency for using all instead of only the useful constraints in separation, propagation and enforcement (-1: never, 0: only in first evaluation)}%
{}

\printoption{constraints/integral/maxprerounds}%
{$-1\leq\textrm{integer}$}%
{$0$}%
{maximal number of presolving rounds the constraint handler participates in (-1: no limit)}%
{}

\printoption{constraints/integral/timingmask}%
{$1\leq\textrm{integer}\leq15$}%
{$1$}%
{timing when constraint propagation should be called (1:BEFORELP, 2:DURINGLPLOOP, 4:AFTERLPLOOP, 15:ALWAYS))}%
{}

\printoption{constraints/knapsack/delaypresol}%
{boolean}%
{FALSE}%
{should presolving method be delayed, if other presolvers found reductions?}%
{}

\printoption{constraints/knapsack/delayprop}%
{boolean}%
{FALSE}%
{should propagation method be delayed, if other propagators found reductions?}%
{}

\printoption{constraints/knapsack/delaysepa}%
{boolean}%
{FALSE}%
{should separation method be delayed, if other separators found cuts?}%
{}

\printoption{constraints/knapsack/disaggregation}%
{boolean}%
{TRUE}%
{should disaggregation of knapsack constraints be allowed in preprocessing?}%
{}

\printoption{constraints/knapsack/dualpresolving}%
{boolean}%
{TRUE}%
{should dual presolving steps be performed?}%
{}

\printoption{constraints/knapsack/eagerfreq}%
{$-1\leq\textrm{integer}$}%
{$100$}%
{frequency for using all instead of only the useful constraints in separation, propagation and enforcement (-1: never, 0: only in first evaluation)}%
{}

\printoption{constraints/knapsack/maxcardbounddist}%
{$0\leq\textrm{real}\leq1$}%
{$0$}%
{maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for separating knapsack cuts}%
{}

\printoption{constraints/knapsack/maxprerounds}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal number of presolving rounds the constraint handler participates in (-1: no limit)}%
{}

\printoption{constraints/knapsack/negatedclique}%
{boolean}%
{TRUE}%
{should negated clique information be used in solving process}%
{}

\printoption{constraints/knapsack/presolpairwise}%
{boolean}%
{TRUE}%
{should pairwise constraint comparison be performed in presolving?}%
{}

\printoption{constraints/knapsack/presolusehashing}%
{boolean}%
{TRUE}%
{should hash table be used for detecting redundant constraints in advance}%
{}

\printoption{constraints/knapsack/sepacardfreq}%
{$-1\leq\textrm{integer}$}%
{$1$}%
{multiplier on separation frequency, how often knapsack cuts are separated (-1: never, 0: only at root)}%
{}

\printoption{constraints/knapsack/simplifyinequalities}%
{boolean}%
{TRUE}%
{should presolving try to simplify knapsacks}%
{}

\printoption{constraints/knapsack/timingmask}%
{$1\leq\textrm{integer}\leq15$}%
{$1$}%
{timing when constraint propagation should be called (1:BEFORELP, 2:DURINGLPLOOP, 4:AFTERLPLOOP, 15:ALWAYS))}%
{}

\printoption{constraints/knapsack/usegubs}%
{boolean}%
{FALSE}%
{should GUB information be used for separation?}%
{}

\printoption{constraints/linear/aggregatevariables}%
{boolean}%
{TRUE}%
{should presolving search for aggregations in equations}%
{}

\printoption{constraints/linear/delaypresol}%
{boolean}%
{FALSE}%
{should presolving method be delayed, if other presolvers found reductions?}%
{}

\printoption{constraints/linear/delayprop}%
{boolean}%
{FALSE}%
{should propagation method be delayed, if other propagators found reductions?}%
{}

\printoption{constraints/linear/delaysepa}%
{boolean}%
{FALSE}%
{should separation method be delayed, if other separators found cuts?}%
{}

\printoption{constraints/linear/dualpresolving}%
{boolean}%
{TRUE}%
{should dual presolving steps be performed?}%
{}

\printoption{constraints/linear/eagerfreq}%
{$-1\leq\textrm{integer}$}%
{$100$}%
{frequency for using all instead of only the useful constraints in separation, propagation and enforcement (-1: never, 0: only in first evaluation)}%
{}

\printoption{constraints/linear/maxaggrnormscale}%
{$0\leq\textrm{real}$}%
{$0$}%
{maximal allowed relative gain in maximum norm for constraint aggregation (0.0: disable constraint aggregation)}%
{}

\printoption{constraints/linear/maxcardbounddist}%
{$0\leq\textrm{real}\leq1$}%
{$0$}%
{maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for separating knapsack cardinality cuts}%
{}

\printoption{constraints/linear/maxprerounds}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal number of presolving rounds the constraint handler participates in (-1: no limit)}%
{}

\printoption{constraints/linear/mingainpernmincomparisons}%
{$0\leq\textrm{real}$}%
{$10^{- 6}$}%
{minimal gain per minimal pairwise presolve comparisons to repeat pairwise comparison round}%
{}

\printoption{constraints/linear/nmincomparisons}%
{$1\leq\textrm{integer}$}%
{$200000$}%
{number for minimal pairwise presolve comparisons}%
{}

\printoption{constraints/linear/presolpairwise}%
{boolean}%
{TRUE}%
{should pairwise constraint comparison be performed in presolving?}%
{}

\printoption{constraints/linear/presolusehashing}%
{boolean}%
{TRUE}%
{should hash table be used for detecting redundant constraints in advance}%
{}

\printoption{constraints/linear/simplifyinequalities}%
{boolean}%
{TRUE}%
{should presolving try to simplify inequalities}%
{}

\printoption{constraints/linear/sortvars}%
{boolean}%
{TRUE}%
{apply binaries sorting in decr. order of coeff abs value?}%
{}

\printoption{constraints/linear/tightenboundsfreq}%
{$-1\leq\textrm{integer}$}%
{$1$}%
{multiplier on propagation frequency, how often the bounds are tightened (-1: never, 0: only at root)}%
{}

\printoption{constraints/linear/timingmask}%
{$1\leq\textrm{integer}\leq15$}%
{$1$}%
{timing when constraint propagation should be called (1:BEFORELP, 2:DURINGLPLOOP, 4:AFTERLPLOOP, 15:ALWAYS))}%
{}

\printoption{constraints/logicor/delaypresol}%
{boolean}%
{FALSE}%
{should presolving method be delayed, if other presolvers found reductions?}%
{}

\printoption{constraints/logicor/delayprop}%
{boolean}%
{FALSE}%
{should propagation method be delayed, if other propagators found reductions?}%
{}

\printoption{constraints/logicor/delaysepa}%
{boolean}%
{FALSE}%
{should separation method be delayed, if other separators found cuts?}%
{}

\printoption{constraints/logicor/dualpresolving}%
{boolean}%
{TRUE}%
{should dual presolving steps be performed?}%
{}

\printoption{constraints/logicor/eagerfreq}%
{$-1\leq\textrm{integer}$}%
{$100$}%
{frequency for using all instead of only the useful constraints in separation, propagation and enforcement (-1: never, 0: only in first evaluation)}%
{}

\printoption{constraints/logicor/maxprerounds}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal number of presolving rounds the constraint handler participates in (-1: no limit)}%
{}

\printoption{constraints/logicor/negatedclique}%
{boolean}%
{TRUE}%
{should negated clique information be used in presolving}%
{}

\printoption{constraints/logicor/presolpairwise}%
{boolean}%
{TRUE}%
{should pairwise constraint comparison be performed in presolving?}%
{}

\printoption{constraints/logicor/presolusehashing}%
{boolean}%
{TRUE}%
{should hash table be used for detecting redundant constraints in advance}%
{}

\printoption{constraints/logicor/timingmask}%
{$1\leq\textrm{integer}\leq15$}%
{$1$}%
{timing when constraint propagation should be called (1:BEFORELP, 2:DURINGLPLOOP, 4:AFTERLPLOOP, 15:ALWAYS))}%
{}

\printoption{constraints/nonlinear/assumeconvex}%
{boolean}%
{FALSE}%
{whether to assume that nonlinear functions in inequalities ($<$=) are convex (disables reformulation)}%
{}

\printoption{constraints/nonlinear/delaypresol}%
{boolean}%
{FALSE}%
{should presolving method be delayed, if other presolvers found reductions?}%
{}

\printoption{constraints/nonlinear/delayprop}%
{boolean}%
{FALSE}%
{should propagation method be delayed, if other propagators found reductions?}%
{}

\printoption{constraints/nonlinear/delaysepa}%
{boolean}%
{FALSE}%
{should separation method be delayed, if other separators found cuts?}%
{}

\printoption{constraints/nonlinear/eagerfreq}%
{$-1\leq\textrm{integer}$}%
{$100$}%
{frequency for using all instead of only the useful constraints in separation, propagation and enforcement (-1: never, 0: only in first evaluation)}%
{}

\printoption{constraints/nonlinear/enfocutsremovable}%
{boolean}%
{FALSE}%
{are cuts added during enforcement removable from the LP in the same node?}%
{}

\printoption{constraints/nonlinear/maxexpansionexponent}%
{$1\leq\textrm{integer}$}%
{$2$}%
{maximal exponent where still expanding non-monomial polynomials in expression simplification}%
{}

\printoption{constraints/nonlinear/maxprerounds}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal number of presolving rounds the constraint handler participates in (-1: no limit)}%
{}

\printoption{constraints/nonlinear/minefficacyenfofac}%
{$1\leq\textrm{real}$}%
{$2$}%
{minimal target efficacy of a cut in order to add it to relaxation during enforcement as a factor of the feasibility tolerance (may be ignored)}%
{}

\printoption{constraints/nonlinear/minefficacysepa}%
{$0\leq\textrm{real}$}%
{$0.0001$}%
{minimal efficacy for a cut to be added to the LP during separation; overwrites separating/efficacy}%
{}

\printoption{constraints/nonlinear/timingmask}%
{$1\leq\textrm{integer}\leq15$}%
{$1$}%
{timing when constraint propagation should be called (1:BEFORELP, 2:DURINGLPLOOP, 4:AFTERLPLOOP, 15:ALWAYS))}%
{}

\printoption{constraints/obsoleteage}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{age of a constraint after which it is marked obsolete (0: dynamic, -1 do not mark constraints obsolete)}%
{}

\printoption{constraints/quadratic/binreforminitial}%
{boolean}%
{FALSE}%
{whether to make non-varbound linear constraints added due to replacing products with binary variables initial}%
{}

\printoption{constraints/quadratic/checkfactorable}%
{boolean}%
{TRUE}%
{whether constraint functions should be checked to be factorable}%
{}

\printoption{constraints/quadratic/cutmaxrange}%
{$0\leq\textrm{real}$}%
{$10^{  7}$}%
{maximal coef range of a cut (maximal coefficient divided by minimal coefficient) in order to be added to LP relaxation}%
{}

\printoption{constraints/quadratic/delaypresol}%
{boolean}%
{FALSE}%
{should presolving method be delayed, if other presolvers found reductions?}%
{}

\printoption{constraints/quadratic/delayprop}%
{boolean}%
{FALSE}%
{should propagation method be delayed, if other propagators found reductions?}%
{}

\printoption{constraints/quadratic/delaysepa}%
{boolean}%
{FALSE}%
{should separation method be delayed, if other separators found cuts?}%
{}

\printoption{constraints/quadratic/disaggregate}%
{boolean}%
{FALSE}%
{whether to disaggregate quadratic parts that decompose into a sum of non-overlapping quadratic terms}%
{}

\printoption{constraints/quadratic/eagerfreq}%
{$-1\leq\textrm{integer}$}%
{$100$}%
{frequency for using all instead of only the useful constraints in separation, propagation and enforcement (-1: never, 0: only in first evaluation)}%
{}

\printoption{constraints/quadratic/enfocutsremovable}%
{boolean}%
{FALSE}%
{are cuts added during enforcement removable from the LP in the same node?}%
{}

\printoption{constraints/quadratic/linearizeheursol}%
{boolean}%
{TRUE}%
{whether linearizations of convex quadratic constraints should be added to cutpool in a solution found by some heuristic}%
{}

\printoption{constraints/quadratic/linfeasshift}%
{boolean}%
{TRUE}%
{whether to try to make solutions in check function feasible by shifting a linear variable (esp. useful if constraint was actually objective function)}%
{}

\printoption{constraints/quadratic/maxprerounds}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal number of presolving rounds the constraint handler participates in (-1: no limit)}%
{}

\printoption{constraints/quadratic/maxproprounds}%
{$0\leq\textrm{integer}$}%
{$1$}%
{limit on number of propagation rounds for a single constraint within one round of SCIP propagation during solve}%
{}

\printoption{constraints/quadratic/maxproproundspresolve}%
{$0\leq\textrm{integer}$}%
{$10$}%
{limit on number of propagation rounds for a single constraint within one round of SCIP presolve}%
{}

\printoption{constraints/quadratic/minefficacyenfofac}%
{$1\leq\textrm{real}$}%
{$2$}%
{minimal target efficacy of a cut in order to add it to relaxation during enforcement as a factor of the feasibility tolerance (may be ignored)}%
{}

\printoption{constraints/quadratic/minefficacysepa}%
{$0\leq\textrm{real}$}%
{$0.0001$}%
{minimal efficacy for a cut to be added to the LP during separation; overwrites separating/efficacy}%
{}

\printoption{constraints/quadratic/scaling}%
{boolean}%
{TRUE}%
{whether a quadratic constraint should be scaled w.r.t. the current gradient norm when checking for feasibility}%
{}

\printoption{constraints/quadratic/timingmask}%
{$1\leq\textrm{integer}\leq15$}%
{$1$}%
{timing when constraint propagation should be called (1:BEFORELP, 2:DURINGLPLOOP, 4:AFTERLPLOOP, 15:ALWAYS))}%
{}

\printoption{constraints/setppc/addvariablesascliques}%
{boolean}%
{FALSE}%
{should we try to generate extra cliques out of all binary variables to maybe fasten redundant constraint detection}%
{}

\printoption{constraints/setppc/cliquelifting}%
{boolean}%
{FALSE}%
{ should we try to lift variables into other clique constraints, fix variables, aggregate them, and also shrink the amount of variables in clique constraints}%
{}

\printoption{constraints/setppc/cliqueshrinking}%
{boolean}%
{TRUE}%
{should we try to shrink the number of variables in a clique constraints, by replacing more than one variable by only one}%
{}

\printoption{constraints/setppc/delaypresol}%
{boolean}%
{FALSE}%
{should presolving method be delayed, if other presolvers found reductions?}%
{}

\printoption{constraints/setppc/delayprop}%
{boolean}%
{FALSE}%
{should propagation method be delayed, if other propagators found reductions?}%
{}

\printoption{constraints/setppc/delaysepa}%
{boolean}%
{FALSE}%
{should separation method be delayed, if other separators found cuts?}%
{}

\printoption{constraints/setppc/dualpresolving}%
{boolean}%
{TRUE}%
{should dual presolving steps be performed?}%
{}

\printoption{constraints/setppc/eagerfreq}%
{$-1\leq\textrm{integer}$}%
{$100$}%
{frequency for using all instead of only the useful constraints in separation, propagation and enforcement (-1: never, 0: only in first evaluation)}%
{}

\printoption{constraints/setppc/maxprerounds}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal number of presolving rounds the constraint handler participates in (-1: no limit)}%
{}

\printoption{constraints/setppc/npseudobranches}%
{$0\leq\textrm{integer}$}%
{$2$}%
{number of children created in pseudo branching (0: disable pseudo branching)}%
{}

\printoption{constraints/setppc/presolpairwise}%
{boolean}%
{TRUE}%
{should pairwise constraint comparison be performed in presolving?}%
{}

\printoption{constraints/setppc/presolusehashing}%
{boolean}%
{TRUE}%
{should hash table be used for detecting redundant constraints in advance}%
{}

\printoption{constraints/setppc/timingmask}%
{$1\leq\textrm{integer}\leq15$}%
{$1$}%
{timing when constraint propagation should be called (1:BEFORELP, 2:DURINGLPLOOP, 4:AFTERLPLOOP, 15:ALWAYS))}%
{}

\printoption{constraints/soc/delaypresol}%
{boolean}%
{FALSE}%
{should presolving method be delayed, if other presolvers found reductions?}%
{}

\printoption{constraints/soc/delayprop}%
{boolean}%
{FALSE}%
{should propagation method be delayed, if other propagators found reductions?}%
{}

\printoption{constraints/soc/delaysepa}%
{boolean}%
{FALSE}%
{should separation method be delayed, if other separators found cuts?}%
{}

\printoption{constraints/soc/eagerfreq}%
{$-1\leq\textrm{integer}$}%
{$100$}%
{frequency for using all instead of only the useful constraints in separation, propagation and enforcement (-1: never, 0: only in first evaluation)}%
{}

\printoption{constraints/soc/enfocutsremovable}%
{boolean}%
{FALSE}%
{are cuts added during enforcement removable from the LP in the same node?}%
{}

\printoption{constraints/soc/maxprerounds}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal number of presolving rounds the constraint handler participates in (-1: no limit)}%
{}

\printoption{constraints/soc/projectpoint}%
{boolean}%
{FALSE}%
{whether the reference point of a cut should be projected onto the feasible set of the SOC constraint}%
{}

\printoption{constraints/soc/scaling}%
{boolean}%
{TRUE}%
{whether a constraint should be scaled w.r.t. the current gradient norm when checking for feasibility}%
{}

\printoption{constraints/soc/sparsify}%
{boolean}%
{FALSE}%
{whether to sparsify cuts}%
{}

\printoption{constraints/soc/sparsifymaxloss}%
{$0\leq\textrm{real}\leq1$}%
{$0.2$}%
{maximal loss in cut efficacy by sparsification}%
{}

\printoption{constraints/soc/sparsifynzgrowth}%
{$1\leq\textrm{real}$}%
{$1.3$}%
{growth rate of maximal allowed nonzeros in cuts in sparsification}%
{}

\printoption{constraints/soc/timingmask}%
{$1\leq\textrm{integer}\leq15$}%
{$1$}%
{timing when constraint propagation should be called (1:BEFORELP, 2:DURINGLPLOOP, 4:AFTERLPLOOP, 15:ALWAYS))}%
{}

\printoption{constraints/SOS1/delaypresol}%
{boolean}%
{FALSE}%
{should presolving method be delayed, if other presolvers found reductions?}%
{}

\printoption{constraints/SOS1/delayprop}%
{boolean}%
{FALSE}%
{should propagation method be delayed, if other propagators found reductions?}%
{}

\printoption{constraints/SOS1/delaysepa}%
{boolean}%
{FALSE}%
{should separation method be delayed, if other separators found cuts?}%
{}

\printoption{constraints/SOS1/eagerfreq}%
{$-1\leq\textrm{integer}$}%
{$100$}%
{frequency for using all instead of only the useful constraints in separation, propagation and enforcement (-1: never, 0: only in first evaluation)}%
{}

\printoption{constraints/SOS1/maxprerounds}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal number of presolving rounds the constraint handler participates in (-1: no limit)}%
{}

\printoption{constraints/SOS1/timingmask}%
{$1\leq\textrm{integer}\leq15$}%
{$1$}%
{timing when constraint propagation should be called (1:BEFORELP, 2:DURINGLPLOOP, 4:AFTERLPLOOP, 15:ALWAYS))}%
{}

\printoption{constraints/SOS2/delaypresol}%
{boolean}%
{FALSE}%
{should presolving method be delayed, if other presolvers found reductions?}%
{}

\printoption{constraints/SOS2/delayprop}%
{boolean}%
{FALSE}%
{should propagation method be delayed, if other propagators found reductions?}%
{}

\printoption{constraints/SOS2/delaysepa}%
{boolean}%
{FALSE}%
{should separation method be delayed, if other separators found cuts?}%
{}

\printoption{constraints/SOS2/eagerfreq}%
{$-1\leq\textrm{integer}$}%
{$100$}%
{frequency for using all instead of only the useful constraints in separation, propagation and enforcement (-1: never, 0: only in first evaluation)}%
{}

\printoption{constraints/SOS2/maxprerounds}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal number of presolving rounds the constraint handler participates in (-1: no limit)}%
{}

\printoption{constraints/SOS2/timingmask}%
{$1\leq\textrm{integer}\leq15$}%
{$1$}%
{timing when constraint propagation should be called (1:BEFORELP, 2:DURINGLPLOOP, 4:AFTERLPLOOP, 15:ALWAYS))}%
{}

\printoption{constraints/varbound/delaypresol}%
{boolean}%
{FALSE}%
{should presolving method be delayed, if other presolvers found reductions?}%
{}

\printoption{constraints/varbound/delayprop}%
{boolean}%
{FALSE}%
{should propagation method be delayed, if other propagators found reductions?}%
{}

\printoption{constraints/varbound/delaysepa}%
{boolean}%
{FALSE}%
{should separation method be delayed, if other separators found cuts?}%
{}

\printoption{constraints/varbound/eagerfreq}%
{$-1\leq\textrm{integer}$}%
{$100$}%
{frequency for using all instead of only the useful constraints in separation, propagation and enforcement (-1: never, 0: only in first evaluation)}%
{}

\printoption{constraints/varbound/maxlpcoef}%
{$0\leq\textrm{real}$}%
{$10^{  6}$}%
{maximum coefficient in varbound constraint to be added as a row into LP}%
{}

\printoption{constraints/varbound/maxprerounds}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal number of presolving rounds the constraint handler participates in (-1: no limit)}%
{}

\printoption{constraints/varbound/presolpairwise}%
{boolean}%
{TRUE}%
{should pairwise constraint comparison be performed in presolving?}%
{}

\printoption{constraints/varbound/timingmask}%
{$1\leq\textrm{integer}\leq15$}%
{$1$}%
{timing when constraint propagation should be called (1:BEFORELP, 2:DURINGLPLOOP, 4:AFTERLPLOOP, 15:ALWAYS))}%
{}

\printoptioncategory{Output}
\printoption{display/avgdualbound/active}%
{$0\leq\textrm{integer}\leq2$}%
{$1$}%
{display activation status of display column $<$avgdualbound$>$ (0: off, 1: auto, 2:on)}%
{}

\printoption{display/conflicts/active}%
{$0\leq\textrm{integer}\leq2$}%
{$1$}%
{display activation status of display column $<$conflicts$>$ (0: off, 1: auto, 2:on)}%
{}

\printoption{display/conss/active}%
{$0\leq\textrm{integer}\leq2$}%
{$1$}%
{display activation status of display column $<$conss$>$ (0: off, 1: auto, 2:on)}%
{}

\printoption{display/curcols/active}%
{$0\leq\textrm{integer}\leq2$}%
{$1$}%
{display activation status of display column $<$curcols$>$ (0: off, 1: auto, 2:on)}%
{}

\printoption{display/curconss/active}%
{$0\leq\textrm{integer}\leq2$}%
{$1$}%
{display activation status of display column $<$curconss$>$ (0: off, 1: auto, 2:on)}%
{}

\printoption{display/curdualbound/active}%
{$0\leq\textrm{integer}\leq2$}%
{$1$}%
{display activation status of display column $<$curdualbound$>$ (0: off, 1: auto, 2:on)}%
{}

\printoption{display/currows/active}%
{$0\leq\textrm{integer}\leq2$}%
{$1$}%
{display activation status of display column $<$currows$>$ (0: off, 1: auto, 2:on)}%
{}

\printoption{display/cutoffbound/active}%
{$0\leq\textrm{integer}\leq2$}%
{$1$}%
{display activation status of display column $<$cutoffbound$>$ (0: off, 1: auto, 2:on)}%
{}

\printoption{display/cuts/active}%
{$0\leq\textrm{integer}\leq2$}%
{$1$}%
{display activation status of display column $<$cuts$>$ (0: off, 1: auto, 2:on)}%
{}

\printoption{display/depth/active}%
{$0\leq\textrm{integer}\leq2$}%
{$1$}%
{display activation status of display column $<$depth$>$ (0: off, 1: auto, 2:on)}%
{}

\printoption{display/dualbound/active}%
{$0\leq\textrm{integer}\leq2$}%
{$1$}%
{display activation status of display column $<$dualbound$>$ (0: off, 1: auto, 2:on)}%
{}

\printoption{display/estimate/active}%
{$0\leq\textrm{integer}\leq2$}%
{$1$}%
{display activation status of display column $<$estimate$>$ (0: off, 1: auto, 2:on)}%
{}

\printoption{display/feasST/active}%
{$0\leq\textrm{integer}\leq2$}%
{$0$}%
{display activation status of display column $<$feasST$>$ (0: off, 1: auto, 2:on)}%
{}

\printoption{display/freq}%
{$-1\leq\textrm{integer}$}%
{$100$}%
{frequency for displaying node information lines}%
{}

\printoption{display/gap/active}%
{$0\leq\textrm{integer}\leq2$}%
{$1$}%
{display activation status of display column $<$gap$>$ (0: off, 1: auto, 2:on)}%
{}

\printoption{display/headerfreq}%
{$-1\leq\textrm{integer}$}%
{$15$}%
{frequency for displaying header lines (every n'th node information line)}%
{}

\printoption{display/lpavgiterations/active}%
{$0\leq\textrm{integer}\leq2$}%
{$1$}%
{display activation status of display column $<$lpavgiterations$>$ (0: off, 1: auto, 2:on)}%
{}

\printoption{display/lpcond/active}%
{$0\leq\textrm{integer}\leq2$}%
{$1$}%
{display activation status of display column $<$lpcond$>$ (0: off, 1: auto, 2:on)}%
{}

\printoption{display/lpinfo}%
{boolean}%
{FALSE}%
{should the LP solver display status messages?}%
{}

\printoption{display/lpiterations/active}%
{$0\leq\textrm{integer}\leq2$}%
{$1$}%
{display activation status of display column $<$lpiterations$>$ (0: off, 1: auto, 2:on)}%
{}

\printoption{display/lpobj/active}%
{$0\leq\textrm{integer}\leq2$}%
{$1$}%
{display activation status of display column $<$lpobj$>$ (0: off, 1: auto, 2:on)}%
{}

\printoption{display/maxdepth/active}%
{$0\leq\textrm{integer}\leq2$}%
{$1$}%
{display activation status of display column $<$maxdepth$>$ (0: off, 1: auto, 2:on)}%
{}

\printoption{display/memused/active}%
{$0\leq\textrm{integer}\leq2$}%
{$1$}%
{display activation status of display column $<$memused$>$ (0: off, 1: auto, 2:on)}%
{}

\printoption{display/nexternbranchcands/active}%
{$0\leq\textrm{integer}\leq2$}%
{$1$}%
{display activation status of display column $<$nexternbranchcands$>$ (0: off, 1: auto, 2:on)}%
{}

\printoption{display/nfrac/active}%
{$0\leq\textrm{integer}\leq2$}%
{$1$}%
{display activation status of display column $<$nfrac$>$ (0: off, 1: auto, 2:on)}%
{}

\printoption{display/nnodes/active}%
{$0\leq\textrm{integer}\leq2$}%
{$1$}%
{display activation status of display column $<$nnodes$>$ (0: off, 1: auto, 2:on)}%
{}

\printoption{display/nodesleft/active}%
{$0\leq\textrm{integer}\leq2$}%
{$1$}%
{display activation status of display column $<$nodesleft$>$ (0: off, 1: auto, 2:on)}%
{}

\printoption{display/nsols/active}%
{$0\leq\textrm{integer}\leq2$}%
{$1$}%
{display activation status of display column $<$nsols$>$ (0: off, 1: auto, 2:on)}%
{}

\printoption{display/plungedepth/active}%
{$0\leq\textrm{integer}\leq2$}%
{$1$}%
{display activation status of display column $<$plungedepth$>$ (0: off, 1: auto, 2:on)}%
{}

\printoption{display/poolsize/active}%
{$0\leq\textrm{integer}\leq2$}%
{$1$}%
{display activation status of display column $<$poolsize$>$ (0: off, 1: auto, 2:on)}%
{}

\printoption{display/primalbound/active}%
{$0\leq\textrm{integer}\leq2$}%
{$1$}%
{display activation status of display column $<$primalbound$>$ (0: off, 1: auto, 2:on)}%
{}

\printoption{display/primalgap/active}%
{$0\leq\textrm{integer}\leq2$}%
{$0$}%
{display activation status of display column $<$primalgap$>$ (0: off, 1: auto, 2:on)}%
{}

\printoption{display/pseudoobj/active}%
{$0\leq\textrm{integer}\leq2$}%
{$1$}%
{display activation status of display column $<$pseudoobj$>$ (0: off, 1: auto, 2:on)}%
{}

\printoption{display/separounds/active}%
{$0\leq\textrm{integer}\leq2$}%
{$1$}%
{display activation status of display column $<$separounds$>$ (0: off, 1: auto, 2:on)}%
{}

\printoption{display/solfound/active}%
{$0\leq\textrm{integer}\leq2$}%
{$1$}%
{display activation status of display column $<$solfound$>$ (0: off, 1: auto, 2:on)}%
{}

\printoption{display/sols/active}%
{$0\leq\textrm{integer}\leq2$}%
{$0$}%
{display activation status of display column $<$sols$>$ (0: off, 1: auto, 2:on)}%
{}

\printoption{display/statistics}%
{boolean}%
{FALSE}%
{whether to print statistics on a solve}%
{}

\printoption{display/strongbranchs/active}%
{$0\leq\textrm{integer}\leq2$}%
{$1$}%
{display activation status of display column $<$strongbranchs$>$ (0: off, 1: auto, 2:on)}%
{}

\printoption{display/time/active}%
{$0\leq\textrm{integer}\leq2$}%
{$1$}%
{display activation status of display column $<$time$>$ (0: off, 1: auto, 2:on)}%
{}

\printoption{display/vars/active}%
{$0\leq\textrm{integer}\leq2$}%
{$1$}%
{display activation status of display column $<$vars$>$ (0: off, 1: auto, 2:on)}%
{}

\printoption{display/verblevel}%
{$0\leq\textrm{integer}\leq5$}%
{$4$}%
{verbosity level of output}%
{}

\printoption{display/width}%
{$0\leq\textrm{integer}$}%
{$139$}%
{maximal number of characters in a node information line}%
{}

\printoptioncategory{Heuristics}
\printoption{heuristics/actconsdiving/backtrack}%
{boolean}%
{TRUE}%
{use one level of backtracking if infeasibility is encountered?}%
{}

\printoption{heuristics/actconsdiving/freq}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{frequency for calling primal heuristic $<$actconsdiving$>$ (-1: never, 0: only at depth freqofs)}%
{}

\printoption{heuristics/actconsdiving/freqofs}%
{$0\leq\textrm{integer}$}%
{$5$}%
{frequency offset for calling primal heuristic $<$actconsdiving$>$}%
{}

\printoption{heuristics/actconsdiving/maxlpiterofs}%
{$0\leq\textrm{integer}$}%
{$1000$}%
{additional number of allowed LP iterations}%
{}

\printoption{heuristics/actconsdiving/maxlpiterquot}%
{$0\leq\textrm{real}$}%
{$0.05$}%
{maximal fraction of diving LP iterations compared to node LP iterations}%
{}

\printoption{heuristics/clique/freq}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{frequency for calling primal heuristic $<$clique$>$ (-1: never, 0: only at depth freqofs)}%
{}

\printoption{heuristics/clique/freqofs}%
{$0\leq\textrm{integer}$}%
{$0$}%
{frequency offset for calling primal heuristic $<$clique$>$}%
{}

\printoption{heuristics/clique/minfixingrate}%
{$0\leq\textrm{real}\leq1$}%
{$0.5$}%
{minimum percentage of integer variables that have to be fixable}%
{}

\printoption{heuristics/clique/nodesofs}%
{$0\leq\textrm{integer}$}%
{$500$}%
{number of nodes added to the contingent of the total nodes}%
{}

\printoption{heuristics/clique/nodesquot}%
{$0\leq\textrm{real}\leq1$}%
{$0.1$}%
{contingent of sub problem nodes in relation to the number of nodes of the original problem}%
{}

\printoption{heuristics/coefdiving/backtrack}%
{boolean}%
{TRUE}%
{use one level of backtracking if infeasibility is encountered?}%
{}

\printoption{heuristics/coefdiving/freq}%
{$-1\leq\textrm{integer}$}%
{$10$}%
{frequency for calling primal heuristic $<$coefdiving$>$ (-1: never, 0: only at depth freqofs)}%
{}

\printoption{heuristics/coefdiving/freqofs}%
{$0\leq\textrm{integer}$}%
{$1$}%
{frequency offset for calling primal heuristic $<$coefdiving$>$}%
{}

\printoption{heuristics/coefdiving/maxlpiterofs}%
{$0\leq\textrm{integer}$}%
{$1000$}%
{additional number of allowed LP iterations}%
{}

\printoption{heuristics/coefdiving/maxlpiterquot}%
{$0\leq\textrm{real}$}%
{$0.05$}%
{maximal fraction of diving LP iterations compared to node LP iterations}%
{}

\printoption{heuristics/crossover/freq}%
{$-1\leq\textrm{integer}$}%
{$30$}%
{frequency for calling primal heuristic $<$crossover$>$ (-1: never, 0: only at depth freqofs)}%
{}

\printoption{heuristics/crossover/freqofs}%
{$0\leq\textrm{integer}$}%
{$0$}%
{frequency offset for calling primal heuristic $<$crossover$>$}%
{}

\printoption{heuristics/crossover/minfixingrate}%
{$0\leq\textrm{real}\leq1$}%
{$0.666$}%
{minimum percentage of integer variables that have to be fixed}%
{}

\printoption{heuristics/crossover/nodesofs}%
{$0\leq\textrm{integer}$}%
{$500$}%
{number of nodes added to the contingent of the total nodes}%
{}

\printoption{heuristics/crossover/nodesquot}%
{$0\leq\textrm{real}\leq1$}%
{$0.1$}%
{contingent of sub problem nodes in relation to the number of nodes of the original problem}%
{}

\printoption{heuristics/crossover/nusedsols}%
{$2\leq\textrm{integer}$}%
{$3$}%
{number of solutions to be taken into account}%
{}

\printoption{heuristics/dins/freq}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{frequency for calling primal heuristic $<$dins$>$ (-1: never, 0: only at depth freqofs)}%
{}

\printoption{heuristics/dins/freqofs}%
{$0\leq\textrm{integer}$}%
{$0$}%
{frequency offset for calling primal heuristic $<$dins$>$}%
{}

\printoption{heuristics/dins/minnodes}%
{$0\leq\textrm{integer}$}%
{$500$}%
{minimum number of nodes required to start the subproblem}%
{}

\printoption{heuristics/dins/neighborhoodsize}%
{$1\leq\textrm{integer}$}%
{$18$}%
{radius (using Manhattan metric) of the incumbent's neighborhood to be searched}%
{}

\printoption{heuristics/dins/nodesofs}%
{$0\leq\textrm{integer}$}%
{$5000$}%
{number of nodes added to the contingent of the total nodes}%
{}

\printoption{heuristics/dins/nodesquot}%
{$0\leq\textrm{real}\leq1$}%
{$0.05$}%
{contingent of sub problem nodes in relation to the number of nodes of the original problem}%
{}

\printoption{heuristics/dins/solnum}%
{$1\leq\textrm{integer}$}%
{$5$}%
{number of pool-solutions to be checked for flag array update (for hard fixing of binary variables)}%
{}

\printoption{heuristics/feaspump/alphadiff}%
{$0\leq\textrm{real}\leq1$}%
{$1$}%
{threshold difference for the convex parameter to perform perturbation}%
{}

\printoption{heuristics/feaspump/beforecuts}%
{boolean}%
{TRUE}%
{should the feasibility pump be called at root node before cut separation?}%
{}

\printoption{heuristics/feaspump/freq}%
{$-1\leq\textrm{integer}$}%
{$20$}%
{frequency for calling primal heuristic $<$feaspump$>$ (-1: never, 0: only at depth freqofs)}%
{}

\printoption{heuristics/feaspump/freqofs}%
{$0\leq\textrm{integer}$}%
{$0$}%
{frequency offset for calling primal heuristic $<$feaspump$>$}%
{}

\printoption{heuristics/feaspump/maxlpiterofs}%
{$0\leq\textrm{integer}$}%
{$1000$}%
{additional number of allowed LP iterations}%
{}

\printoption{heuristics/feaspump/maxlpiterquot}%
{$0\leq\textrm{real}$}%
{$0.01$}%
{maximal fraction of diving LP iterations compared to node LP iterations}%
{}

\printoption{heuristics/feaspump/neighborhoodsize}%
{$1\leq\textrm{integer}$}%
{$18$}%
{radius (using Manhattan metric) of the neighborhood to be searched in stage 3}%
{}

\printoption{heuristics/feaspump/objfactor}%
{$0\leq\textrm{real}\leq1$}%
{$1$}%
{factor by which the regard of the objective is decreased in each round, 1.0 for dynamic}%
{}

\printoption{heuristics/feaspump/pertsolfound}%
{boolean}%
{TRUE}%
{should a random perturbation be performed if a feasible solution was found?}%
{}

\printoption{heuristics/feaspump/stage3}%
{boolean}%
{FALSE}%
{should we solve a local branching sub-MIP if no solution could be found?}%
{}

\printoption{heuristics/feaspump/usefp20}%
{boolean}%
{FALSE}%
{should an iterative round-and-propagate scheme be used to find the integral points?}%
{}

\printoption{heuristics/fixandinfer/freq}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{frequency for calling primal heuristic $<$fixandinfer$>$ (-1: never, 0: only at depth freqofs)}%
{}

\printoption{heuristics/fixandinfer/freqofs}%
{$0\leq\textrm{integer}$}%
{$0$}%
{frequency offset for calling primal heuristic $<$fixandinfer$>$}%
{}

\printoption{heuristics/fracdiving/backtrack}%
{boolean}%
{TRUE}%
{use one level of backtracking if infeasibility is encountered?}%
{}

\printoption{heuristics/fracdiving/freq}%
{$-1\leq\textrm{integer}$}%
{$10$}%
{frequency for calling primal heuristic $<$fracdiving$>$ (-1: never, 0: only at depth freqofs)}%
{}

\printoption{heuristics/fracdiving/freqofs}%
{$0\leq\textrm{integer}$}%
{$3$}%
{frequency offset for calling primal heuristic $<$fracdiving$>$}%
{}

\printoption{heuristics/fracdiving/maxlpiterofs}%
{$0\leq\textrm{integer}$}%
{$1000$}%
{additional number of allowed LP iterations}%
{}

\printoption{heuristics/fracdiving/maxlpiterquot}%
{$0\leq\textrm{real}$}%
{$0.05$}%
{maximal fraction of diving LP iterations compared to node LP iterations}%
{}

\printoption{heuristics/guideddiving/backtrack}%
{boolean}%
{TRUE}%
{use one level of backtracking if infeasibility is encountered?}%
{}

\printoption{heuristics/guideddiving/freq}%
{$-1\leq\textrm{integer}$}%
{$10$}%
{frequency for calling primal heuristic $<$guideddiving$>$ (-1: never, 0: only at depth freqofs)}%
{}

\printoption{heuristics/guideddiving/freqofs}%
{$0\leq\textrm{integer}$}%
{$7$}%
{frequency offset for calling primal heuristic $<$guideddiving$>$}%
{}

\printoption{heuristics/guideddiving/maxlpiterofs}%
{$0\leq\textrm{integer}$}%
{$1000$}%
{additional number of allowed LP iterations}%
{}

\printoption{heuristics/guideddiving/maxlpiterquot}%
{$0\leq\textrm{real}$}%
{$0.05$}%
{maximal fraction of diving LP iterations compared to node LP iterations}%
{}

\printoption{heuristics/intdiving/backtrack}%
{boolean}%
{TRUE}%
{use one level of backtracking if infeasibility is encountered?}%
{}

\printoption{heuristics/intdiving/freq}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{frequency for calling primal heuristic $<$intdiving$>$ (-1: never, 0: only at depth freqofs)}%
{}

\printoption{heuristics/intdiving/freqofs}%
{$0\leq\textrm{integer}$}%
{$9$}%
{frequency offset for calling primal heuristic $<$intdiving$>$}%
{}

\printoption{heuristics/intdiving/maxlpiterofs}%
{$0\leq\textrm{integer}$}%
{$1000$}%
{additional number of allowed LP iterations}%
{}

\printoption{heuristics/intdiving/maxlpiterquot}%
{$0\leq\textrm{real}$}%
{$0.05$}%
{maximal fraction of diving LP iterations compared to node LP iterations}%
{}

\printoption{heuristics/intshifting/freq}%
{$-1\leq\textrm{integer}$}%
{$10$}%
{frequency for calling primal heuristic $<$intshifting$>$ (-1: never, 0: only at depth freqofs)}%
{}

\printoption{heuristics/intshifting/freqofs}%
{$0\leq\textrm{integer}$}%
{$0$}%
{frequency offset for calling primal heuristic $<$intshifting$>$}%
{}

\printoption{heuristics/linesearchdiving/backtrack}%
{boolean}%
{TRUE}%
{use one level of backtracking if infeasibility is encountered?}%
{}

\printoption{heuristics/linesearchdiving/freq}%
{$-1\leq\textrm{integer}$}%
{$10$}%
{frequency for calling primal heuristic $<$linesearchdiving$>$ (-1: never, 0: only at depth freqofs)}%
{}

\printoption{heuristics/linesearchdiving/freqofs}%
{$0\leq\textrm{integer}$}%
{$6$}%
{frequency offset for calling primal heuristic $<$linesearchdiving$>$}%
{}

\printoption{heuristics/linesearchdiving/maxlpiterofs}%
{$0\leq\textrm{integer}$}%
{$1000$}%
{additional number of allowed LP iterations}%
{}

\printoption{heuristics/linesearchdiving/maxlpiterquot}%
{$0\leq\textrm{real}$}%
{$0.05$}%
{maximal fraction of diving LP iterations compared to node LP iterations}%
{}

\printoption{heuristics/localbranching/freq}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{frequency for calling primal heuristic $<$localbranching$>$ (-1: never, 0: only at depth freqofs)}%
{}

\printoption{heuristics/localbranching/freqofs}%
{$0\leq\textrm{integer}$}%
{$0$}%
{frequency offset for calling primal heuristic $<$localbranching$>$}%
{}

\printoption{heuristics/localbranching/neighborhoodsize}%
{$1\leq\textrm{integer}$}%
{$18$}%
{radius (using Manhattan metric) of the incumbent's neighborhood to be searched}%
{}

\printoption{heuristics/localbranching/nodesofs}%
{$0\leq\textrm{integer}$}%
{$1000$}%
{number of nodes added to the contingent of the total nodes}%
{}

\printoption{heuristics/localbranching/nodesquot}%
{$0\leq\textrm{real}\leq1$}%
{$0.05$}%
{contingent of sub problem nodes in relation to the number of nodes of the original problem}%
{}

\printoption{heuristics/mutation/freq}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{frequency for calling primal heuristic $<$mutation$>$ (-1: never, 0: only at depth freqofs)}%
{}

\printoption{heuristics/mutation/freqofs}%
{$0\leq\textrm{integer}$}%
{$8$}%
{frequency offset for calling primal heuristic $<$mutation$>$}%
{}

\printoption{heuristics/mutation/minfixingrate}%
{$10^{- 6}\leq\textrm{real}\leq0.999999$}%
{$0.8$}%
{percentage of integer variables that have to be fixed}%
{}

\printoption{heuristics/mutation/nodesofs}%
{$0\leq\textrm{integer}$}%
{$500$}%
{number of nodes added to the contingent of the total nodes}%
{}

\printoption{heuristics/mutation/nodesquot}%
{$0\leq\textrm{real}\leq1$}%
{$0.1$}%
{contingent of sub problem nodes in relation to the number of nodes of the original problem}%
{}

\printoption{heuristics/nlpdiving/backtrack}%
{boolean}%
{TRUE}%
{use one level of backtracking if infeasibility is encountered?}%
{}

\printoption{heuristics/nlpdiving/fixquot}%
{$0\leq\textrm{real}\leq1$}%
{$0.2$}%
{percentage of fractional variables that should be fixed before the next NLP solve}%
{}

\printoption{heuristics/nlpdiving/freq}%
{$-1\leq\textrm{integer}$}%
{$10$}%
{frequency for calling primal heuristic $<$nlpdiving$>$ (-1: never, 0: only at depth freqofs)}%
{}

\printoption{heuristics/nlpdiving/freqofs}%
{$0\leq\textrm{integer}$}%
{$3$}%
{frequency offset for calling primal heuristic $<$nlpdiving$>$}%
{}

\printoption{heuristics/nlpdiving/maxfeasnlps}%
{$1\leq\textrm{integer}$}%
{$10$}%
{maximal number of NLPs with feasible solution to solve during one dive}%
{}

\printoption{heuristics/nlpdiving/maxnlpiterabs}%
{$0\leq\textrm{integer}$}%
{$200$}%
{minimial absolute number of allowed NLP iterations}%
{}

\printoption{heuristics/nlpdiving/maxnlpiterrel}%
{$0\leq\textrm{integer}$}%
{$10$}%
{additional allowed number of NLP iterations relative to successfully found solutions}%
{}

\printoption{heuristics/nlpdiving/minsuccquot}%
{$0\leq\textrm{real}\leq1$}%
{$0.1$}%
{heuristic will not run if less then this percentage of calls succeeded (0.0: no limit)}%
{}

\printoption{heuristics/nlpdiving/nlpfastfail}%
{boolean}%
{TRUE}%
{should the NLP solver stop early if it converges slow?}%
{}

\printoption{heuristics/nlpdiving/prefercover}%
{boolean}%
{TRUE}%
{should variables in a minimal cover be preferred?}%
{}

\printoption{heuristics/nlpdiving/solvesubmip}%
{boolean}%
{FALSE}%
{should a sub-MIP be solved if all cover variables are fixed?}%
{}

\printoption{heuristics/nlpdiving/varselrule}%
{character}%
{d}%
{which variable selection should be used? ('f'ractionality, 'c'oefficient, 'p'seudocost, 'g'uided, 'd'ouble, 'v'eclen)}%
{}

\printoption{heuristics/objpscostdiving/freq}%
{$-1\leq\textrm{integer}$}%
{$20$}%
{frequency for calling primal heuristic $<$objpscostdiving$>$ (-1: never, 0: only at depth freqofs)}%
{}

\printoption{heuristics/objpscostdiving/freqofs}%
{$0\leq\textrm{integer}$}%
{$4$}%
{frequency offset for calling primal heuristic $<$objpscostdiving$>$}%
{}

\printoption{heuristics/objpscostdiving/maxlpiterofs}%
{$0\leq\textrm{integer}$}%
{$1000$}%
{additional number of allowed LP iterations}%
{}

\printoption{heuristics/objpscostdiving/maxlpiterquot}%
{$0\leq\textrm{real}\leq1$}%
{$0.01$}%
{maximal fraction of diving LP iterations compared to total iteration number}%
{}

\printoption{heuristics/octane/freq}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{frequency for calling primal heuristic $<$octane$>$ (-1: never, 0: only at depth freqofs)}%
{}

\printoption{heuristics/octane/freqofs}%
{$0\leq\textrm{integer}$}%
{$0$}%
{frequency offset for calling primal heuristic $<$octane$>$}%
{}

\printoption{heuristics/oneopt/freq}%
{$-1\leq\textrm{integer}$}%
{$1$}%
{frequency for calling primal heuristic $<$oneopt$>$ (-1: never, 0: only at depth freqofs)}%
{}

\printoption{heuristics/oneopt/freqofs}%
{$0\leq\textrm{integer}$}%
{$0$}%
{frequency offset for calling primal heuristic $<$oneopt$>$}%
{}

\printoption{heuristics/pscostdiving/backtrack}%
{boolean}%
{TRUE}%
{use one level of backtracking if infeasibility is encountered?}%
{}

\printoption{heuristics/pscostdiving/freq}%
{$-1\leq\textrm{integer}$}%
{$10$}%
{frequency for calling primal heuristic $<$pscostdiving$>$ (-1: never, 0: only at depth freqofs)}%
{}

\printoption{heuristics/pscostdiving/freqofs}%
{$0\leq\textrm{integer}$}%
{$2$}%
{frequency offset for calling primal heuristic $<$pscostdiving$>$}%
{}

\printoption{heuristics/pscostdiving/maxlpiterofs}%
{$0\leq\textrm{integer}$}%
{$1000$}%
{additional number of allowed LP iterations}%
{}

\printoption{heuristics/pscostdiving/maxlpiterquot}%
{$0\leq\textrm{real}$}%
{$0.05$}%
{maximal fraction of diving LP iterations compared to node LP iterations}%
{}

\printoption{heuristics/rens/freq}%
{$-1\leq\textrm{integer}$}%
{$0$}%
{frequency for calling primal heuristic $<$rens$>$ (-1: never, 0: only at depth freqofs)}%
{}

\printoption{heuristics/rens/freqofs}%
{$0\leq\textrm{integer}$}%
{$0$}%
{frequency offset for calling primal heuristic $<$rens$>$}%
{}

\printoption{heuristics/rens/minfixingrate}%
{$0\leq\textrm{real}\leq1$}%
{$0.5$}%
{minimum percentage of integer variables that have to be fixable}%
{}

\printoption{heuristics/rens/nodesofs}%
{$0\leq\textrm{integer}$}%
{$500$}%
{number of nodes added to the contingent of the total nodes}%
{}

\printoption{heuristics/rens/nodesquot}%
{$0\leq\textrm{real}\leq1$}%
{$0.1$}%
{contingent of sub problem nodes in relation to the number of nodes of the original problem}%
{}

\printoption{heuristics/rens/startsol}%
{character}%
{l}%
{solution that is used for fixing values ('l'p relaxation, 'n'lp relaxation)}%
{}

\printoption{heuristics/rins/freq}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{frequency for calling primal heuristic $<$rins$>$ (-1: never, 0: only at depth freqofs)}%
{}

\printoption{heuristics/rins/freqofs}%
{$0\leq\textrm{integer}$}%
{$5$}%
{frequency offset for calling primal heuristic $<$rins$>$}%
{}

\printoption{heuristics/rins/minfixingrate}%
{$0\leq\textrm{real}\leq1$}%
{$0$}%
{minimum percentage of integer variables that have to be fixed}%
{}

\printoption{heuristics/rins/nodesofs}%
{$0\leq\textrm{integer}$}%
{$500$}%
{number of nodes added to the contingent of the total nodes}%
{}

\printoption{heuristics/rins/nodesquot}%
{$0\leq\textrm{real}\leq1$}%
{$0.1$}%
{contingent of sub problem nodes in relation to the number of nodes of the original problem}%
{}

\printoption{heuristics/rootsoldiving/freq}%
{$-1\leq\textrm{integer}$}%
{$20$}%
{frequency for calling primal heuristic $<$rootsoldiving$>$ (-1: never, 0: only at depth freqofs)}%
{}

\printoption{heuristics/rootsoldiving/freqofs}%
{$0\leq\textrm{integer}$}%
{$5$}%
{frequency offset for calling primal heuristic $<$rootsoldiving$>$}%
{}

\printoption{heuristics/rootsoldiving/maxlpiterofs}%
{$0\leq\textrm{integer}$}%
{$1000$}%
{additional number of allowed LP iterations}%
{}

\printoption{heuristics/rootsoldiving/maxlpiterquot}%
{$0\leq\textrm{real}$}%
{$0.01$}%
{maximal fraction of diving LP iterations compared to node LP iterations}%
{}

\printoption{heuristics/rounding/freq}%
{$-1\leq\textrm{integer}$}%
{$1$}%
{frequency for calling primal heuristic $<$rounding$>$ (-1: never, 0: only at depth freqofs)}%
{}

\printoption{heuristics/rounding/freqofs}%
{$0\leq\textrm{integer}$}%
{$0$}%
{frequency offset for calling primal heuristic $<$rounding$>$}%
{}

\printoption{heuristics/shiftandpropagate/freq}%
{$-1\leq\textrm{integer}$}%
{$0$}%
{frequency for calling primal heuristic $<$shiftandpropagate$>$ (-1: never, 0: only at depth freqofs)}%
{}

\printoption{heuristics/shiftandpropagate/freqofs}%
{$0\leq\textrm{integer}$}%
{$0$}%
{frequency offset for calling primal heuristic $<$shiftandpropagate$>$}%
{}

\printoption{heuristics/shifting/freq}%
{$-1\leq\textrm{integer}$}%
{$10$}%
{frequency for calling primal heuristic $<$shifting$>$ (-1: never, 0: only at depth freqofs)}%
{}

\printoption{heuristics/shifting/freqofs}%
{$0\leq\textrm{integer}$}%
{$0$}%
{frequency offset for calling primal heuristic $<$shifting$>$}%
{}

\printoption{heuristics/simplerounding/freq}%
{$-1\leq\textrm{integer}$}%
{$1$}%
{frequency for calling primal heuristic $<$simplerounding$>$ (-1: never, 0: only at depth freqofs)}%
{}

\printoption{heuristics/simplerounding/freqofs}%
{$0\leq\textrm{integer}$}%
{$0$}%
{frequency offset for calling primal heuristic $<$simplerounding$>$}%
{}

\printoption{heuristics/subnlp/forbidfixings}%
{boolean}%
{TRUE}%
{whether to add constraints that forbid specific fixings that turned out to be infeasible}%
{}

\printoption{heuristics/subnlp/freq}%
{$-1\leq\textrm{integer}$}%
{$1$}%
{frequency for calling primal heuristic $<$subnlp$>$ (-1: never, 0: only at depth freqofs)}%
{}

\printoption{heuristics/subnlp/freqofs}%
{$0\leq\textrm{integer}$}%
{$0$}%
{frequency offset for calling primal heuristic $<$subnlp$>$}%
{}

\printoption{heuristics/subnlp/itermin}%
{$0\leq\textrm{integer}$}%
{$300$}%
{contingent of NLP iterations in relation to the number of nodes in SCIP}%
{}

\printoption{heuristics/subnlp/iteroffset}%
{$0\leq\textrm{integer}$}%
{$500$}%
{number of iterations added to the contingent of the total number of iterations}%
{}

\printoption{heuristics/subnlp/iterquotient}%
{$0\leq\textrm{real}$}%
{$0.1$}%
{contingent of NLP iterations in relation to the number of nodes in SCIP}%
{}

\printoption{heuristics/subnlp/nlpiterlimit}%
{$0\leq\textrm{integer}$}%
{$0$}%
{iteration limit of NLP solver; 0 to use solver default}%
{}

\printoption{heuristics/subnlp/nlptimelimit}%
{$0\leq\textrm{real}$}%
{$0$}%
{time limit of NLP solver; 0 to use solver default}%
{}

\printoption{heuristics/subnlp/nlpverblevel}%
{$0\leq\textrm{integer}$}%
{$0$}%
{verbosity level of NLP solver}%
{}

\printoption{heuristics/subnlp/runalways}%
{boolean}%
{FALSE}%
{whether to run NLP heuristic always if starting point available (does not use iteroffset,iterquot,itermin)}%
{}

\printoption{heuristics/trivial/freq}%
{$-1\leq\textrm{integer}$}%
{$0$}%
{frequency for calling primal heuristic $<$trivial$>$ (-1: never, 0: only at depth freqofs)}%
{}

\printoption{heuristics/trivial/freqofs}%
{$0\leq\textrm{integer}$}%
{$0$}%
{frequency offset for calling primal heuristic $<$trivial$>$}%
{}

\printoption{heuristics/trysol/freq}%
{$-1\leq\textrm{integer}$}%
{$1$}%
{frequency for calling primal heuristic $<$trysol$>$ (-1: never, 0: only at depth freqofs)}%
{}

\printoption{heuristics/trysol/freqofs}%
{$0\leq\textrm{integer}$}%
{$0$}%
{frequency offset for calling primal heuristic $<$trysol$>$}%
{}

\printoption{heuristics/twoopt/freq}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{frequency for calling primal heuristic $<$twoopt$>$ (-1: never, 0: only at depth freqofs)}%
{}

\printoption{heuristics/twoopt/freqofs}%
{$0\leq\textrm{integer}$}%
{$0$}%
{frequency offset for calling primal heuristic $<$twoopt$>$}%
{}

\printoption{heuristics/undercover/fixingalts}%
{string}%
{li}%
{prioritized sequence of fixing values used ('l'p relaxation, 'n'lp relaxation, 'i'ncumbent solution)}%
{}

\printoption{heuristics/undercover/freq}%
{$-1\leq\textrm{integer}$}%
{$0$}%
{frequency for calling primal heuristic $<$undercover$>$ (-1: never, 0: only at depth freqofs)}%
{}

\printoption{heuristics/undercover/freqofs}%
{$0\leq\textrm{integer}$}%
{$0$}%
{frequency offset for calling primal heuristic $<$undercover$>$}%
{}

\printoption{heuristics/undercover/nodesofs}%
{$0\leq\textrm{integer}$}%
{$500$}%
{number of nodes added to the contingent of the total nodes}%
{}

\printoption{heuristics/undercover/nodesquot}%
{$0\leq\textrm{real}\leq1$}%
{$0.1$}%
{contingent of sub problem nodes in relation to the number of nodes of the original problem}%
{}

\printoption{heuristics/undercover/onlyconvexify}%
{boolean}%
{FALSE}%
{should we only fix variables in order to obtain a convex problem?}%
{}

\printoption{heuristics/undercover/postnlp}%
{boolean}%
{TRUE}%
{should the NLP heuristic be called to polish a feasible solution?}%
{}

\printoption{heuristics/vbounds/freq}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{frequency for calling primal heuristic $<$vbounds$>$ (-1: never, 0: only at depth freqofs)}%
{}

\printoption{heuristics/vbounds/freqofs}%
{$0\leq\textrm{integer}$}%
{$0$}%
{frequency offset for calling primal heuristic $<$vbounds$>$}%
{}

\printoption{heuristics/vbounds/minfixingrate}%
{$0\leq\textrm{real}\leq1$}%
{$0.5$}%
{minimum percentage of integer variables that have to be fixable}%
{}

\printoption{heuristics/vbounds/nodesofs}%
{$0\leq\textrm{integer}$}%
{$500$}%
{number of nodes added to the contingent of the total nodes}%
{}

\printoption{heuristics/vbounds/nodesquot}%
{$0\leq\textrm{real}\leq1$}%
{$0.1$}%
{contingent of sub problem nodes in relation to the number of nodes of the original problem}%
{}

\printoption{heuristics/veclendiving/backtrack}%
{boolean}%
{TRUE}%
{use one level of backtracking if infeasibility is encountered?}%
{}

\printoption{heuristics/veclendiving/freq}%
{$-1\leq\textrm{integer}$}%
{$10$}%
{frequency for calling primal heuristic $<$veclendiving$>$ (-1: never, 0: only at depth freqofs)}%
{}

\printoption{heuristics/veclendiving/freqofs}%
{$0\leq\textrm{integer}$}%
{$4$}%
{frequency offset for calling primal heuristic $<$veclendiving$>$}%
{}

\printoption{heuristics/veclendiving/maxlpiterofs}%
{$0\leq\textrm{integer}$}%
{$1000$}%
{additional number of allowed LP iterations}%
{}

\printoption{heuristics/veclendiving/maxlpiterquot}%
{$0\leq\textrm{real}$}%
{$0.05$}%
{maximal fraction of diving LP iterations compared to node LP iterations}%
{}

\printoption{heuristics/zeroobj/freq}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{frequency for calling primal heuristic $<$zeroobj$>$ (-1: never, 0: only at depth freqofs)}%
{}

\printoption{heuristics/zeroobj/freqofs}%
{$0\leq\textrm{integer}$}%
{$0$}%
{frequency offset for calling primal heuristic $<$zeroobj$>$}%
{}

\printoption{heuristics/zeroobj/nodesofs}%
{$0\leq\textrm{integer}$}%
{$100$}%
{number of nodes added to the contingent of the total nodes}%
{}

\printoption{heuristics/zeroobj/nodesquot}%
{$0\leq\textrm{real}\leq1$}%
{$0.1$}%
{contingent of sub problem nodes in relation to the number of nodes of the original problem}%
{}

\printoption{heuristics/zirounding/freq}%
{$-1\leq\textrm{integer}$}%
{$1$}%
{frequency for calling primal heuristic $<$zirounding$>$ (-1: never, 0: only at depth freqofs)}%
{}

\printoption{heuristics/zirounding/freqofs}%
{$0\leq\textrm{integer}$}%
{$0$}%
{frequency offset for calling primal heuristic $<$zirounding$>$}%
{}

\printoptioncategory{Heuristics (advanced options)}
\printoption{heuristics/actconsdiving/maxdepth}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal depth level to call primal heuristic $<$actconsdiving$>$ (-1: no limit)}%
{}

\printoption{heuristics/actconsdiving/maxdiveavgquot}%
{$0\leq\textrm{real}$}%
{$0$}%
{maximal quotient (curlowerbound - lowerbound)/(avglowerbound - lowerbound) where diving is performed (0.0: no limit)}%
{}

\printoption{heuristics/actconsdiving/maxdiveavgquotnosol}%
{$0\leq\textrm{real}$}%
{$0$}%
{maximal AVGQUOT when no solution was found yet (0.0: no limit)}%
{}

\printoption{heuristics/actconsdiving/maxdiveubquot}%
{$0\leq\textrm{real}\leq1$}%
{$0.8$}%
{maximal quotient (curlowerbound - lowerbound)/(cutoffbound - lowerbound) where diving is performed (0.0: no limit)}%
{}

\printoption{heuristics/actconsdiving/maxdiveubquotnosol}%
{$0\leq\textrm{real}\leq1$}%
{$0.1$}%
{maximal UBQUOT when no solution was found yet (0.0: no limit)}%
{}

\printoption{heuristics/actconsdiving/maxreldepth}%
{$0\leq\textrm{real}\leq1$}%
{$1$}%
{maximal relative depth to start diving}%
{}

\printoption{heuristics/actconsdiving/minreldepth}%
{$0\leq\textrm{real}\leq1$}%
{$0$}%
{minimal relative depth to start diving}%
{}

\printoption{heuristics/actconsdiving/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$-1003700$}%
{priority of heuristic $<$actconsdiving$>$}%
{}

\printoption{heuristics/clique/copycuts}%
{boolean}%
{TRUE}%
{should all active cuts from cutpool be copied to constraints in subproblem?}%
{}

\printoption{heuristics/clique/initseed}%
{$0\leq\textrm{integer}$}%
{$0$}%
{initial random seed value to permutate variables}%
{}

\printoption{heuristics/clique/maxdepth}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal depth level to call primal heuristic $<$clique$>$ (-1: no limit)}%
{}

\printoption{heuristics/clique/maxnodes}%
{$0\leq\textrm{integer}$}%
{$5000$}%
{maximum number of nodes to regard in the subproblem}%
{}

\printoption{heuristics/clique/maxproprounds}%
{$-1\leq\textrm{integer}\leq536870911$}%
{$2$}%
{maximum number of propagation rounds during probing (-1 infinity)}%
{}

\printoption{heuristics/clique/minimprove}%
{$0\leq\textrm{real}\leq1$}%
{$0.01$}%
{factor by which clique heuristic should at least improve the incumbent}%
{}

\printoption{heuristics/clique/minnodes}%
{$0\leq\textrm{integer}$}%
{$500$}%
{minimum number of nodes required to start the subproblem}%
{}

\printoption{heuristics/clique/multiplier}%
{$0\leq\textrm{real}$}%
{$1.1$}%
{value to increase nodenumber to determine the next run}%
{}

\printoption{heuristics/clique/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$-1000500$}%
{priority of heuristic $<$clique$>$}%
{}

\printoption{heuristics/coefdiving/maxdepth}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal depth level to call primal heuristic $<$coefdiving$>$ (-1: no limit)}%
{}

\printoption{heuristics/coefdiving/maxdiveavgquot}%
{$0\leq\textrm{real}$}%
{$0$}%
{maximal quotient (curlowerbound - lowerbound)/(avglowerbound - lowerbound) where diving is performed (0.0: no limit)}%
{}

\printoption{heuristics/coefdiving/maxdiveavgquotnosol}%
{$0\leq\textrm{real}$}%
{$0$}%
{maximal AVGQUOT when no solution was found yet (0.0: no limit)}%
{}

\printoption{heuristics/coefdiving/maxdiveubquot}%
{$0\leq\textrm{real}\leq1$}%
{$0.8$}%
{maximal quotient (curlowerbound - lowerbound)/(cutoffbound - lowerbound) where diving is performed (0.0: no limit)}%
{}

\printoption{heuristics/coefdiving/maxdiveubquotnosol}%
{$0\leq\textrm{real}\leq1$}%
{$0.1$}%
{maximal UBQUOT when no solution was found yet (0.0: no limit)}%
{}

\printoption{heuristics/coefdiving/maxreldepth}%
{$0\leq\textrm{real}\leq1$}%
{$1$}%
{maximal relative depth to start diving}%
{}

\printoption{heuristics/coefdiving/minreldepth}%
{$0\leq\textrm{real}\leq1$}%
{$0$}%
{minimal relative depth to start diving}%
{}

\printoption{heuristics/coefdiving/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$-1001000$}%
{priority of heuristic $<$coefdiving$>$}%
{}

\printoption{heuristics/crossover/copycuts}%
{boolean}%
{TRUE}%
{if uselprows == FALSE, should all active cuts from cutpool be copied to constraints in subproblem?}%
{}

\printoption{heuristics/crossover/dontwaitatroot}%
{boolean}%
{FALSE}%
{should the nwaitingnodes parameter be ignored at the root node?}%
{}

\printoption{heuristics/crossover/maxdepth}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal depth level to call primal heuristic $<$crossover$>$ (-1: no limit)}%
{}

\printoption{heuristics/crossover/maxnodes}%
{$0\leq\textrm{integer}$}%
{$5000$}%
{maximum number of nodes to regard in the subproblem}%
{}

\printoption{heuristics/crossover/minimprove}%
{$0\leq\textrm{real}\leq1$}%
{$0.01$}%
{factor by which Crossover should at least improve the incumbent}%
{}

\printoption{heuristics/crossover/minnodes}%
{$0\leq\textrm{integer}$}%
{$500$}%
{minimum number of nodes required to start the subproblem}%
{}

\printoption{heuristics/crossover/nwaitingnodes}%
{$0\leq\textrm{integer}$}%
{$200$}%
{number of nodes without incumbent change that heuristic should wait}%
{}

\printoption{heuristics/crossover/permute}%
{boolean}%
{FALSE}%
{should the subproblem be permuted to increase diversification?}%
{}

\printoption{heuristics/crossover/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$-1104000$}%
{priority of heuristic $<$crossover$>$}%
{}

\printoption{heuristics/crossover/randomization}%
{boolean}%
{TRUE}%
{should the choice which sols to take be randomized?}%
{}

\printoption{heuristics/crossover/uselprows}%
{boolean}%
{FALSE}%
{should subproblem be created out of the rows in the LP rows?}%
{}

\printoption{heuristics/dins/copycuts}%
{boolean}%
{TRUE}%
{if uselprows == FALSE, should all active cuts from cutpool be copied to constraints in subproblem?}%
{}

\printoption{heuristics/dins/maxdepth}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal depth level to call primal heuristic $<$dins$>$ (-1: no limit)}%
{}

\printoption{heuristics/dins/maxnodes}%
{$0\leq\textrm{integer}$}%
{$5000$}%
{maximum number of nodes to regard in the subproblem}%
{}

\printoption{heuristics/dins/minimprove}%
{$0\leq\textrm{real}\leq1$}%
{$0.01$}%
{factor by which dins should at least improve the incumbent}%
{}

\printoption{heuristics/dins/nwaitingnodes}%
{$0\leq\textrm{integer}$}%
{$0$}%
{number of nodes without incumbent change that heuristic should wait}%
{}

\printoption{heuristics/dins/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$-1105000$}%
{priority of heuristic $<$dins$>$}%
{}

\printoption{heuristics/dins/uselprows}%
{boolean}%
{FALSE}%
{should subproblem be created out of the rows in the LP rows?}%
{}

\printoption{heuristics/feaspump/copycuts}%
{boolean}%
{TRUE}%
{should all active cuts from cutpool be copied to constraints in subproblem?}%
{}

\printoption{heuristics/feaspump/cyclelength}%
{$1\leq\textrm{integer}\leq100$}%
{$3$}%
{maximum length of cycles to be checked explicitly in each round}%
{}

\printoption{heuristics/feaspump/maxdepth}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal depth level to call primal heuristic $<$feaspump$>$ (-1: no limit)}%
{}

\printoption{heuristics/feaspump/maxloops}%
{$-1\leq\textrm{integer}$}%
{$10000$}%
{maximal number of pumping loops (-1: no limit)}%
{}

\printoption{heuristics/feaspump/maxsols}%
{$-1\leq\textrm{integer}$}%
{$10$}%
{total number of feasible solutions found up to which heuristic is called (-1: no limit)}%
{}

\printoption{heuristics/feaspump/maxstallloops}%
{$-1\leq\textrm{integer}$}%
{$10$}%
{maximal number of pumping rounds without fractionality improvement (-1: no limit)}%
{}

\printoption{heuristics/feaspump/minflips}%
{$1\leq\textrm{integer}$}%
{$10$}%
{minimum number of random variables to flip, if a 1-cycle is encountered}%
{}

\printoption{heuristics/feaspump/perturbfreq}%
{$1\leq\textrm{integer}$}%
{$100$}%
{number of iterations until a random perturbation is forced}%
{}

\printoption{heuristics/feaspump/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$-1000000$}%
{priority of heuristic $<$feaspump$>$}%
{}

\printoption{heuristics/fixandinfer/maxdepth}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal depth level to call primal heuristic $<$fixandinfer$>$ (-1: no limit)}%
{}

\printoption{heuristics/fixandinfer/minfixings}%
{$0\leq\textrm{integer}$}%
{$100$}%
{minimal number of fixings to apply before dive may be aborted}%
{}

\printoption{heuristics/fixandinfer/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$-500000$}%
{priority of heuristic $<$fixandinfer$>$}%
{}

\printoption{heuristics/fixandinfer/proprounds}%
{$-1\leq\textrm{integer}$}%
{$0$}%
{maximal number of propagation rounds in probing subproblems (-1: no limit, 0: auto)}%
{}

\printoption{heuristics/fracdiving/maxdepth}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal depth level to call primal heuristic $<$fracdiving$>$ (-1: no limit)}%
{}

\printoption{heuristics/fracdiving/maxdiveavgquot}%
{$0\leq\textrm{real}$}%
{$0$}%
{maximal quotient (curlowerbound - lowerbound)/(avglowerbound - lowerbound) where diving is performed (0.0: no limit)}%
{}

\printoption{heuristics/fracdiving/maxdiveavgquotnosol}%
{$0\leq\textrm{real}$}%
{$0$}%
{maximal AVGQUOT when no solution was found yet (0.0: no limit)}%
{}

\printoption{heuristics/fracdiving/maxdiveubquot}%
{$0\leq\textrm{real}\leq1$}%
{$0.8$}%
{maximal quotient (curlowerbound - lowerbound)/(cutoffbound - lowerbound) where diving is performed (0.0: no limit)}%
{}

\printoption{heuristics/fracdiving/maxdiveubquotnosol}%
{$0\leq\textrm{real}\leq1$}%
{$0.1$}%
{maximal UBQUOT when no solution was found yet (0.0: no limit)}%
{}

\printoption{heuristics/fracdiving/maxreldepth}%
{$0\leq\textrm{real}\leq1$}%
{$1$}%
{maximal relative depth to start diving}%
{}

\printoption{heuristics/fracdiving/minreldepth}%
{$0\leq\textrm{real}\leq1$}%
{$0$}%
{minimal relative depth to start diving}%
{}

\printoption{heuristics/fracdiving/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$-1003000$}%
{priority of heuristic $<$fracdiving$>$}%
{}

\printoption{heuristics/guideddiving/maxdepth}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal depth level to call primal heuristic $<$guideddiving$>$ (-1: no limit)}%
{}

\printoption{heuristics/guideddiving/maxdiveavgquot}%
{$0\leq\textrm{real}$}%
{$0$}%
{maximal quotient (curlowerbound - lowerbound)/(avglowerbound - lowerbound) where diving is performed (0.0: no limit)}%
{}

\printoption{heuristics/guideddiving/maxdiveubquot}%
{$0\leq\textrm{real}\leq1$}%
{$0.8$}%
{maximal quotient (curlowerbound - lowerbound)/(cutoffbound - lowerbound) where diving is performed (0.0: no limit)}%
{}

\printoption{heuristics/guideddiving/maxreldepth}%
{$0\leq\textrm{real}\leq1$}%
{$1$}%
{maximal relative depth to start diving}%
{}

\printoption{heuristics/guideddiving/minreldepth}%
{$0\leq\textrm{real}\leq1$}%
{$0$}%
{minimal relative depth to start diving}%
{}

\printoption{heuristics/guideddiving/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$-1007000$}%
{priority of heuristic $<$guideddiving$>$}%
{}

\printoption{heuristics/intdiving/maxdepth}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal depth level to call primal heuristic $<$intdiving$>$ (-1: no limit)}%
{}

\printoption{heuristics/intdiving/maxdiveavgquot}%
{$0\leq\textrm{real}$}%
{$0$}%
{maximal quotient (curlowerbound - lowerbound)/(avglowerbound - lowerbound) where diving is performed (0.0: no limit)}%
{}

\printoption{heuristics/intdiving/maxdiveavgquotnosol}%
{$0\leq\textrm{real}$}%
{$0$}%
{maximal AVGQUOT when no solution was found yet (0.0: no limit)}%
{}

\printoption{heuristics/intdiving/maxdiveubquot}%
{$0\leq\textrm{real}\leq1$}%
{$0.8$}%
{maximal quotient (curlowerbound - lowerbound)/(cutoffbound - lowerbound) where diving is performed (0.0: no limit)}%
{}

\printoption{heuristics/intdiving/maxdiveubquotnosol}%
{$0\leq\textrm{real}\leq1$}%
{$0.1$}%
{maximal UBQUOT when no solution was found yet (0.0: no limit)}%
{}

\printoption{heuristics/intdiving/maxreldepth}%
{$0\leq\textrm{real}\leq1$}%
{$1$}%
{maximal relative depth to start diving}%
{}

\printoption{heuristics/intdiving/minreldepth}%
{$0\leq\textrm{real}\leq1$}%
{$0$}%
{minimal relative depth to start diving}%
{}

\printoption{heuristics/intdiving/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$-1003500$}%
{priority of heuristic $<$intdiving$>$}%
{}

\printoption{heuristics/intshifting/maxdepth}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal depth level to call primal heuristic $<$intshifting$>$ (-1: no limit)}%
{}

\printoption{heuristics/intshifting/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$-10000$}%
{priority of heuristic $<$intshifting$>$}%
{}

\printoption{heuristics/linesearchdiving/maxdepth}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal depth level to call primal heuristic $<$linesearchdiving$>$ (-1: no limit)}%
{}

\printoption{heuristics/linesearchdiving/maxdiveavgquot}%
{$0\leq\textrm{real}$}%
{$0$}%
{maximal quotient (curlowerbound - lowerbound)/(avglowerbound - lowerbound) where diving is performed (0.0: no limit)}%
{}

\printoption{heuristics/linesearchdiving/maxdiveavgquotnosol}%
{$0\leq\textrm{real}$}%
{$0$}%
{maximal AVGQUOT when no solution was found yet (0.0: no limit)}%
{}

\printoption{heuristics/linesearchdiving/maxdiveubquot}%
{$0\leq\textrm{real}\leq1$}%
{$0.8$}%
{maximal quotient (curlowerbound - lowerbound)/(cutoffbound - lowerbound) where diving is performed (0.0: no limit)}%
{}

\printoption{heuristics/linesearchdiving/maxdiveubquotnosol}%
{$0\leq\textrm{real}\leq1$}%
{$0.1$}%
{maximal UBQUOT when no solution was found yet (0.0: no limit)}%
{}

\printoption{heuristics/linesearchdiving/maxreldepth}%
{$0\leq\textrm{real}\leq1$}%
{$1$}%
{maximal relative depth to start diving}%
{}

\printoption{heuristics/linesearchdiving/minreldepth}%
{$0\leq\textrm{real}\leq1$}%
{$0$}%
{minimal relative depth to start diving}%
{}

\printoption{heuristics/linesearchdiving/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$-1006000$}%
{priority of heuristic $<$linesearchdiving$>$}%
{}

\printoption{heuristics/localbranching/copycuts}%
{boolean}%
{TRUE}%
{if uselprows == FALSE, should all active cuts from cutpool be copied to constraints in subproblem?}%
{}

\printoption{heuristics/localbranching/maxdepth}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal depth level to call primal heuristic $<$localbranching$>$ (-1: no limit)}%
{}

\printoption{heuristics/localbranching/maxnodes}%
{$0\leq\textrm{integer}$}%
{$10000$}%
{maximum number of nodes to regard in the subproblem}%
{}

\printoption{heuristics/localbranching/minimprove}%
{$0\leq\textrm{real}\leq1$}%
{$0.01$}%
{factor by which localbranching should at least improve the incumbent}%
{}

\printoption{heuristics/localbranching/minnodes}%
{$0\leq\textrm{integer}$}%
{$1000$}%
{minimum number of nodes required to start the subproblem}%
{}

\printoption{heuristics/localbranching/nwaitingnodes}%
{$0\leq\textrm{integer}$}%
{$200$}%
{number of nodes without incumbent change that heuristic should wait}%
{}

\printoption{heuristics/localbranching/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$-1102000$}%
{priority of heuristic $<$localbranching$>$}%
{}

\printoption{heuristics/localbranching/uselprows}%
{boolean}%
{FALSE}%
{should subproblem be created out of the rows in the LP rows?}%
{}

\printoption{heuristics/mutation/copycuts}%
{boolean}%
{TRUE}%
{if uselprows == FALSE, should all active cuts from cutpool be copied to constraints in subproblem?}%
{}

\printoption{heuristics/mutation/maxdepth}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal depth level to call primal heuristic $<$mutation$>$ (-1: no limit)}%
{}

\printoption{heuristics/mutation/maxnodes}%
{$0\leq\textrm{integer}$}%
{$5000$}%
{maximum number of nodes to regard in the subproblem}%
{}

\printoption{heuristics/mutation/minimprove}%
{$0\leq\textrm{real}\leq1$}%
{$0.01$}%
{factor by which mutation should at least improve the incumbent}%
{}

\printoption{heuristics/mutation/minnodes}%
{$0\leq\textrm{integer}$}%
{$500$}%
{minimum number of nodes required to start the subproblem}%
{}

\printoption{heuristics/mutation/nwaitingnodes}%
{$0\leq\textrm{integer}$}%
{$200$}%
{number of nodes without incumbent change that heuristic should wait}%
{}

\printoption{heuristics/mutation/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$-1103000$}%
{priority of heuristic $<$mutation$>$}%
{}

\printoption{heuristics/mutation/uselprows}%
{boolean}%
{FALSE}%
{should subproblem be created out of the rows in the LP rows?}%
{}

\printoption{heuristics/nlpdiving/lp}%
{boolean}%
{FALSE}%
{should the LP relaxation be solved before the NLP relaxation?}%
{}

\printoption{heuristics/nlpdiving/maxdepth}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal depth level to call primal heuristic $<$nlpdiving$>$ (-1: no limit)}%
{}

\printoption{heuristics/nlpdiving/maxdiveavgquot}%
{$0\leq\textrm{real}$}%
{$0$}%
{maximal quotient (curlowerbound - lowerbound)/(avglowerbound - lowerbound) where diving is performed (0.0: no limit)}%
{}

\printoption{heuristics/nlpdiving/maxdiveavgquotnosol}%
{$0\leq\textrm{real}$}%
{$0$}%
{maximal AVGQUOT when no solution was found yet (0.0: no limit)}%
{}

\printoption{heuristics/nlpdiving/maxdiveubquot}%
{$0\leq\textrm{real}\leq1$}%
{$0.8$}%
{maximal quotient (curlowerbound - lowerbound)/(cutoffbound - lowerbound) where diving is performed (0.0: no limit)}%
{}

\printoption{heuristics/nlpdiving/maxdiveubquotnosol}%
{$0\leq\textrm{real}\leq1$}%
{$0.1$}%
{maximal UBQUOT when no solution was found yet (0.0: no limit)}%
{}

\printoption{heuristics/nlpdiving/maxreldepth}%
{$0\leq\textrm{real}\leq1$}%
{$1$}%
{maximal relative depth to start diving}%
{}

\printoption{heuristics/nlpdiving/minreldepth}%
{$0\leq\textrm{real}\leq1$}%
{$0$}%
{minimal relative depth to start diving}%
{}

\printoption{heuristics/nlpdiving/nlpstart}%
{character}%
{s}%
{which point should be used as starting point for the NLP solver? ('n'one, last 'f'easible, from dive's'tart)}%
{}

\printoption{heuristics/nlpdiving/preferlpfracs}%
{boolean}%
{FALSE}%
{prefer variables that are also fractional in LP solution?}%
{}

\printoption{heuristics/nlpdiving/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$-1003000$}%
{priority of heuristic $<$nlpdiving$>$}%
{}

\printoption{heuristics/objpscostdiving/depthfac}%
{$0\leq\textrm{real}$}%
{$0.5$}%
{maximal diving depth: number of binary/integer variables times depthfac}%
{}

\printoption{heuristics/objpscostdiving/depthfacnosol}%
{$0\leq\textrm{real}$}%
{$2$}%
{maximal diving depth factor if no feasible solution was found yet}%
{}

\printoption{heuristics/objpscostdiving/maxdepth}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal depth level to call primal heuristic $<$objpscostdiving$>$ (-1: no limit)}%
{}

\printoption{heuristics/objpscostdiving/maxreldepth}%
{$0\leq\textrm{real}\leq1$}%
{$1$}%
{maximal relative depth to start diving}%
{}

\printoption{heuristics/objpscostdiving/maxsols}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{total number of feasible solutions found up to which heuristic is called (-1: no limit)}%
{}

\printoption{heuristics/objpscostdiving/minreldepth}%
{$0\leq\textrm{real}\leq1$}%
{$0$}%
{minimal relative depth to start diving}%
{}

\printoption{heuristics/objpscostdiving/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$-1004000$}%
{priority of heuristic $<$objpscostdiving$>$}%
{}

\printoption{heuristics/octane/ffirst}%
{$1\leq\textrm{integer}$}%
{$10$}%
{number of 0-1-points to be tested at first whether they violate a common row}%
{}

\printoption{heuristics/octane/fmax}%
{$1\leq\textrm{integer}$}%
{$100$}%
{number of 0-1-points to be tested as possible solutions by OCTANE}%
{}

\printoption{heuristics/octane/maxdepth}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal depth level to call primal heuristic $<$octane$>$ (-1: no limit)}%
{}

\printoption{heuristics/octane/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$-1008000$}%
{priority of heuristic $<$octane$>$}%
{}

\printoption{heuristics/octane/useavgnbray}%
{boolean}%
{TRUE}%
{should the weighted average of the nonbasic cone be used as one ray direction?}%
{}

\printoption{heuristics/octane/useavgray}%
{boolean}%
{TRUE}%
{should the average of the basic cone be used as one ray direction?}%
{}

\printoption{heuristics/octane/useavgwgtray}%
{boolean}%
{TRUE}%
{should the weighted average of the basic cone be used as one ray direction?}%
{}

\printoption{heuristics/octane/usediffray}%
{boolean}%
{FALSE}%
{should the difference between the root solution and the current LP solution be used as one ray direction?}%
{}

\printoption{heuristics/octane/usefracspace}%
{boolean}%
{TRUE}%
{execute OCTANE only in the space of fractional variables (TRUE) or in the full space?}%
{}

\printoption{heuristics/octane/useobjray}%
{boolean}%
{TRUE}%
{should the inner normal of the objective be used as one ray direction?}%
{}

\printoption{heuristics/oneopt/beforepresol}%
{boolean}%
{FALSE}%
{should the heuristic be called before presolving?}%
{}

\printoption{heuristics/oneopt/duringroot}%
{boolean}%
{TRUE}%
{should the heuristic be called before and during the root node?}%
{}

\printoption{heuristics/oneopt/forcelpconstruction}%
{boolean}%
{FALSE}%
{should the construction of the LP be forced even if LP solving is deactivated?}%
{}

\printoption{heuristics/oneopt/maxdepth}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal depth level to call primal heuristic $<$oneopt$>$ (-1: no limit)}%
{}

\printoption{heuristics/oneopt/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$-20000$}%
{priority of heuristic $<$oneopt$>$}%
{}

\printoption{heuristics/oneopt/weightedobj}%
{boolean}%
{TRUE}%
{should the objective be weighted with the potential shifting value when sorting the shifting candidates?}%
{}

\printoption{heuristics/pscostdiving/maxdepth}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal depth level to call primal heuristic $<$pscostdiving$>$ (-1: no limit)}%
{}

\printoption{heuristics/pscostdiving/maxdiveavgquot}%
{$0\leq\textrm{real}$}%
{$0$}%
{maximal quotient (curlowerbound - lowerbound)/(avglowerbound - lowerbound) where diving is performed (0.0: no limit)}%
{}

\printoption{heuristics/pscostdiving/maxdiveavgquotnosol}%
{$0\leq\textrm{real}$}%
{$0$}%
{maximal AVGQUOT when no solution was found yet (0.0: no limit)}%
{}

\printoption{heuristics/pscostdiving/maxdiveubquot}%
{$0\leq\textrm{real}\leq1$}%
{$0.8$}%
{maximal quotient (curlowerbound - lowerbound)/(cutoffbound - lowerbound) where diving is performed (0.0: no limit)}%
{}

\printoption{heuristics/pscostdiving/maxdiveubquotnosol}%
{$0\leq\textrm{real}\leq1$}%
{$0.1$}%
{maximal UBQUOT when no solution was found yet (0.0: no limit)}%
{}

\printoption{heuristics/pscostdiving/maxreldepth}%
{$0\leq\textrm{real}\leq1$}%
{$1$}%
{maximal relative depth to start diving}%
{}

\printoption{heuristics/pscostdiving/minreldepth}%
{$0\leq\textrm{real}\leq1$}%
{$0$}%
{minimal relative depth to start diving}%
{}

\printoption{heuristics/pscostdiving/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$-1002000$}%
{priority of heuristic $<$pscostdiving$>$}%
{}

\printoption{heuristics/rens/addallsols}%
{boolean}%
{FALSE}%
{should all subproblem solutions be added to the original SCIP?}%
{}

\printoption{heuristics/rens/binarybounds}%
{boolean}%
{TRUE}%
{should general integers get binary bounds [floor(.),ceil(.)] ?}%
{}

\printoption{heuristics/rens/copycuts}%
{boolean}%
{TRUE}%
{if uselprows == FALSE, should all active cuts from cutpool be copied to constraints in subproblem?}%
{}

\printoption{heuristics/rens/extratime}%
{boolean}%
{FALSE}%
{should the RENS sub-CIP get its own full time limit? This is only for tesing and not recommended!}%
{}

\printoption{heuristics/rens/fullscale}%
{boolean}%
{FALSE}%
{should the RENS sub-CIP be solved with cuts, conflicts, strong branching,... This is only for tesing and not recommended!}%
{}

\printoption{heuristics/rens/maxdepth}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal depth level to call primal heuristic $<$rens$>$ (-1: no limit)}%
{}

\printoption{heuristics/rens/maxnodes}%
{$0\leq\textrm{integer}$}%
{$5000$}%
{maximum number of nodes to regard in the subproblem}%
{}

\printoption{heuristics/rens/minimprove}%
{$0\leq\textrm{real}\leq1$}%
{$0.01$}%
{factor by which RENS should at least improve the incumbent}%
{}

\printoption{heuristics/rens/minnodes}%
{$0\leq\textrm{integer}$}%
{$500$}%
{minimum number of nodes required to start the subproblem}%
{}

\printoption{heuristics/rens/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$-1100000$}%
{priority of heuristic $<$rens$>$}%
{}

\printoption{heuristics/rens/uselprows}%
{boolean}%
{FALSE}%
{should subproblem be created out of the rows in the LP rows?}%
{}

\printoption{heuristics/rins/copycuts}%
{boolean}%
{TRUE}%
{if uselprows == FALSE, should all active cuts from cutpool be copied to constraints in subproblem?}%
{}

\printoption{heuristics/rins/maxdepth}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal depth level to call primal heuristic $<$rins$>$ (-1: no limit)}%
{}

\printoption{heuristics/rins/maxnodes}%
{$0\leq\textrm{integer}$}%
{$5000$}%
{maximum number of nodes to regard in the subproblem}%
{}

\printoption{heuristics/rins/minimprove}%
{$0\leq\textrm{real}\leq1$}%
{$0.01$}%
{factor by which rins should at least improve the incumbent}%
{}

\printoption{heuristics/rins/minnodes}%
{$0\leq\textrm{integer}$}%
{$500$}%
{minimum number of nodes required to start the subproblem}%
{}

\printoption{heuristics/rins/nwaitingnodes}%
{$0\leq\textrm{integer}$}%
{$200$}%
{number of nodes without incumbent change that heuristic should wait}%
{}

\printoption{heuristics/rins/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$-1101000$}%
{priority of heuristic $<$rins$>$}%
{}

\printoption{heuristics/rins/uselprows}%
{boolean}%
{FALSE}%
{should subproblem be created out of the rows in the LP rows?}%
{}

\printoption{heuristics/rootsoldiving/alpha}%
{$0\leq\textrm{real}\leq1$}%
{$0.9$}%
{soft rounding factor to fade out objective coefficients}%
{}

\printoption{heuristics/rootsoldiving/depthfac}%
{$0\leq\textrm{real}$}%
{$0.5$}%
{maximal diving depth: number of binary/integer variables times depthfac}%
{}

\printoption{heuristics/rootsoldiving/depthfacnosol}%
{$0\leq\textrm{real}$}%
{$2$}%
{maximal diving depth factor if no feasible solution was found yet}%
{}

\printoption{heuristics/rootsoldiving/maxdepth}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal depth level to call primal heuristic $<$rootsoldiving$>$ (-1: no limit)}%
{}

\printoption{heuristics/rootsoldiving/maxreldepth}%
{$0\leq\textrm{real}\leq1$}%
{$1$}%
{maximal relative depth to start diving}%
{}

\printoption{heuristics/rootsoldiving/maxsols}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{total number of feasible solutions found up to which heuristic is called (-1: no limit)}%
{}

\printoption{heuristics/rootsoldiving/minreldepth}%
{$0\leq\textrm{real}\leq1$}%
{$0$}%
{minimal relative depth to start diving}%
{}

\printoption{heuristics/rootsoldiving/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$-1005000$}%
{priority of heuristic $<$rootsoldiving$>$}%
{}

\printoption{heuristics/rounding/maxdepth}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal depth level to call primal heuristic $<$rounding$>$ (-1: no limit)}%
{}

\printoption{heuristics/rounding/oncepernode}%
{boolean}%
{FALSE}%
{should the heuristic only be called once per node?}%
{}

\printoption{heuristics/rounding/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$-1000$}%
{priority of heuristic $<$rounding$>$}%
{}

\printoption{heuristics/rounding/successfactor}%
{$-1\leq\textrm{integer}$}%
{$100$}%
{number of calls per found solution that are considered as standard success, a higher factor causes the heuristic to be called more often}%
{}

\printoption{heuristics/shiftandpropagate/cutoffbreaker}%
{$-1\leq\textrm{integer}\leq1000000$}%
{$15$}%
{The number of cutoffs before heuristic stops}%
{}

\printoption{heuristics/shiftandpropagate/maxdepth}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal depth level to call primal heuristic $<$shiftandpropagate$>$ (-1: no limit)}%
{}

\printoption{heuristics/shiftandpropagate/nproprounds}%
{$-1\leq\textrm{integer}\leq1000$}%
{$10$}%
{The number of propagation rounds used for each propagation}%
{}

\printoption{heuristics/shiftandpropagate/onlywithoutsol}%
{boolean}%
{TRUE}%
{Should heuristic only be executed if no primal solution was found, yet?}%
{}

\printoption{heuristics/shiftandpropagate/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$1000$}%
{priority of heuristic $<$shiftandpropagate$>$}%
{}

\printoption{heuristics/shiftandpropagate/probing}%
{boolean}%
{TRUE}%
{Should domains be reduced by probing?}%
{}

\printoption{heuristics/shiftandpropagate/relax}%
{boolean}%
{TRUE}%
{Should continuous variables be relaxed?}%
{}

\printoption{heuristics/shiftandpropagate/sortkey}%
{character}%
{u}%
{the key for variable sorting: (n)orms or (r)andom}%
{}

\printoption{heuristics/shiftandpropagate/sortvars}%
{boolean}%
{TRUE}%
{Should variables be sorted for the heuristic?}%
{}

\printoption{heuristics/shifting/maxdepth}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal depth level to call primal heuristic $<$shifting$>$ (-1: no limit)}%
{}

\printoption{heuristics/shifting/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$-5000$}%
{priority of heuristic $<$shifting$>$}%
{}

\printoption{heuristics/simplerounding/maxdepth}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal depth level to call primal heuristic $<$simplerounding$>$ (-1: no limit)}%
{}

\printoption{heuristics/simplerounding/oncepernode}%
{boolean}%
{FALSE}%
{should the heuristic only be called once per node?}%
{}

\printoption{heuristics/simplerounding/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$0$}%
{priority of heuristic $<$simplerounding$>$}%
{}

\printoption{heuristics/subnlp/keepcopy}%
{boolean}%
{TRUE}%
{whether to keep SCIP copy or to create new copy each time heuristic is applied}%
{}

\printoption{heuristics/subnlp/maxdepth}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal depth level to call primal heuristic $<$subnlp$>$ (-1: no limit)}%
{}

\printoption{heuristics/subnlp/maxpresolverounds}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{limit on number of presolve rounds in sub-SCIP (-1 for unlimited, 0 for no presolve)}%
{}

\printoption{heuristics/subnlp/minimprove}%
{$0\leq\textrm{real}\leq1$}%
{$0.01$}%
{factor by which NLP heuristic should at least improve the incumbent}%
{}

\printoption{heuristics/subnlp/nlpoptfile}%
{string}%
{}%
{name of an NLP solver specific options file}%
{}

\printoption{heuristics/subnlp/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$-2000000$}%
{priority of heuristic $<$subnlp$>$}%
{}

\printoption{heuristics/subnlp/resolvefromscratch}%
{boolean}%
{TRUE}%
{should the NLP resolve be started from the original starting point or the infeasible solution?}%
{}

\printoption{heuristics/subnlp/resolvetolfactor}%
{$0\leq\textrm{real}\leq1$}%
{$0.001$}%
{if SCIP does not accept a NLP feasible solution, resolve NLP with feas. tolerance reduced by this factor (set to 1.0 to turn off resolve)}%
{}

\printoption{heuristics/trivial/maxdepth}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal depth level to call primal heuristic $<$trivial$>$ (-1: no limit)}%
{}

\printoption{heuristics/trivial/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$10000$}%
{priority of heuristic $<$trivial$>$}%
{}

\printoption{heuristics/trysol/maxdepth}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal depth level to call primal heuristic $<$trysol$>$ (-1: no limit)}%
{}

\printoption{heuristics/trysol/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$-3000000$}%
{priority of heuristic $<$trysol$>$}%
{}

\printoption{heuristics/twoopt/intopt}%
{boolean}%
{FALSE}%
{ Should Integer-2-Optimization be applied or not?}%
{}

\printoption{heuristics/twoopt/matchingrate}%
{$0\leq\textrm{real}\leq1$}%
{$0.5$}%
{parameter to determine the percentage of rows two variables have to share before they are considered equal}%
{}

\printoption{heuristics/twoopt/maxdepth}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal depth level to call primal heuristic $<$twoopt$>$ (-1: no limit)}%
{}

\printoption{heuristics/twoopt/maxnslaves}%
{$-1\leq\textrm{integer}\leq1000000$}%
{$199$}%
{maximum number of slaves for one master variable}%
{}

\printoption{heuristics/twoopt/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$-20100$}%
{priority of heuristic $<$twoopt$>$}%
{}

\printoption{heuristics/twoopt/waitingnodes}%
{$0\leq\textrm{integer}\leq10000$}%
{$0$}%
{user parameter to determine number of nodes to wait after last best solution before calling heuristic}%
{}

\printoption{heuristics/undercover/beforecuts}%
{boolean}%
{TRUE}%
{should the heuristic be called at root node before cut separation?}%
{}

\printoption{heuristics/undercover/conflictweight}%
{$\textrm{real}$}%
{$1000$}%
{weight for conflict score in fixing order}%
{}

\printoption{heuristics/undercover/copycuts}%
{boolean}%
{TRUE}%
{should all active cuts from cutpool be copied to constraints in subproblem?}%
{}

\printoption{heuristics/undercover/coverbd}%
{boolean}%
{FALSE}%
{should bounddisjunction constraints be covered (or just copied)?}%
{}

\printoption{heuristics/undercover/coveringobj}%
{character}%
{u}%
{objective function of the covering problem (influenced nonlinear 'c'onstraints/'t'erms, 'd'omain size, 'l'ocks, 'm'in of up/down locks, 'u'nit penalties)}%
{}

\printoption{heuristics/undercover/cutoffweight}%
{$0\leq\textrm{real}$}%
{$1$}%
{weight for cutoff score in fixing order}%
{}

\printoption{heuristics/undercover/fixingorder}%
{character}%
{v}%
{order in which variables should be fixed (increasing 'C'onflict score, decreasing 'c'onflict score, increasing 'V'ariable index, decreasing 'v'ariable index}%
{}

\printoption{heuristics/undercover/fixintfirst}%
{boolean}%
{FALSE}%
{should integer variables in the cover be fixed first?}%
{}

\printoption{heuristics/undercover/inferenceweight}%
{$\textrm{real}$}%
{$1$}%
{weight for inference score in fixing order}%
{}

\printoption{heuristics/undercover/locksrounding}%
{boolean}%
{TRUE}%
{shall LP values for integer vars be rounded according to locks?}%
{}

\printoption{heuristics/undercover/maxbacktracks}%
{$0\leq\textrm{integer}$}%
{$6$}%
{maximum number of backtracks in fix-and-propagate}%
{}

\printoption{heuristics/undercover/maxcoversizeconss}%
{$0\leq\textrm{real}$}%
{$\infty$}%
{maximum coversize maximum coversize (as ratio to the percentage of non-affected constraints)}%
{}

\printoption{heuristics/undercover/maxcoversizevars}%
{$0\leq\textrm{real}\leq1$}%
{$1$}%
{maximum coversize (as fraction of total number of variables)}%
{}

\printoption{heuristics/undercover/maxdepth}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal depth level to call primal heuristic $<$undercover$>$ (-1: no limit)}%
{}

\printoption{heuristics/undercover/maxnodes}%
{$0\leq\textrm{integer}$}%
{$500$}%
{maximum number of nodes to regard in the subproblem}%
{}

\printoption{heuristics/undercover/maxrecovers}%
{$0\leq\textrm{integer}$}%
{$0$}%
{maximum number of recoverings}%
{}

\printoption{heuristics/undercover/maxreorders}%
{$0\leq\textrm{integer}$}%
{$1$}%
{maximum number of reorderings of the fixing order}%
{}

\printoption{heuristics/undercover/mincoveredabs}%
{$0\leq\textrm{integer}$}%
{$5$}%
{minimum number of nonlinear constraints in the original problem}%
{}

\printoption{heuristics/undercover/mincoveredrel}%
{$0\leq\textrm{real}\leq1$}%
{$0.15$}%
{minimum percentage of nonlinear constraints in the original problem}%
{}

\printoption{heuristics/undercover/minimprove}%
{$-1\leq\textrm{real}\leq1$}%
{$0$}%
{factor by which the heuristic should at least improve the incumbent}%
{}

\printoption{heuristics/undercover/minnodes}%
{$0\leq\textrm{integer}$}%
{$500$}%
{minimum number of nodes required to start the subproblem}%
{}

\printoption{heuristics/undercover/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$-1110000$}%
{priority of heuristic $<$undercover$>$}%
{}

\printoption{heuristics/undercover/recoverdiv}%
{$0\leq\textrm{real}\leq1$}%
{$0.9$}%
{fraction of covering variables in the last cover which need to change their value when recovering}%
{}

\printoption{heuristics/undercover/reusecover}%
{boolean}%
{FALSE}%
{shall the cover be reused if a conflict was added after an infeasible subproblem?}%
{}

\printoption{heuristics/vbounds/copycuts}%
{boolean}%
{TRUE}%
{should all active cuts from cutpool be copied to constraints in subproblem?}%
{}

\printoption{heuristics/vbounds/maxdepth}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal depth level to call primal heuristic $<$vbounds$>$ (-1: no limit)}%
{}

\printoption{heuristics/vbounds/maxnodes}%
{$0\leq\textrm{integer}$}%
{$5000$}%
{maximum number of nodes to regard in the subproblem}%
{}

\printoption{heuristics/vbounds/maxproprounds}%
{$-1\leq\textrm{integer}\leq536870911$}%
{$2$}%
{maximum number of propagation rounds during probing (-1 infinity)}%
{}

\printoption{heuristics/vbounds/minimprove}%
{$0\leq\textrm{real}\leq1$}%
{$0.01$}%
{factor by which vbounds heuristic should at least improve the incumbent}%
{}

\printoption{heuristics/vbounds/minnodes}%
{$0\leq\textrm{integer}$}%
{$500$}%
{minimum number of nodes required to start the subproblem}%
{}

\printoption{heuristics/vbounds/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$-1106000$}%
{priority of heuristic $<$vbounds$>$}%
{}

\printoption{heuristics/veclendiving/maxdepth}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal depth level to call primal heuristic $<$veclendiving$>$ (-1: no limit)}%
{}

\printoption{heuristics/veclendiving/maxdiveavgquot}%
{$0\leq\textrm{real}$}%
{$0$}%
{maximal quotient (curlowerbound - lowerbound)/(avglowerbound - lowerbound) where diving is performed (0.0: no limit)}%
{}

\printoption{heuristics/veclendiving/maxdiveavgquotnosol}%
{$0\leq\textrm{real}$}%
{$0$}%
{maximal AVGQUOT when no solution was found yet (0.0: no limit)}%
{}

\printoption{heuristics/veclendiving/maxdiveubquot}%
{$0\leq\textrm{real}\leq1$}%
{$0.8$}%
{maximal quotient (curlowerbound - lowerbound)/(cutoffbound - lowerbound) where diving is performed (0.0: no limit)}%
{}

\printoption{heuristics/veclendiving/maxdiveubquotnosol}%
{$0\leq\textrm{real}\leq1$}%
{$0.1$}%
{maximal UBQUOT when no solution was found yet (0.0: no limit)}%
{}

\printoption{heuristics/veclendiving/maxreldepth}%
{$0\leq\textrm{real}\leq1$}%
{$1$}%
{maximal relative depth to start diving}%
{}

\printoption{heuristics/veclendiving/minreldepth}%
{$0\leq\textrm{real}\leq1$}%
{$0$}%
{minimal relative depth to start diving}%
{}

\printoption{heuristics/veclendiving/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$-1003100$}%
{priority of heuristic $<$veclendiving$>$}%
{}

\printoption{heuristics/zeroobj/addallsols}%
{boolean}%
{FALSE}%
{should all subproblem solutions be added to the original SCIP?}%
{}

\printoption{heuristics/zeroobj/maxdepth}%
{$-1\leq\textrm{integer}$}%
{$0$}%
{maximal depth level to call primal heuristic $<$zeroobj$>$ (-1: no limit)}%
{}

\printoption{heuristics/zeroobj/maxlpiters}%
{$-1\leq\textrm{integer}$}%
{$5000$}%
{maximum number of LP iterations to be performed in the subproblem}%
{}

\printoption{heuristics/zeroobj/maxnodes}%
{$0\leq\textrm{integer}$}%
{$1000$}%
{maximum number of nodes to regard in the subproblem}%
{}

\printoption{heuristics/zeroobj/minimprove}%
{$0\leq\textrm{real}\leq1$}%
{$0.01$}%
{factor by which zeroobj should at least improve the incumbent}%
{}

\printoption{heuristics/zeroobj/minnodes}%
{$0\leq\textrm{integer}$}%
{$100$}%
{minimum number of nodes required to start the subproblem}%
{}

\printoption{heuristics/zeroobj/onlywithoutsol}%
{boolean}%
{TRUE}%
{should heuristic only be executed if no primal solution was found, yet?}%
{}

\printoption{heuristics/zeroobj/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$100$}%
{priority of heuristic $<$zeroobj$>$}%
{}

\printoption{heuristics/zirounding/maxdepth}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal depth level to call primal heuristic $<$zirounding$>$ (-1: no limit)}%
{}

\printoption{heuristics/zirounding/maxroundingloops}%
{$-1\leq\textrm{integer}$}%
{$2$}%
{determines maximum number of rounding loops}%
{}

\printoption{heuristics/zirounding/minstopncalls}%
{$1\leq\textrm{integer}$}%
{$1000$}%
{determines the minimum number of calls before percentage-based deactivation of Zirounding is applied}%
{}

\printoption{heuristics/zirounding/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$-500$}%
{priority of heuristic $<$zirounding$>$}%
{}

\printoption{heuristics/zirounding/stoppercentage}%
{$0\leq\textrm{real}\leq1$}%
{$0.02$}%
{if percentage of found solutions falls below this parameter, Zirounding will be deactivated}%
{}

\printoption{heuristics/zirounding/stopziround}%
{boolean}%
{TRUE}%
{flag to determine if Zirounding is deactivated after a certain percentage of unsuccessful calls}%
{}

\printoptioncategory{Limits}
\printoption{limits/absgap}%
{$0\leq\textrm{real}$}%
{$0$}%
{solving stops, if the absolute gap = $|$primalbound - dualbound$|$ is below the given value}%
{}

\printoption{limits/bestsol}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{solving stops, if the given number of solution improvements were found (-1: no limit)}%
{}

\printoption{limits/gap}%
{$0\leq\textrm{real}$}%
{$0.1$}%
{solving stops, if the relative gap = $|$primal - dual$|$/MIN($|$dual$|$,$|$primal$|$) is below the given value}%
{}

\printoption{limits/maxorigsol}%
{$0\leq\textrm{integer}$}%
{$10$}%
{maximal number of solutions candidates to store in the solution storage of the original problem}%
{}

\printoption{limits/maxsol}%
{$1\leq\textrm{integer}$}%
{$100$}%
{maximal number of solutions to store in the solution storage}%
{}

\printoption{limits/memory}%
{$0\leq\textrm{real}$}%
{$\infty$}%
{maximal memory usage in MB; reported memory usage is lower than real memory usage!}%
{}

\printoption{limits/nodes}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal number of nodes to process (-1: no limit)}%
{}

\printoption{limits/restarts}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{solving stops, if the given number of restarts was triggered (-1: no limit)}%
{}

\printoption{limits/solutions}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{solving stops, if the given number of solutions were found (-1: no limit)}%
{}

\printoption{limits/stallnodes}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{solving stops, if the given number of nodes was processed since the last improvement of the primal solution value (-1: no limit)}%
{}

\printoption{limits/time}%
{$0\leq\textrm{real}$}%
{$1000$}%
{maximal time in seconds to run}%
{}

\printoption{limits/totalnodes}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal number of total nodes (incl. restarts) to process (-1: no limit)}%
{}

\printoptioncategory{LP}
\printoption{lp/initalgorithm}%
{character}%
{s}%
{LP algorithm for solving initial LP relaxations (automatic 's'implex, 'p'rimal simplex, 'd'ual simplex, 'b'arrier, barrier with 'c'rossover)}%
{}

\printoption{lp/pricing}%
{character}%
{l}%
{LP pricing strategy ('l'pi default, 'a'uto, 'f'ull pricing, 'p'artial, 's'teepest edge pricing, 'q'uickstart steepest edge pricing, 'd'evex pricing)}%
{}

\printoption{lp/resolvealgorithm}%
{character}%
{s}%
{LP algorithm for resolving LP relaxations if a starting basis exists (automatic 's'implex, 'p'rimal simplex, 'd'ual simplex, 'b'arrier, barrier with 'c'rossover)}%
{}

\printoption{lp/solvedepth}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal depth for solving LP at the nodes (-1: no depth limit)}%
{}

\printoption{lp/solvefreq}%
{$-1\leq\textrm{integer}$}%
{$1$}%
{frequency for solving LP at the nodes (-1: never; 0: only root LP)}%
{}

\printoption{lp/solver}%
{string}%
{cplex, if licensed, otherwise soplex}%
{LP solver to use (clp, cplex, soplex)}%
{}

\printoptioncategory{LP (advanced options)}
\printoption{lp/checkfeas}%
{boolean}%
{TRUE}%
{should LP solutions be checked, resolving LP when numerical troubles occur?}%
{}

\printoption{lp/checkstability}%
{boolean}%
{TRUE}%
{should LP solver's return status be checked for stability?}%
{}

\printoption{lp/cleanupcols}%
{boolean}%
{FALSE}%
{should new non-basic columns be removed after LP solving?}%
{}

\printoption{lp/cleanupcolsroot}%
{boolean}%
{FALSE}%
{should new non-basic columns be removed after root LP solving?}%
{}

\printoption{lp/cleanuprows}%
{boolean}%
{TRUE}%
{should new basic rows be removed after LP solving?}%
{}

\printoption{lp/cleanuprowsroot}%
{boolean}%
{TRUE}%
{should new basic rows be removed after root LP solving?}%
{}

\printoption{lp/clearinitialprobinglp}%
{boolean}%
{TRUE}%
{should lp state be cleared at the end of probing mode when lp was initially unsolved, e.g., when called right after presolving?}%
{}

\printoption{lp/colagelimit}%
{$-1\leq\textrm{integer}$}%
{$10$}%
{maximum age a dynamic column can reach before it is deleted from the LP (-1: don't delete columns due to aging)}%
{}

\printoption{lp/fastmip}%
{$0\leq\textrm{integer}\leq1$}%
{$1$}%
{which FASTMIP setting of LP solver should be used? 0: off, 1: low}%
{}

\printoption{lp/freesolvalbuffers}%
{boolean}%
{FALSE}%
{should the buffers for storing LP solution values during diving be freed at end of diving?}%
{}

\printoption{lp/iterlim}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{iteration limit for each single LP solve (-1: no limit)}%
{}

\printoption{lp/lexdualalgo}%
{boolean}%
{FALSE}%
{should the lexicographic dual alogrithm be used?}%
{}

\printoption{lp/lexdualbasic}%
{boolean}%
{FALSE}%
{choose fractional basic variables in lexicographic dual algorithm?}%
{}

\printoption{lp/lexdualmaxrounds}%
{$-1\leq\textrm{integer}$}%
{$2$}%
{maximum number of rounds in the  lexicographic dual algorithm (-1: unbounded)}%
{}

\printoption{lp/lexdualrootonly}%
{boolean}%
{TRUE}%
{should the lexicographic dual algorithm be applied only at the root node}%
{}

\printoption{lp/lexdualstalling}%
{boolean}%
{TRUE}%
{turn on the lex dual algorithm only when stalling?}%
{}

\printoption{lp/presolving}%
{boolean}%
{TRUE}%
{should presolving of LP solver be used?}%
{}

\printoption{lp/resolveiterfac}%
{$-1\leq\textrm{real}$}%
{$-1$}%
{factor of average LP iterations that is used as LP iteration limit for LP resolve (-1: unlimited)}%
{}

\printoption{lp/resolveitermin}%
{$1\leq\textrm{integer}$}%
{$1000$}%
{minimum number of iterations that are allowed for LP resolve}%
{}

\printoption{lp/resolverestore}%
{boolean}%
{FALSE}%
{should the LP be resolved to restore the state at start of diving (if FALSE we buffer the solution values)?}%
{}

\printoption{lp/rootiterlim}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{iteration limit for initial root LP solve (-1: no limit)}%
{}

\printoption{lp/rowagelimit}%
{$-1\leq\textrm{integer}$}%
{$10$}%
{maximum age a dynamic row can reach before it is deleted from the LP (-1: don't delete rows due to aging)}%
{}

\printoption{lp/rowrepswitch}%
{$-1\leq\textrm{real}$}%
{$-1$}%
{simplex algorithm shall use row representation of the basis if number of rows divided by number of columns exceeds this value (-1.0 to disable row representation)}%
{}

\printoption{lp/scaling}%
{boolean}%
{TRUE}%
{should scaling of LP solver be used?}%
{}

\printoption{lp/threads}%
{$0\leq\textrm{integer}\leq64$}%
{$0$}%
{number of threads used for solving the LP (0: automatic)}%
{}

\printoptioncategory{Memory}
\printoption{memory/savefac}%
{$0\leq\textrm{real}\leq1$}%
{$0.8$}%
{fraction of maximal memory usage resulting in switch to memory saving mode}%
{}

\printoptioncategory{Memory (advanced options)}
\printoption{memory/arraygrowfac}%
{$1\leq\textrm{real}\leq10$}%
{$1.2$}%
{memory growing factor for dynamically allocated arrays}%
{}

\printoption{memory/arraygrowinit}%
{$0\leq\textrm{integer}$}%
{$4$}%
{initial size of dynamically allocated arrays}%
{}

\printoption{memory/pathgrowfac}%
{$1\leq\textrm{real}\leq10$}%
{$2$}%
{memory growing factor for path array}%
{}

\printoption{memory/pathgrowinit}%
{$0\leq\textrm{integer}$}%
{$256$}%
{initial size of path array}%
{}

\printoption{memory/treegrowfac}%
{$1\leq\textrm{real}\leq10$}%
{$2$}%
{memory growing factor for tree array}%
{}

\printoption{memory/treegrowinit}%
{$0\leq\textrm{integer}$}%
{$65536$}%
{initial size of tree array}%
{}

\printoptioncategory{Micellaneous}
\printoption{misc/catchctrlc}%
{boolean}%
{TRUE}%
{should the CTRL-C interrupt be caught by SCIP?}%
{}

\printoption{misc/estimexternmem}%
{boolean}%
{TRUE}%
{should the usage of external memory be estimated?}%
{}

\printoption{misc/improvingsols}%
{boolean}%
{FALSE}%
{should only solutions be checked which improve the primal bound}%
{}

\printoption{misc/permutationseed}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{seed value for permuting the problem after the problem was transformed (-1: no permutation)}%
{}

\printoption{misc/printreason}%
{boolean}%
{TRUE}%
{should the reason be printed if a given start solution is infeasible}%
{}

\printoption{misc/resetstat}%
{boolean}%
{TRUE}%
{should the statistics be reset if the transformed problem is freed (in case of a benders decomposition this parameter should be set to FALSE)}%
{}

\printoption{misc/transorigsols}%
{boolean}%
{TRUE}%
{should SCIP try to transfer original solutions to the extended space (after presolving)?}%
{}

\printoption{misc/useconstable}%
{boolean}%
{TRUE}%
{should a hashtable be used to map from constraint names to constraints?}%
{}

\printoption{misc/usesmalltables}%
{boolean}%
{FALSE}%
{should smaller hashtables be used? yields better performance for small problems with about 100 variables}%
{}

\printoption{misc/usevartable}%
{boolean}%
{TRUE}%
{should a hashtable be used to map from variable names to variables?}%
{}

\printoptioncategory{Node Selection}
\printoption{nodeselection/bfs/stdpriority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$100000$}%
{priority of node selection rule $<$bfs$>$ in standard mode}%
{}

\printoption{nodeselection/childsel}%
{character}%
{h}%
{child selection rule ('d'own, 'u'p, 'p'seudo costs, 'i'nference, 'l'p value, 'r'oot LP value difference, 'h'ybrid inference/root LP value difference)}%
{}

\printoption{nodeselection/dfs/stdpriority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$0$}%
{priority of node selection rule $<$dfs$>$ in standard mode}%
{}

\printoption{nodeselection/estimate/bestnodefreq}%
{$0\leq\textrm{integer}$}%
{$10$}%
{frequency at which the best node instead of the best estimate is selected (0: never)}%
{}

\printoption{nodeselection/estimate/breadthfirstdepth}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{depth until breadth-fisrt search is applied}%
{}

\printoption{nodeselection/estimate/stdpriority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$200000$}%
{priority of node selection rule $<$estimate$>$ in standard mode}%
{}

\printoption{nodeselection/hybridestim/bestnodefreq}%
{$0\leq\textrm{integer}$}%
{$1000$}%
{frequency at which the best node instead of the hybrid best estimate / best bound is selected (0: never)}%
{}

\printoption{nodeselection/hybridestim/stdpriority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$50000$}%
{priority of node selection rule $<$hybridestim$>$ in standard mode}%
{}

\printoption{nodeselection/restartdfs/countonlyleaves}%
{boolean}%
{TRUE}%
{count only leaf nodes (otherwise all nodes)?}%
{}

\printoption{nodeselection/restartdfs/selectbestfreq}%
{$0\leq\textrm{integer}$}%
{$100$}%
{frequency for selecting the best node instead of the deepest one}%
{}

\printoption{nodeselection/restartdfs/stdpriority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$10000$}%
{priority of node selection rule $<$restartdfs$>$ in standard mode}%
{}

\printoptioncategory{Node Selection (advanced options)}
\printoption{nodeselection/bfs/maxplungedepth}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal plunging depth, before new best node is forced to be selected (-1 for dynamic setting)}%
{}

\printoption{nodeselection/bfs/maxplungequot}%
{$0\leq\textrm{real}$}%
{$0.25$}%
{maximal quotient (curlowerbound - lowerbound)/(cutoffbound - lowerbound) where plunging is performed}%
{}

\printoption{nodeselection/bfs/memsavepriority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$0$}%
{priority of node selection rule $<$bfs$>$ in memory saving mode}%
{}

\printoption{nodeselection/bfs/minplungedepth}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{minimal plunging depth, before new best node may be selected (-1 for dynamic setting)}%
{}

\printoption{nodeselection/dfs/memsavepriority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$100000$}%
{priority of node selection rule $<$dfs$>$ in memory saving mode}%
{}

\printoption{nodeselection/estimate/maxplungedepth}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal plunging depth, before new best node is forced to be selected (-1 for dynamic setting)}%
{}

\printoption{nodeselection/estimate/maxplungequot}%
{$0\leq\textrm{real}$}%
{$0.25$}%
{maximal quotient (estimate - lowerbound)/(cutoffbound - lowerbound) where plunging is performed}%
{}

\printoption{nodeselection/estimate/memsavepriority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$100$}%
{priority of node selection rule $<$estimate$>$ in memory saving mode}%
{}

\printoption{nodeselection/estimate/minplungedepth}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{minimal plunging depth, before new best node may be selected (-1 for dynamic setting)}%
{}

\printoption{nodeselection/hybridestim/estimweight}%
{$0\leq\textrm{real}\leq1$}%
{$0.1$}%
{weight of estimate value in node selection score (0: pure best bound search, 1: pure best estimate search)}%
{}

\printoption{nodeselection/hybridestim/maxplungedepth}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal plunging depth, before new best node is forced to be selected (-1 for dynamic setting)}%
{}

\printoption{nodeselection/hybridestim/maxplungequot}%
{$0\leq\textrm{real}$}%
{$0.25$}%
{maximal quotient (estimate - lowerbound)/(cutoffbound - lowerbound) where plunging is performed}%
{}

\printoption{nodeselection/hybridestim/memsavepriority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$50$}%
{priority of node selection rule $<$hybridestim$>$ in memory saving mode}%
{}

\printoption{nodeselection/hybridestim/minplungedepth}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{minimal plunging depth, before new best node may be selected (-1 for dynamic setting)}%
{}

\printoption{nodeselection/restartdfs/memsavepriority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$50000$}%
{priority of node selection rule $<$restartdfs$>$ in memory saving mode}%
{}

\printoptioncategory{Tolerances}
\printoption{numerics/dualfeastol}%
{$10^{-17}\leq\textrm{real}\leq0.001$}%
{$10^{- 6}$}%
{feasibility tolerance for reduced costs in LP solution}%
{}

\printoption{numerics/epsilon}%
{$10^{-20}\leq\textrm{real}\leq0.001$}%
{$10^{- 9}$}%
{absolute values smaller than this are considered zero}%
{}

\printoption{numerics/feastol}%
{$10^{-17}\leq\textrm{real}\leq0.001$}%
{$10^{- 6}$}%
{feasibility tolerance for constraints}%
{}

\printoption{numerics/lpfeastol}%
{$10^{-17}\leq\textrm{real}\leq0.001$}%
{$10^{- 6}$}%
{primal feasibility tolerance of LP solver}%
{}

\printoption{numerics/sumepsilon}%
{$10^{-17}\leq\textrm{real}\leq0.001$}%
{$10^{- 6}$}%
{absolute values of sums smaller than this are considered zero}%
{}

\printoptioncategory{Tolerances (advanced options)}
\printoption{numerics/barrierconvtol}%
{$10^{-17}\leq\textrm{real}\leq0.001$}%
{$10^{-10}$}%
{LP convergence tolerance used in barrier algorithm}%
{}

\printoption{numerics/boundstreps}%
{$10^{-17}\leq\textrm{real}$}%
{$0.05$}%
{minimal relative improve for strengthening bounds}%
{}

\printoption{numerics/hugeval}%
{$0\leq\textrm{real}$}%
{$10^{ 15}$}%
{values larger than this are considered huge and should be handled separately (e.g., in activity computation)}%
{}

\printoption{numerics/pseudocostdelta}%
{$0\leq\textrm{real}$}%
{$0.0001$}%
{minimal objective distance value to use for branching pseudo cost updates}%
{}

\printoption{numerics/pseudocosteps}%
{$10^{-17}\leq\textrm{real}\leq1$}%
{$0.1$}%
{minimal variable distance value to use for branching pseudo cost updates}%
{}

\printoption{numerics/recomputefac}%
{$0\leq\textrm{real}$}%
{$10^{  7}$}%
{minimal decrease factor that causes the recomputation of a value (e.g., pseudo objective) instead of an update}%
{}

\printoptioncategory{Presolving}
\printoption{presolving/boundshift/maxrounds}%
{$-1\leq\textrm{integer}$}%
{$0$}%
{maximal number of presolving rounds the presolver participates in (-1: no limit)}%
{}

\printoption{presolving/components/intfactor}%
{$0\leq\textrm{real}$}%
{$1$}%
{the weight of an integer variable compared to binary variables}%
{}

\printoption{presolving/components/maxintvars}%
{$-1\leq\textrm{integer}$}%
{$500$}%
{maximum number of integer (or binary) variables to solve a subproblem directly (-1: unlimited)}%
{}

\printoption{presolving/components/maxrounds}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal number of presolving rounds the presolver participates in (-1: no limit)}%
{}

\printoption{presolving/components/nodelimit}%
{$-1\leq\textrm{integer}$}%
{$10000$}%
{maximum number of nodes to be solved in subproblems}%
{}

\printoption{presolving/components/reldecrease}%
{$0\leq\textrm{real}\leq1$}%
{$0.2$}%
{percentage by which the number of variables has to be decreased after the last component solving to allow running again (1.0: do not run again)}%
{}

\printoption{presolving/components/writeproblems}%
{boolean}%
{FALSE}%
{should the single components be written as an .lp-file?}%
{}

\printoption{presolving/convertinttobin/maxrounds}%
{$-1\leq\textrm{integer}$}%
{$0$}%
{maximal number of presolving rounds the presolver participates in (-1: no limit)}%
{}

\printoption{presolving/domcol/maxrounds}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal number of presolving rounds the presolver participates in (-1: no limit)}%
{}

\printoption{presolving/dualfix/maxrounds}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal number of presolving rounds the presolver participates in (-1: no limit)}%
{}

\printoption{presolving/gateextraction/maxrounds}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal number of presolving rounds the presolver participates in (-1: no limit)}%
{}

\printoption{presolving/implics/maxrounds}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal number of presolving rounds the presolver participates in (-1: no limit)}%
{}

\printoption{presolving/inttobinary/maxrounds}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal number of presolving rounds the presolver participates in (-1: no limit)}%
{}

\printoption{presolving/maxrestarts}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal number of restarts (-1: unlimited)}%
{}

\printoption{presolving/maxrounds}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal number of presolving rounds (-1: unlimited, 0: off)}%
{}

\printoption{presolving/trivial/maxrounds}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal number of presolving rounds the presolver participates in (-1: no limit)}%
{}

\printoptioncategory{Presolving (advanced options)}
\printoption{presolving/abortfac}%
{$0\leq\textrm{real}\leq1$}%
{$0.0001$}%
{abort presolve, if at most this fraction of the problem was changed in last presolve round}%
{}

\printoption{presolving/boundshift/delay}%
{boolean}%
{FALSE}%
{should presolver be delayed, if other presolvers found reductions?}%
{}

\printoption{presolving/boundshift/flipping}%
{boolean}%
{TRUE}%
{is flipping allowed (multiplying with -1)?}%
{}

\printoption{presolving/boundshift/integer}%
{boolean}%
{TRUE}%
{shift only integer ranges?}%
{}

\printoption{presolving/boundshift/maxshift}%
{$0\leq\textrm{integer}$}%
{$\infty$}%
{absolute value of maximum shift}%
{}

\printoption{presolving/boundshift/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$7900000$}%
{priority of presolver $<$boundshift$>$}%
{}

\printoption{presolving/components/delay}%
{boolean}%
{TRUE}%
{should presolver be delayed, if other presolvers found reductions?}%
{}

\printoption{presolving/components/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$-9200000$}%
{priority of presolver $<$components$>$}%
{}

\printoption{presolving/convertinttobin/delay}%
{boolean}%
{FALSE}%
{should presolver be delayed, if other presolvers found reductions?}%
{}

\printoption{presolving/convertinttobin/maxdomainsize}%
{$0\leq\textrm{integer}$}%
{$\infty$}%
{absolute value of maximum domain size for converting an integer variable to binaries variables}%
{}

\printoption{presolving/convertinttobin/onlypoweroftwo}%
{boolean}%
{FALSE}%
{should only integer variables with a domain size of 2\^p - 1 be converted(, there we don't need an knapsack-constraint for restricting the sum of the binaries)}%
{}

\printoption{presolving/convertinttobin/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$6000000$}%
{priority of presolver $<$convertinttobin$>$}%
{}

\printoption{presolving/convertinttobin/samelocksinbothdirections}%
{boolean}%
{FALSE}%
{should only integer variables with uplocks equals downlocks be converted}%
{}

\printoption{presolving/domcol/delay}%
{boolean}%
{TRUE}%
{should presolver be delayed, if other presolvers found reductions?}%
{}

\printoption{presolving/domcol/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$20000000$}%
{priority of presolver $<$domcol$>$}%
{}

\printoption{presolving/donotaggr}%
{boolean}%
{FALSE}%
{should aggregation of variables be forbidden?}%
{}

\printoption{presolving/donotmultaggr}%
{boolean}%
{FALSE}%
{should multi-aggregation of variables be forbidden?}%
{}

\printoption{presolving/dualfix/delay}%
{boolean}%
{FALSE}%
{should presolver be delayed, if other presolvers found reductions?}%
{}

\printoption{presolving/dualfix/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$8000000$}%
{priority of presolver $<$dualfix$>$}%
{}

\printoption{presolving/gateextraction/delay}%
{boolean}%
{TRUE}%
{should presolver be delayed, if other presolvers found reductions?}%
{}

\printoption{presolving/gateextraction/onlysetpart}%
{boolean}%
{FALSE}%
{should we only try to extract set-partitioning constraints and no and-constraints}%
{}

\printoption{presolving/gateextraction/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$1000000$}%
{priority of presolver $<$gateextraction$>$}%
{}

\printoption{presolving/gateextraction/searchequations}%
{boolean}%
{TRUE}%
{should we try to extract set-partitioning constraint out of one logicor and one corresponding set-packing constraint}%
{}

\printoption{presolving/gateextraction/sorting}%
{$-1\leq\textrm{integer}\leq1$}%
{$1$}%
{order logicor contraints to extract big-gates before smaller ones (-1), do not order them (0) or order them to extract smaller gates at first (1)}%
{}

\printoption{presolving/immrestartfac}%
{$0\leq\textrm{real}\leq1$}%
{$0.2$}%
{fraction of integer variables that were fixed in the root node triggering an immediate restart with preprocessing}%
{}

\printoption{presolving/implics/delay}%
{boolean}%
{FALSE}%
{should presolver be delayed, if other presolvers found reductions?}%
{}

\printoption{presolving/implics/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$-10000$}%
{priority of presolver $<$implics$>$}%
{}

\printoption{presolving/inttobinary/delay}%
{boolean}%
{FALSE}%
{should presolver be delayed, if other presolvers found reductions?}%
{}

\printoption{presolving/inttobinary/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$7000000$}%
{priority of presolver $<$inttobinary$>$}%
{}

\printoption{presolving/restartfac}%
{$0\leq\textrm{real}\leq1$}%
{$0.05$}%
{fraction of integer variables that were fixed in the root node triggering a restart with preprocessing after root node evaluation}%
{}

\printoption{presolving/restartminred}%
{$0\leq\textrm{real}\leq1$}%
{$0.1$}%
{minimal fraction of integer variables removed after restart to allow for an additional restart}%
{}

\printoption{presolving/subrestartfac}%
{$0\leq\textrm{real}\leq1$}%
{$1$}%
{fraction of integer variables that were globally fixed during the solving process triggering a restart with preprocessing}%
{}

\printoption{presolving/trivial/delay}%
{boolean}%
{FALSE}%
{should presolver be delayed, if other presolvers found reductions?}%
{}

\printoption{presolving/trivial/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$9000000$}%
{priority of presolver $<$trivial$>$}%
{}

\printoptioncategory{Domain Propagation}
\printoption{propagating/abortoncutoff}%
{boolean}%
{TRUE}%
{should propagation be aborted immediately? setting this to FALSE could help conflict analysis to produce more conflict constraints}%
{}

\printoption{propagating/genvbounds/freq}%
{$-1\leq\textrm{integer}$}%
{$1$}%
{frequency for calling propagator $<$genvbounds$>$ (-1: never, 0: only in root node)}%
{}

\printoption{propagating/genvbounds/maxprerounds}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal number of presolving rounds the propagator participates in (-1: no limit)}%
{}

\printoption{propagating/maxrounds}%
{$-1\leq\textrm{integer}$}%
{$100$}%
{maximal number of propagation rounds per node (-1: unlimited)}%
{}

\printoption{propagating/maxroundsroot}%
{$-1\leq\textrm{integer}$}%
{$1000$}%
{maximal number of propagation rounds in the root node (-1: unlimited)}%
{}

\printoption{propagating/obbt/dualfeastol}%
{$0\leq\textrm{real}$}%
{$10^{- 9}$}%
{feasibility tolerance for reduced costs used in obbt; this value is used if SCIP's dual feastol is greater}%
{}

\printoption{propagating/obbt/freq}%
{$-1\leq\textrm{integer}$}%
{$0$}%
{frequency for calling propagator $<$obbt$>$ (-1: never, 0: only in root node)}%
{}

\printoption{propagating/obbt/itlimitfactor}%
{$\textrm{real}$}%
{$5$}%
{multiple of root node LP iterations used as total LP iteration limit for obbt ($<$= 0: no limit )}%
{}

\printoption{propagating/obbt/maxlookahead}%
{$-1\leq\textrm{integer}$}%
{$3$}%
{maximal number of bounds evaluated without success per group (-1: no limit)}%
{}

\printoption{propagating/obbt/maxprerounds}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal number of presolving rounds the propagator participates in (-1: no limit)}%
{}

\printoption{propagating/probing/freq}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{frequency for calling propagator $<$probing$>$ (-1: never, 0: only in root node)}%
{}

\printoption{propagating/probing/maxprerounds}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal number of presolving rounds the propagator participates in (-1: no limit)}%
{}

\printoption{propagating/probing/maxruns}%
{$-1\leq\textrm{integer}$}%
{$1$}%
{maximal number of runs, probing participates in (-1: no limit)}%
{}

\printoption{propagating/pseudoobj/freq}%
{$-1\leq\textrm{integer}$}%
{$1$}%
{frequency for calling propagator $<$pseudoobj$>$ (-1: never, 0: only in root node)}%
{}

\printoption{propagating/pseudoobj/maxprerounds}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal number of presolving rounds the propagator participates in (-1: no limit)}%
{}

\printoption{propagating/redcost/continuous}%
{boolean}%
{FALSE}%
{should reduced cost fixing be also applied to continuous variables?}%
{}

\printoption{propagating/redcost/freq}%
{$-1\leq\textrm{integer}$}%
{$1$}%
{frequency for calling propagator $<$redcost$>$ (-1: never, 0: only in root node)}%
{}

\printoption{propagating/redcost/maxprerounds}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal number of presolving rounds the propagator participates in (-1: no limit)}%
{}

\printoption{propagating/redcost/useimplics}%
{boolean}%
{TRUE}%
{should implications be used to strength the reduced cost for binary variables?}%
{}

\printoption{propagating/rootredcost/freq}%
{$-1\leq\textrm{integer}$}%
{$1$}%
{frequency for calling propagator $<$rootredcost$>$ (-1: never, 0: only in root node)}%
{}

\printoption{propagating/rootredcost/maxprerounds}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal number of presolving rounds the propagator participates in (-1: no limit)}%
{}

\printoption{propagating/vbounds/dotoposort}%
{boolean}%
{TRUE}%
{should the bounds be topologically sorted in advance?}%
{}

\printoption{propagating/vbounds/freq}%
{$-1\leq\textrm{integer}$}%
{$1$}%
{frequency for calling propagator $<$vbounds$>$ (-1: never, 0: only in root node)}%
{}

\printoption{propagating/vbounds/maxprerounds}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal number of presolving rounds the propagator participates in (-1: no limit)}%
{}

\printoption{propagating/vbounds/sortcliques}%
{boolean}%
{FALSE}%
{should cliques be regarded for the topological sort?}%
{}

\printoption{propagating/vbounds/usebdwidening}%
{boolean}%
{TRUE}%
{should bound widening be used to initialize conflict analysis?}%
{}

\printoption{propagating/vbounds/usecliques}%
{boolean}%
{FALSE}%
{should cliques be propagated?}%
{}

\printoption{propagating/vbounds/useimplics}%
{boolean}%
{FALSE}%
{should implications be propagated?}%
{}

\printoption{propagating/vbounds/usevbounds}%
{boolean}%
{TRUE}%
{should vbounds be propagated?}%
{}

\printoptioncategory{Domain Propagation (advanced options)}
\printoption{propagating/genvbounds/delay}%
{boolean}%
{FALSE}%
{should propagator be delayed, if other propagators found reductions?}%
{}

\printoption{propagating/genvbounds/global}%
{boolean}%
{TRUE}%
{apply global propagation?}%
{}

\printoption{propagating/genvbounds/presoldelay}%
{boolean}%
{FALSE}%
{should presolving be delayed, if other presolvers found reductions?}%
{}

\printoption{propagating/genvbounds/presolpriority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$-2000000$}%
{presolving priority of propagator $<$genvbounds$>$}%
{}

\printoption{propagating/genvbounds/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$3000000$}%
{priority of propagator $<$genvbounds$>$}%
{}

\printoption{propagating/genvbounds/propinrootnode}%
{boolean}%
{TRUE}%
{apply genvbounds in root node if no new incumbent was found?}%
{}

\printoption{propagating/genvbounds/sort}%
{boolean}%
{TRUE}%
{sort genvbounds and wait for bound change events?}%
{}

\printoption{propagating/genvbounds/timingmask}%
{$1\leq\textrm{integer}\leq15$}%
{$15$}%
{timing when propagator should be called (1:BEFORELP, 2:DURINGLPLOOP, 4:AFTERLPLOOP, 15:ALWAYS))}%
{}

\printoption{propagating/obbt/applyfilterrounds}%
{boolean}%
{FALSE}%
{try to filter bounds in so-called filter rounds by solving auxiliary LPs?}%
{}

\printoption{propagating/obbt/creategenvbounds}%
{boolean}%
{TRUE}%
{should obbt try to provide genvbounds if possible?}%
{}

\printoption{propagating/obbt/delay}%
{boolean}%
{TRUE}%
{should propagator be delayed, if other propagators found reductions?}%
{}

\printoption{propagating/obbt/minfilter}%
{$1\leq\textrm{integer}$}%
{$2$}%
{minimal number of filtered bounds to apply another filter round}%
{}

\printoption{propagating/obbt/normalize}%
{boolean}%
{TRUE}%
{should coefficients in filtering be normalized w.r.t. the domains sizes?}%
{}

\printoption{propagating/obbt/presoldelay}%
{boolean}%
{FALSE}%
{should presolving be delayed, if other presolvers found reductions?}%
{}

\printoption{propagating/obbt/presolpriority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$0$}%
{presolving priority of propagator $<$obbt$>$}%
{}

\printoption{propagating/obbt/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$-1000000$}%
{priority of propagator $<$obbt$>$}%
{}

\printoption{propagating/obbt/timingmask}%
{$1\leq\textrm{integer}\leq15$}%
{$4$}%
{timing when propagator should be called (1:BEFORELP, 2:DURINGLPLOOP, 4:AFTERLPLOOP, 15:ALWAYS))}%
{}

\printoption{propagating/probing/delay}%
{boolean}%
{TRUE}%
{should propagator be delayed, if other propagators found reductions?}%
{}

\printoption{propagating/probing/maxdepth}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal depth until propagation is executed(-1: no limit)}%
{}

\printoption{propagating/probing/maxfixings}%
{$0\leq\textrm{integer}$}%
{$25$}%
{maximal number of fixings found, until probing is interrupted (0: don't iterrupt)}%
{}

\printoption{propagating/probing/maxsumuseless}%
{$0\leq\textrm{integer}$}%
{$0$}%
{maximal number of probings without fixings, until probing is aborted (0: don't abort)}%
{}

\printoption{propagating/probing/maxtotaluseless}%
{$0\leq\textrm{integer}$}%
{$50$}%
{maximal number of successive probings without fixings, bound changes, and implications, until probing is aborted (0: don't abort)}%
{}

\printoption{propagating/probing/maxuseless}%
{$0\leq\textrm{integer}$}%
{$1000$}%
{maximal number of successive probings without fixings, until probing is aborted (0: don't abort)}%
{}

\printoption{propagating/probing/presoldelay}%
{boolean}%
{TRUE}%
{should presolving be delayed, if other presolvers found reductions?}%
{}

\printoption{propagating/probing/presolpriority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$-100000$}%
{presolving priority of propagator $<$probing$>$}%
{}

\printoption{propagating/probing/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$-100000$}%
{priority of propagator $<$probing$>$}%
{}

\printoption{propagating/probing/proprounds}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal number of propagation rounds in probing subproblems (-1: no limit, 0: auto)}%
{}

\printoption{propagating/probing/timingmask}%
{$1\leq\textrm{integer}\leq15$}%
{$4$}%
{timing when propagator should be called (1:BEFORELP, 2:DURINGLPLOOP, 4:AFTERLPLOOP, 15:ALWAYS))}%
{}

\printoption{propagating/pseudoobj/delay}%
{boolean}%
{FALSE}%
{should propagator be delayed, if other propagators found reductions?}%
{}

\printoption{propagating/pseudoobj/force}%
{boolean}%
{FALSE}%
{should the propagator be forced even active pricer are present?}%
{}

\printoption{propagating/pseudoobj/maximplvars}%
{$-1\leq\textrm{integer}$}%
{$50000$}%
{maximum number of binary variables the implications are used if turned on (-1: unlimited)?}%
{}

\printoption{propagating/pseudoobj/maxnewvars}%
{$0\leq\textrm{integer}$}%
{$1000$}%
{number of variable added after the propgatore is reinitialized?}%
{}

\printoption{propagating/pseudoobj/maxvarsfrac}%
{$0\leq\textrm{real}\leq1$}%
{$0.1$}%
{maximal fraction of none binary variables with non-zero objective without a bound reduction before aborted}%
{}

\printoption{propagating/pseudoobj/minuseless}%
{$0\leq\textrm{integer}$}%
{$100$}%
{minimal number of successive none binary variable propagator whithout a bound reduction before aborted}%
{}

\printoption{propagating/pseudoobj/presoldelay}%
{boolean}%
{TRUE}%
{should presolving be delayed, if other presolvers found reductions?}%
{}

\printoption{propagating/pseudoobj/presolpriority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$6000000$}%
{presolving priority of propagator $<$pseudoobj$>$}%
{}

\printoption{propagating/pseudoobj/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$3000000$}%
{priority of propagator $<$pseudoobj$>$}%
{}

\printoption{propagating/pseudoobj/propcutoffbound}%
{boolean}%
{TRUE}%
{propagate new cutoff bound directly globally}%
{}

\printoption{propagating/pseudoobj/propfullinroot}%
{boolean}%
{TRUE}%
{do we want to propagate all none binary variables if we are propagating the root node}%
{}

\printoption{propagating/pseudoobj/propuseimplics}%
{boolean}%
{TRUE}%
{use implications to strengthen the propagation of binary variable (increasing the objective change)?}%
{}

\printoption{propagating/pseudoobj/respropuseimplics}%
{boolean}%
{TRUE}%
{use implications to strengthen the resolve propagation of binary variable (increasing the objective change)?}%
{}

\printoption{propagating/pseudoobj/timingmask}%
{$1\leq\textrm{integer}\leq15$}%
{$5$}%
{timing when propagator should be called (1:BEFORELP, 2:DURINGLPLOOP, 4:AFTERLPLOOP, 15:ALWAYS))}%
{}

\printoption{propagating/redcost/delay}%
{boolean}%
{FALSE}%
{should propagator be delayed, if other propagators found reductions?}%
{}

\printoption{propagating/redcost/presoldelay}%
{boolean}%
{FALSE}%
{should presolving be delayed, if other presolvers found reductions?}%
{}

\printoption{propagating/redcost/presolpriority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$0$}%
{presolving priority of propagator $<$redcost$>$}%
{}

\printoption{propagating/redcost/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$1000000$}%
{priority of propagator $<$redcost$>$}%
{}

\printoption{propagating/redcost/timingmask}%
{$1\leq\textrm{integer}\leq15$}%
{$2$}%
{timing when propagator should be called (1:BEFORELP, 2:DURINGLPLOOP, 4:AFTERLPLOOP, 15:ALWAYS))}%
{}

\printoption{propagating/rootredcost/delay}%
{boolean}%
{FALSE}%
{should propagator be delayed, if other propagators found reductions?}%
{}

\printoption{propagating/rootredcost/presoldelay}%
{boolean}%
{FALSE}%
{should presolving be delayed, if other presolvers found reductions?}%
{}

\printoption{propagating/rootredcost/presolpriority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$0$}%
{presolving priority of propagator $<$rootredcost$>$}%
{}

\printoption{propagating/rootredcost/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$10000000$}%
{priority of propagator $<$rootredcost$>$}%
{}

\printoption{propagating/rootredcost/timingmask}%
{$1\leq\textrm{integer}\leq15$}%
{$5$}%
{timing when propagator should be called (1:BEFORELP, 2:DURINGLPLOOP, 4:AFTERLPLOOP, 15:ALWAYS))}%
{}

\printoption{propagating/vbounds/delay}%
{boolean}%
{FALSE}%
{should propagator be delayed, if other propagators found reductions?}%
{}

\printoption{propagating/vbounds/presoldelay}%
{boolean}%
{FALSE}%
{should presolving be delayed, if other presolvers found reductions?}%
{}

\printoption{propagating/vbounds/presolpriority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$0$}%
{presolving priority of propagator $<$vbounds$>$}%
{}

\printoption{propagating/vbounds/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$3000000$}%
{priority of propagator $<$vbounds$>$}%
{}

\printoption{propagating/vbounds/timingmask}%
{$1\leq\textrm{integer}\leq15$}%
{$5$}%
{timing when propagator should be called (1:BEFORELP, 2:DURINGLPLOOP, 4:AFTERLPLOOP, 15:ALWAYS))}%
{}

\printoptioncategory{Separation}
\printoption{separating/cgmip/addviolationcons}%
{boolean}%
{FALSE}%
{add constraint to subscip that only allows violated cuts (otherwise add obj. limit)?}%
{}

\printoption{separating/cgmip/addviolconshdlr}%
{boolean}%
{FALSE}%
{add constraint handler to filter out violated cuts?}%
{}

\printoption{separating/cgmip/allowlocal}%
{boolean}%
{FALSE}%
{Allow to generate local cuts?}%
{}

\printoption{separating/cgmip/cmirownbounds}%
{boolean}%
{FALSE}%
{tell CMIR-generator which bounds to used in rounding?}%
{}

\printoption{separating/cgmip/conshdlrusenorm}%
{boolean}%
{TRUE}%
{should the violation constraint handler use the norm of a cut to check for feasibility?}%
{}

\printoption{separating/cgmip/contconvert}%
{boolean}%
{FALSE}%
{Convert some integral variables to be continuous to reduce the size of the sub-MIP?}%
{}

\printoption{separating/cgmip/contconvfrac}%
{$0\leq\textrm{real}\leq1$}%
{$0.1$}%
{fraction of integral variables converted to be continuous (if contconvert)}%
{}

\printoption{separating/cgmip/contconvmin}%
{$-1\leq\textrm{integer}$}%
{$100$}%
{minimum number of integral variables before some are converted to be continuous}%
{}

\printoption{separating/cgmip/decisiontree}%
{boolean}%
{FALSE}%
{Use decision tree to turn separation on/off?}%
{}

\printoption{separating/cgmip/dynamiccuts}%
{boolean}%
{TRUE}%
{should generated cuts be removed from the LP if they are no longer tight?}%
{}

\printoption{separating/cgmip/earlyterm}%
{boolean}%
{TRUE}%
{terminate separation if a violated (but possibly sub-optimal) cut has been found?}%
{}

\printoption{separating/cgmip/freq}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{frequency for calling separator $<$cgmip$>$ (-1: never, 0: only in root node)}%
{}

\printoption{separating/cgmip/intconvert}%
{boolean}%
{FALSE}%
{Convert some integral variables attaining fractional values to have integral value?}%
{}

\printoption{separating/cgmip/intconvfrac}%
{$0\leq\textrm{real}\leq1$}%
{$0.1$}%
{fraction of frac. integral variables converted to have integral value (if intconvert)}%
{}

\printoption{separating/cgmip/intconvmin}%
{$-1\leq\textrm{integer}$}%
{$100$}%
{minimum number of integral variables before some are converted to have integral value}%
{}

\printoption{separating/cgmip/maxdepth}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal depth at which the separator is applied (-1: unlimited)}%
{}

\printoption{separating/cgmip/maxnodelimit}%
{$-1\leq\textrm{integer}$}%
{$5000$}%
{maximum number of nodes considered for sub-MIP (-1: unlimited)}%
{}

\printoption{separating/cgmip/maxrounds}%
{$-1\leq\textrm{integer}$}%
{$5$}%
{maximal number of cgmip separation rounds per node (-1: unlimited)}%
{}

\printoption{separating/cgmip/maxroundsroot}%
{$-1\leq\textrm{integer}$}%
{$50$}%
{maximal number of cgmip separation rounds in the root node (-1: unlimited)}%
{}

\printoption{separating/cgmip/maxrowage}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal age of rows to consider if onlyactiverows is false}%
{}

\printoption{separating/cgmip/minnodelimit}%
{$-1\leq\textrm{integer}$}%
{$500$}%
{minimum number of nodes considered for sub-MIP (-1: unlimited)}%
{}

\printoption{separating/cgmip/objlone}%
{boolean}%
{FALSE}%
{Should the objective of the sub-MIP minimize the l1-norm of the multipliers?}%
{}

\printoption{separating/cgmip/objweighsize}%
{boolean}%
{FALSE}%
{Weigh each row by its size?}%
{}

\printoption{separating/cgmip/onlyactiverows}%
{boolean}%
{FALSE}%
{Use only active rows to generate cuts?}%
{}

\printoption{separating/cgmip/onlyintvars}%
{boolean}%
{FALSE}%
{Generate cuts for problems with only integer variables?}%
{}

\printoption{separating/cgmip/onlyrankone}%
{boolean}%
{FALSE}%
{Separate only rank 1 inequalities?}%
{}

\printoption{separating/cgmip/primalseparation}%
{boolean}%
{TRUE}%
{only separate cuts that are tight for the best feasible solution?}%
{}

\printoption{separating/cgmip/skipmultbounds}%
{boolean}%
{TRUE}%
{Skip the upper bounds on the multipliers in the sub-MIP?}%
{}

\printoption{separating/cgmip/usecmir}%
{boolean}%
{TRUE}%
{use CMIR-generator (otherwise add cut directly)?}%
{}

\printoption{separating/cgmip/usecutpool}%
{boolean}%
{TRUE}%
{use cutpool to store CG-cuts even if the are not efficient?}%
{}

\printoption{separating/cgmip/usestrongcg}%
{boolean}%
{FALSE}%
{use strong CG-function to strengthen cut?}%
{}

\printoption{separating/clique/freq}%
{$-1\leq\textrm{integer}$}%
{$0$}%
{frequency for calling separator $<$clique$>$ (-1: never, 0: only in root node)}%
{}

\printoption{separating/clique/maxsepacuts}%
{$-1\leq\textrm{integer}$}%
{$10$}%
{maximal number of clique cuts separated per separation round (-1: no limit)}%
{}

\printoption{separating/closecuts/freq}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{frequency for calling separator $<$closecuts$>$ (-1: never, 0: only in root node)}%
{}

\printoption{separating/cmir/dynamiccuts}%
{boolean}%
{TRUE}%
{should generated cuts be removed from the LP if they are no longer tight?}%
{}

\printoption{separating/cmir/freq}%
{$-1\leq\textrm{integer}$}%
{$0$}%
{frequency for calling separator $<$cmir$>$ (-1: never, 0: only in root node)}%
{}

\printoption{separating/cmir/maxrounds}%
{$-1\leq\textrm{integer}$}%
{$3$}%
{maximal number of cmir separation rounds per node (-1: unlimited)}%
{}

\printoption{separating/cmir/maxroundsroot}%
{$-1\leq\textrm{integer}$}%
{$10$}%
{maximal number of cmir separation rounds in the root node (-1: unlimited)}%
{}

\printoption{separating/cmir/maxsepacuts}%
{$0\leq\textrm{integer}$}%
{$100$}%
{maximal number of cmir cuts separated per separation round}%
{}

\printoption{separating/cmir/maxsepacutsroot}%
{$0\leq\textrm{integer}$}%
{$500$}%
{maximal number of cmir cuts separated per separation round in the root node}%
{}

\printoption{separating/flowcover/dynamiccuts}%
{boolean}%
{TRUE}%
{should generated cuts be removed from the LP if they are no longer tight?}%
{}

\printoption{separating/flowcover/freq}%
{$-1\leq\textrm{integer}$}%
{$0$}%
{frequency for calling separator $<$flowcover$>$ (-1: never, 0: only in root node)}%
{}

\printoption{separating/flowcover/maxrounds}%
{$-1\leq\textrm{integer}$}%
{$5$}%
{maximal number of separation rounds per node (-1: unlimited)}%
{}

\printoption{separating/flowcover/maxroundsroot}%
{$-1\leq\textrm{integer}$}%
{$15$}%
{maximal number of separation rounds in the root node (-1: unlimited)}%
{}

\printoption{separating/flowcover/maxsepacuts}%
{$0\leq\textrm{integer}$}%
{$100$}%
{maximal number of flow cover cuts separated per separation round}%
{}

\printoption{separating/flowcover/maxsepacutsroot}%
{$0\leq\textrm{integer}$}%
{$200$}%
{maximal number of flow cover cuts separated per separation round in the root}%
{}

\printoption{separating/gomory/away}%
{$0\leq\textrm{real}\leq0.5$}%
{$0.01$}%
{minimal integrality violation of a basis variable in order to try Gomory cut}%
{}

\printoption{separating/gomory/dynamiccuts}%
{boolean}%
{TRUE}%
{should generated cuts be removed from the LP if they are no longer tight?}%
{}

\printoption{separating/gomory/freq}%
{$-1\leq\textrm{integer}$}%
{$0$}%
{frequency for calling separator $<$gomory$>$ (-1: never, 0: only in root node)}%
{}

\printoption{separating/gomory/maxrounds}%
{$-1\leq\textrm{integer}$}%
{$5$}%
{maximal number of gomory separation rounds per node (-1: unlimited)}%
{}

\printoption{separating/gomory/maxroundsroot}%
{$-1\leq\textrm{integer}$}%
{$10$}%
{maximal number of gomory separation rounds in the root node (-1: unlimited)}%
{}

\printoption{separating/gomory/maxsepacuts}%
{$0\leq\textrm{integer}$}%
{$50$}%
{maximal number of gomory cuts separated per separation round}%
{}

\printoption{separating/gomory/maxsepacutsroot}%
{$0\leq\textrm{integer}$}%
{$200$}%
{maximal number of gomory cuts separated per separation round in the root node}%
{}

\printoption{separating/impliedbounds/freq}%
{$-1\leq\textrm{integer}$}%
{$0$}%
{frequency for calling separator $<$impliedbounds$>$ (-1: never, 0: only in root node)}%
{}

\printoption{separating/intobj/freq}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{frequency for calling separator $<$intobj$>$ (-1: never, 0: only in root node)}%
{}

\printoption{separating/maxbounddist}%
{$0\leq\textrm{real}\leq1$}%
{$1$}%
{maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying separation (0.0: only on current best node, 1.0: on all nodes)}%
{}

\printoption{separating/maxcuts}%
{$0\leq\textrm{integer}$}%
{$100$}%
{maximal number of cuts separated per separation round (0: disable local separation)}%
{}

\printoption{separating/maxcutsroot}%
{$0\leq\textrm{integer}$}%
{$2000$}%
{maximal number of separated cuts at the root node (0: disable root node separation)}%
{}

\printoption{separating/maxrounds}%
{$-1\leq\textrm{integer}$}%
{$5$}%
{maximal number of separation rounds per node (-1: unlimited)}%
{}

\printoption{separating/maxroundsroot}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal number of separation rounds in the root node (-1: unlimited)}%
{}

\printoption{separating/maxstallrounds}%
{$-1\leq\textrm{integer}$}%
{$5$}%
{maximal number of consecutive separation rounds without objective or integrality improvement (-1: no additional restriction)}%
{}

\printoption{separating/mcf/dynamiccuts}%
{boolean}%
{TRUE}%
{should generated cuts be removed from the LP if they are no longer tight?}%
{}

\printoption{separating/mcf/freq}%
{$-1\leq\textrm{integer}$}%
{$0$}%
{frequency for calling separator $<$mcf$>$ (-1: never, 0: only in root node)}%
{}

\printoption{separating/mcf/maxsepacuts}%
{$-1\leq\textrm{integer}$}%
{$100$}%
{maximal number of mcf cuts separated per separation round}%
{}

\printoption{separating/mcf/maxsepacutsroot}%
{$-1\leq\textrm{integer}$}%
{$200$}%
{maximal number of mcf cuts separated per separation round in the root node  -- default separation}%
{}

\printoption{separating/minefficacy}%
{$0\leq\textrm{real}$}%
{$0.05$}%
{minimal efficacy for a cut to enter the LP}%
{}

\printoption{separating/minefficacyroot}%
{$0\leq\textrm{real}$}%
{$0.01$}%
{minimal efficacy for a cut to enter the LP in the root node}%
{}

\printoption{separating/minortho}%
{$0\leq\textrm{real}\leq1$}%
{$0.5$}%
{minimal orthogonality for a cut to enter the LP}%
{}

\printoption{separating/minorthoroot}%
{$0\leq\textrm{real}\leq1$}%
{$0.5$}%
{minimal orthogonality for a cut to enter the LP in the root node}%
{}

\printoption{separating/oddcycle/freq}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{frequency for calling separator $<$oddcycle$>$ (-1: never, 0: only in root node)}%
{}

\printoption{separating/oddcycle/liftoddcycles}%
{boolean}%
{FALSE}%
{should odd cycle cuts be lifted?}%
{}

\printoption{separating/oddcycle/maxrounds}%
{$-1\leq\textrm{integer}$}%
{$10$}%
{maximal number of oddcycle separation rounds per node (-1: unlimited)}%
{}

\printoption{separating/oddcycle/maxroundsroot}%
{$-1\leq\textrm{integer}$}%
{$10$}%
{maximal number of oddcycle separation rounds in the root node (-1: unlimited)}%
{}

\printoption{separating/oddcycle/maxsepacuts}%
{$0\leq\textrm{integer}$}%
{$5000$}%
{maximal number of oddcycle cuts separated per separation round}%
{}

\printoption{separating/oddcycle/maxsepacutsroot}%
{$0\leq\textrm{integer}$}%
{$5000$}%
{maximal number of oddcycle cuts separated per separation round in the root node}%
{}

\printoption{separating/oddcycle/usegls}%
{boolean}%
{TRUE}%
{should the search method by Groetschel, Lovasz, Schrijver be used? Otherwise use levelgraph method by Hoffman, Padberg.}%
{}

\printoption{separating/poolfreq}%
{$-1\leq\textrm{integer}$}%
{$0$}%
{separation frequency for the global cut pool (-1: disable global cut pool, 0: only separate pool at the root)}%
{}

\printoption{separating/rapidlearning/freq}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{frequency for calling separator $<$rapidlearning$>$ (-1: never, 0: only in root node)}%
{}

\printoption{separating/strongcg/dynamiccuts}%
{boolean}%
{TRUE}%
{should generated cuts be removed from the LP if they are no longer tight?}%
{}

\printoption{separating/strongcg/freq}%
{$-1\leq\textrm{integer}$}%
{$0$}%
{frequency for calling separator $<$strongcg$>$ (-1: never, 0: only in root node)}%
{}

\printoption{separating/strongcg/maxrounds}%
{$-1\leq\textrm{integer}$}%
{$5$}%
{maximal number of strong CG separation rounds per node (-1: unlimited)}%
{}

\printoption{separating/strongcg/maxroundsroot}%
{$-1\leq\textrm{integer}$}%
{$20$}%
{maximal number of strong CG separation rounds in the root node (-1: unlimited)}%
{}

\printoption{separating/strongcg/maxsepacuts}%
{$0\leq\textrm{integer}$}%
{$50$}%
{maximal number of strong CG cuts separated per separation round}%
{}

\printoption{separating/strongcg/maxsepacutsroot}%
{$0\leq\textrm{integer}$}%
{$500$}%
{maximal number of strong CG cuts separated per separation round in the root node}%
{}

\printoption{separating/zerohalf/dynamiccuts}%
{boolean}%
{TRUE}%
{should generated cuts be removed from the LP if they are no longer tight?}%
{}

\printoption{separating/zerohalf/freq}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{frequency for calling separator $<$zerohalf$>$ (-1: never, 0: only in root node)}%
{}

\printoption{separating/zerohalf/maxrounds}%
{$-1\leq\textrm{integer}$}%
{$5$}%
{maximal number of zerohalf separation rounds per node (-1: unlimited)}%
{}

\printoption{separating/zerohalf/maxroundsroot}%
{$-1\leq\textrm{integer}$}%
{$10$}%
{maximal number of zerohalf separation rounds in the root node (-1: unlimited)}%
{}

\printoption{separating/zerohalf/maxsepacuts}%
{$0\leq\textrm{integer}$}%
{$50$}%
{maximal number of {0,1/2}-cuts separated per separation round}%
{}

\printoption{separating/zerohalf/maxsepacutsroot}%
{$0\leq\textrm{integer}$}%
{$500$}%
{maximal number of {0,1/2}-cuts separated per separation round in the root node}%
{}

\printoption{separating/zerohalf/preprocessing/decomposeproblem}%
{boolean}%
{FALSE}%
{should problem be decomposed into subproblems (if possible) before applying preprocessing?}%
{}

\printoption{separating/zerohalf/preprocessing/delta}%
{$0\leq\textrm{real}\leq1$}%
{$0.5$}%
{value of delta parameter used in preprocessing method 'd'}%
{}

\printoption{separating/zerohalf/preprocessing/ppmethods}%
{string}%
{CXGXIM}%
{preprocessing methods and ordering:\\   \#                      'd' columns with small LP solution,\\   \#                      'G' modified Gaussian elimination,\\   \#                      'i' identical columns,\\   \#                      'I' identical rows,\\   \#                      'L' large slack rows,\\   \#                      'M' large slack rows (minslack),\\   \#                      's' column singletons,\\   \#                      'X' add trivial zerohalf cuts,\\   \#                      'z' zero columns,\\   \#                      'Z' zero rows,\\   \#                      'C' fast {'z','s'},\\   \#                      'R' fast {'Z','L','I'}\\   \#
   \#                      '-' no preprocessing\\   \#}%
{}

\printoption{separating/zerohalf/separating/auxip/objective}%
{character}%
{v}%
{auxiliary IP objective:\\   \#                      'v' maximize cut violation,\\   \#                      'u' minimize number of aggregated rows in cut,\\   \#                      'w' minimize number of aggregated rows in cut\\   \#                          weighted by the number of rows in the aggregation,\\   \#                      'p' maximize cut violation and penalize a high number\\   \#                          of aggregated rows in the cut weighted by the number\\   \#                          of rows in the aggregation and the penalty factor p\\   \#}%
{}

\printoption{separating/zerohalf/separating/auxip/penaltyfactor}%
{$0\leq\textrm{real}\leq1$}%
{$0.001$}%
{penalty factor used with objective function 'p' of auxiliary IP}%
{}

\printoption{separating/zerohalf/separating/auxip/settingsfile}%
{string}%
{-}%
{optional settings file of the auxiliary IP (-: none)}%
{}

\printoption{separating/zerohalf/separating/auxip/sollimit}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{limits/solutions setting of the auxiliary IP}%
{}

\printoption{separating/zerohalf/separating/auxip/useallsols}%
{boolean}%
{TRUE}%
{should all (proper) solutions of the auxiliary IP be used to generate cuts instead of using only the best?}%
{}

\printoption{separating/zerohalf/separating/forcecutstolp}%
{boolean}%
{FALSE}%
{should the cuts be forced to enter the LP?}%
{}

\printoption{separating/zerohalf/separating/forcecutstosepastore}%
{boolean}%
{FALSE}%
{should the cuts be forced to enter SCIP's sepastore?}%
{}

\printoption{separating/zerohalf/separating/minviolation}%
{$0.001\leq\textrm{real}\leq0.5$}%
{$0.3$}%
{minimal violation of a {0,1/2}-cut to be separated}%
{}

\printoption{separating/zerohalf/separating/sepamethods}%
{string}%
{2g}%
{separating methods and ordering:\\   \#                      '!' stop further processing if a cut was found,\\   \#                      '2' exact polynomial time algorithm (only if matrix has max 2 odd entries per row),\\   \#                      'e' enumeration heuristics (k=1: try all preprocessed rows),\\   \#                      'E' enumeration heuristics (k=2: try all combinations of up to two preprocessed rows),\\   \#                      'g' Extended Gaussian elimination heuristics,\\   \#                      's' auxiliary IP heuristics (i.e. number of solved nodes is limited)\\   \#                      'S' auxiliary IP exact      (i.e. unlimited number of nodes)\\   \#
   \#                      '-' no processing\\   \#}%
{}

\printoptioncategory{Separation (advanced options)}
\printoption{separating/cgmip/cutcoefbnd}%
{$0\leq\textrm{real}$}%
{$1000$}%
{bounds on the values of the coefficients in the CG-cut}%
{}

\printoption{separating/cgmip/delay}%
{boolean}%
{FALSE}%
{should separator be delayed, if other separators found cuts?}%
{}

\printoption{separating/cgmip/maxbounddist}%
{$0\leq\textrm{real}\leq1$}%
{$0$}%
{maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying separator $<$cgmip$>$ (0.0: only on current best node, 1.0: on all nodes)}%
{}

\printoption{separating/cgmip/memorylimit}%
{$0\leq\textrm{real}$}%
{$\infty$}%
{memory limit for sub-MIP}%
{}

\printoption{separating/cgmip/objweight}%
{$0\leq\textrm{real}$}%
{$0.001$}%
{weight used for the row combination coefficient in the sub-MIP objective}%
{}

\printoption{separating/cgmip/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$-1000$}%
{priority of separator $<$cgmip$>$}%
{}

\printoption{separating/cgmip/timelimit}%
{$0\leq\textrm{real}$}%
{$\infty$}%
{time limit for sub-MIP}%
{}

\printoption{separating/clique/backtrackfreq}%
{$0\leq\textrm{integer}$}%
{$1000$}%
{frequency for premature backtracking up to tree level 1 (0: no backtracking)}%
{}

\printoption{separating/clique/cliquedensity}%
{$0\leq\textrm{real}\leq1$}%
{$0.05$}%
{minimal density of cliques to use a dense clique table}%
{}

\printoption{separating/clique/cliquetablemem}%
{$0\leq\textrm{real}\leq2.09715 \cdot 10^{  6}$}%
{$20000$}%
{maximal memory size of dense clique table (in kb)}%
{}

\printoption{separating/clique/delay}%
{boolean}%
{FALSE}%
{should separator be delayed, if other separators found cuts?}%
{}

\printoption{separating/clique/maxbounddist}%
{$0\leq\textrm{real}\leq1$}%
{$0$}%
{maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying separator $<$clique$>$ (0.0: only on current best node, 1.0: on all nodes)}%
{}

\printoption{separating/clique/maxtreenodes}%
{$-1\leq\textrm{integer}$}%
{$10000$}%
{maximal number of nodes in branch and bound tree (-1: no limit)}%
{}

\printoption{separating/clique/maxzeroextensions}%
{$-1\leq\textrm{integer}$}%
{$1000$}%
{maximal number of zero-valued variables extending the clique (-1: no limit)}%
{}

\printoption{separating/clique/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$-5000$}%
{priority of separator $<$clique$>$}%
{}

\printoption{separating/clique/scaleval}%
{$1\leq\textrm{real}$}%
{$1000$}%
{factor for scaling weights}%
{}

\printoption{separating/closecuts/closethres}%
{$-1\leq\textrm{integer}$}%
{$50$}%
{threshold on number of generated cuts below which the ordinary separation is started}%
{}

\printoption{separating/closecuts/delay}%
{boolean}%
{FALSE}%
{should separator be delayed, if other separators found cuts?}%
{}

\printoption{separating/closecuts/inclobjcutoff}%
{boolean}%
{FALSE}%
{include an objective cutoff when computing the relative interior?}%
{}

\printoption{separating/closecuts/maxbounddist}%
{$0\leq\textrm{real}\leq1$}%
{$1$}%
{maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying separator $<$closecuts$>$ (0.0: only on current best node, 1.0: on all nodes)}%
{}

\printoption{separating/closecuts/maxlpiterfactor}%
{$-1\leq\textrm{real}$}%
{$10$}%
{factor for maximal LP iterations in relative interior computation compared to node LP iterations (negative for no limit)}%
{}

\printoption{separating/closecuts/maxunsuccessful}%
{$-1\leq\textrm{integer}$}%
{$0$}%
{turn off separation in current node after unsuccessful calls (-1 never turn off)}%
{}

\printoption{separating/closecuts/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$1000000$}%
{priority of separator $<$closecuts$>$}%
{}

\printoption{separating/closecuts/recomputerelint}%
{boolean}%
{FALSE}%
{recompute relative interior point in each separation call?}%
{}

\printoption{separating/closecuts/relintnormtype}%
{character}%
{o}%
{type of norm to use when computing relative interior: 'o'ne norm, 's'upremum norm}%
{}

\printoption{separating/closecuts/sepacombvalue}%
{$0\leq\textrm{real}\leq1$}%
{$0.3$}%
{convex combination value for close cuts}%
{}

\printoption{separating/closecuts/separelint}%
{boolean}%
{TRUE}%
{generate close cuts w.r.t. relative interior point (best solution otherwise)?}%
{}

\printoption{separating/cmir/aggrtol}%
{$0\leq\textrm{real}$}%
{$0.1$}%
{tolerance for bound distances used to select continuous variable in current aggregated constraint to be eliminated}%
{}

\printoption{separating/cmir/delay}%
{boolean}%
{FALSE}%
{should separator be delayed, if other separators found cuts?}%
{}

\printoption{separating/cmir/densityoffset}%
{$0\leq\textrm{integer}$}%
{$100$}%
{additional number of variables allowed in row on top of density}%
{}

\printoption{separating/cmir/densityscore}%
{$0\leq\textrm{real}$}%
{$0.0001$}%
{weight of row density in the aggregation scoring of the rows}%
{}

\printoption{separating/cmir/fixintegralrhs}%
{boolean}%
{TRUE}%
{should an additional variable be complemented if f0 = 0?}%
{}

\printoption{separating/cmir/maxaggdensity}%
{$0\leq\textrm{real}\leq1$}%
{$0.2$}%
{maximal density of aggregated row}%
{}

\printoption{separating/cmir/maxaggrs}%
{$0\leq\textrm{integer}$}%
{$3$}%
{maximal number of aggregations for each row per separation round}%
{}

\printoption{separating/cmir/maxaggrsroot}%
{$0\leq\textrm{integer}$}%
{$6$}%
{maximal number of aggregations for each row per separation round in the root node}%
{}

\printoption{separating/cmir/maxbounddist}%
{$0\leq\textrm{real}\leq1$}%
{$0$}%
{maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying separator $<$cmir$>$ (0.0: only on current best node, 1.0: on all nodes)}%
{}

\printoption{separating/cmir/maxconts}%
{$0\leq\textrm{integer}$}%
{$10$}%
{maximal number of active continuous variables in aggregated row}%
{}

\printoption{separating/cmir/maxcontsroot}%
{$0\leq\textrm{integer}$}%
{$10$}%
{maximal number of active continuous variables in aggregated row in the root node}%
{}

\printoption{separating/cmir/maxfails}%
{$-1\leq\textrm{integer}$}%
{$20$}%
{maximal number of consecutive unsuccessful aggregation tries (-1: unlimited)}%
{}

\printoption{separating/cmir/maxfailsroot}%
{$-1\leq\textrm{integer}$}%
{$100$}%
{maximal number of consecutive unsuccessful aggregation tries in the root node (-1: unlimited)}%
{}

\printoption{separating/cmir/maxrowdensity}%
{$0\leq\textrm{real}\leq1$}%
{$0.05$}%
{maximal density of row to be used in aggregation}%
{}

\printoption{separating/cmir/maxrowfac}%
{$0\leq\textrm{real}$}%
{$10000$}%
{maximal row aggregation factor}%
{}

\printoption{separating/cmir/maxslack}%
{$0\leq\textrm{real}$}%
{$0$}%
{maximal slack of rows to be used in aggregation}%
{}

\printoption{separating/cmir/maxslackroot}%
{$0\leq\textrm{real}$}%
{$0.1$}%
{maximal slack of rows to be used in aggregation in the root node}%
{}

\printoption{separating/cmir/maxtestdelta}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal number of different deltas to try (-1: unlimited)}%
{}

\printoption{separating/cmir/maxtries}%
{$-1\leq\textrm{integer}$}%
{$100$}%
{maximal number of rows to start aggregation with per separation round (-1: unlimited)}%
{}

\printoption{separating/cmir/maxtriesroot}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal number of rows to start aggregation with per separation round in the root node (-1: unlimited)}%
{}

\printoption{separating/cmir/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$-3000$}%
{priority of separator $<$cmir$>$}%
{}

\printoption{separating/cmir/slackscore}%
{$0\leq\textrm{real}$}%
{$0.001$}%
{weight of slack in the aggregation scoring of the rows}%
{}

\printoption{separating/cmir/trynegscaling}%
{boolean}%
{TRUE}%
{should negative values also be tested in scaling?}%
{}

\printoption{separating/cutagelimit}%
{$-1\leq\textrm{integer}$}%
{$100$}%
{maximum age a cut can reach before it is deleted from the global cut pool, or -1 to keep all cuts}%
{}

\printoption{separating/efficacynorm}%
{character}%
{e}%
{row norm to use for efficacy calculation ('e'uclidean, 'm'aximum, 's'um, 'd'iscrete)}%
{}

\printoption{separating/flowcover/delay}%
{boolean}%
{FALSE}%
{should separator be delayed, if other separators found cuts?}%
{}

\printoption{separating/flowcover/maxbounddist}%
{$0\leq\textrm{real}\leq1$}%
{$0$}%
{maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying separator $<$flowcover$>$ (0.0: only on current best node, 1.0: on all nodes)}%
{}

\printoption{separating/flowcover/maxfails}%
{$-1\leq\textrm{integer}$}%
{$50$}%
{maximal number of consecutive fails to generate a cut per separation round (-1: unlimited)}%
{}

\printoption{separating/flowcover/maxfailsroot}%
{$-1\leq\textrm{integer}$}%
{$100$}%
{maximal number of consecutive fails to generate a cut per separation round in the root (-1: unlimited)}%
{}

\printoption{separating/flowcover/maxrowdensity}%
{$0\leq\textrm{real}\leq1$}%
{$1$}%
{maximal density of row to separate flow cover cuts for}%
{}

\printoption{separating/flowcover/maxslack}%
{$0\leq\textrm{real}$}%
{$\infty$}%
{maximal slack of rows to separate flow cover cuts for}%
{}

\printoption{separating/flowcover/maxslackroot}%
{$0\leq\textrm{real}$}%
{$\infty$}%
{maximal slack of rows to separate flow cover cuts for in the root}%
{}

\printoption{separating/flowcover/maxtestdelta}%
{$0\leq\textrm{integer}$}%
{$10$}%
{cut generation heuristic: maximal number of different deltas to try}%
{}

\printoption{separating/flowcover/maxtries}%
{$-1\leq\textrm{integer}$}%
{$100$}%
{maximal number of rows to separate flow cover cuts for per separation round (-1: unlimited)}%
{}

\printoption{separating/flowcover/maxtriesroot}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal number of rows to separate flow cover cuts for per separation round in the root (-1: unlimited)}%
{}

\printoption{separating/flowcover/multbyminusone}%
{boolean}%
{TRUE}%
{should flow cover cuts be separated for 0-1 single node flow set with reversed arcs in addition?}%
{}

\printoption{separating/flowcover/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$-4000$}%
{priority of separator $<$flowcover$>$}%
{}

\printoption{separating/flowcover/slackscore}%
{$0\leq\textrm{real}$}%
{$0.001$}%
{weight of slack in the scoring of the rows}%
{}

\printoption{separating/gomory/delay}%
{boolean}%
{FALSE}%
{should separator be delayed, if other separators found cuts?}%
{}

\printoption{separating/gomory/delayedcuts}%
{boolean}%
{TRUE}%
{should cuts be added to the delayed cut pool?}%
{}

\printoption{separating/gomory/forcecuts}%
{boolean}%
{TRUE}%
{if conversion to integral coefficients failed still use the cut}%
{}

\printoption{separating/gomory/makeintegral}%
{boolean}%
{TRUE}%
{try to scale cuts to integral coefficients}%
{}

\printoption{separating/gomory/maxbounddist}%
{$0\leq\textrm{real}\leq1$}%
{$0$}%
{maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying separator $<$gomory$>$ (0.0: only on current best node, 1.0: on all nodes)}%
{}

\printoption{separating/gomory/maxweightrange}%
{$1\leq\textrm{real}$}%
{$10000$}%
{maximal valid range max($|$weights$|$)/min($|$weights$|$) of row weights}%
{}

\printoption{separating/gomory/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$-1000$}%
{priority of separator $<$gomory$>$}%
{}

\printoption{separating/gomory/separaterows}%
{boolean}%
{TRUE}%
{separate rows with integral slack}%
{}

\printoption{separating/impliedbounds/delay}%
{boolean}%
{FALSE}%
{should separator be delayed, if other separators found cuts?}%
{}

\printoption{separating/impliedbounds/maxbounddist}%
{$0\leq\textrm{real}\leq1$}%
{$0$}%
{maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying separator $<$impliedbounds$>$ (0.0: only on current best node, 1.0: on all nodes)}%
{}

\printoption{separating/impliedbounds/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$-50$}%
{priority of separator $<$impliedbounds$>$}%
{}

\printoption{separating/intobj/delay}%
{boolean}%
{FALSE}%
{should separator be delayed, if other separators found cuts?}%
{}

\printoption{separating/intobj/maxbounddist}%
{$0\leq\textrm{real}\leq1$}%
{$0$}%
{maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying separator $<$intobj$>$ (0.0: only on current best node, 1.0: on all nodes)}%
{}

\printoption{separating/intobj/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$-100$}%
{priority of separator $<$intobj$>$}%
{}

\printoption{separating/maxaddrounds}%
{$-1\leq\textrm{integer}$}%
{$1$}%
{maximal additional number of separation rounds in subsequent price-and-cut loops (-1: no additional restriction)}%
{}

\printoption{separating/maxroundsrootsubrun}%
{$-1\leq\textrm{integer}$}%
{$1$}%
{maximal number of separation rounds in the root node of a subsequent run (-1: unlimited)}%
{}

\printoption{separating/maxruns}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal number of runs for which separation is enabled (-1: unlimited)}%
{}

\printoption{separating/mcf/checkcutshoreconnectivity}%
{boolean}%
{TRUE}%
{should we separate only if the cuts shores are connected?}%
{}

\printoption{separating/mcf/delay}%
{boolean}%
{FALSE}%
{should separator be delayed, if other separators found cuts?}%
{}

\printoption{separating/mcf/fixintegralrhs}%
{boolean}%
{TRUE}%
{should an additional variable be complemented if f0 = 0?}%
{}

\printoption{separating/mcf/maxarcinconsistencyratio}%
{$0\leq\textrm{real}$}%
{$0.5$}%
{maximum inconsistency ratio of arcs not to be deleted}%
{}

\printoption{separating/mcf/maxbounddist}%
{$0\leq\textrm{real}\leq1$}%
{$0$}%
{maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying separator $<$mcf$>$ (0.0: only on current best node, 1.0: on all nodes)}%
{}

\printoption{separating/mcf/maxinconsistencyratio}%
{$0\leq\textrm{real}$}%
{$0.02$}%
{maximum inconsistency ratio for separation at all}%
{}

\printoption{separating/mcf/maxtestdelta}%
{$-1\leq\textrm{integer}$}%
{$20$}%
{maximal number of different deltas to try (-1: unlimited)  -- default separation}%
{}

\printoption{separating/mcf/maxweightrange}%
{$1\leq\textrm{real}$}%
{$10^{  6}$}%
{maximal valid range max($|$weights$|$)/min($|$weights$|$) of row weights}%
{}

\printoption{separating/mcf/modeltype}%
{$0\leq\textrm{integer}\leq2$}%
{$0$}%
{model type of network (0: auto, 1:directed, 2:undirected)}%
{}

\printoption{separating/mcf/nclusters}%
{$2\leq\textrm{integer}\leq32$}%
{$5$}%
{number of clusters to generate in the shrunken network -- default separation}%
{}

\printoption{separating/mcf/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$-10000$}%
{priority of separator $<$mcf$>$}%
{}

\printoption{separating/mcf/separateflowcutset}%
{boolean}%
{TRUE}%
{should we separate flowcutset inequalities on the network cuts?}%
{}

\printoption{separating/mcf/separateknapsack}%
{boolean}%
{TRUE}%
{should we separate knapsack cover inequalities on the network cuts?}%
{}

\printoption{separating/mcf/separatesinglenodecuts}%
{boolean}%
{TRUE}%
{should we separate inequalities based on single-node cuts?}%
{}

\printoption{separating/mcf/trynegscaling}%
{boolean}%
{FALSE}%
{should negative values also be tested in scaling?}%
{}

\printoption{separating/objparalfac}%
{$0\leq\textrm{real}$}%
{$0.0001$}%
{factor to scale objective parallelism of cut in separation score calculation}%
{}

\printoption{separating/oddcycle/addselfarcs}%
{boolean}%
{TRUE}%
{add links between a variable and its negated}%
{}

\printoption{separating/oddcycle/allowmultiplecuts}%
{boolean}%
{TRUE}%
{even if a variable is already covered by a cut, still allow another cut to cover it too}%
{}

\printoption{separating/oddcycle/delay}%
{boolean}%
{FALSE}%
{should separator be delayed, if other separators found cuts?}%
{}

\printoption{separating/oddcycle/includetriangles}%
{boolean}%
{TRUE}%
{separate triangles found as 3-cycles or repaired larger cycles}%
{}

\printoption{separating/oddcycle/lpliftcoef}%
{boolean}%
{FALSE}%
{choose lifting candidate by coef*lpvalue or only by coef}%
{}

\printoption{separating/oddcycle/maxbounddist}%
{$0\leq\textrm{real}\leq1$}%
{$1$}%
{maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying separator $<$oddcycle$>$ (0.0: only on current best node, 1.0: on all nodes)}%
{}

\printoption{separating/oddcycle/maxcutslevel}%
{$0\leq\textrm{integer}$}%
{$50$}%
{maximal number of oddcycle cuts generated in every level of the level graph}%
{}

\printoption{separating/oddcycle/maxcutsroot}%
{$0\leq\textrm{integer}$}%
{$1$}%
{maximal number of oddcycle cuts generated per chosen variable as root of the level graph}%
{}

\printoption{separating/oddcycle/maxnlevels}%
{$0\leq\textrm{integer}$}%
{$20$}%
{maximal number of levels in level graph}%
{}

\printoption{separating/oddcycle/maxpernodeslevel}%
{$0\leq\textrm{integer}\leq100$}%
{$100$}%
{percentage of nodes allowed in the same level of the level graph [0-100]}%
{}

\printoption{separating/oddcycle/maxreference}%
{$0\leq\textrm{integer}$}%
{$0$}%
{minimal weight on an edge (in level graph or bipartite graph)}%
{}

\printoption{separating/oddcycle/maxunsucessfull}%
{$0\leq\textrm{integer}$}%
{$3$}%
{number of unsuccessful calls at current node}%
{}

\printoption{separating/oddcycle/multiplecuts}%
{boolean}%
{FALSE}%
{even if a variable is already covered by a cut, still try it as start node for a cycle search}%
{}

\printoption{separating/oddcycle/offsetnodeslevel}%
{$0\leq\textrm{integer}$}%
{$10$}%
{offset of nodes allowed in the same level of the level graph (additional to the percentage of levelnodes)}%
{}

\printoption{separating/oddcycle/offsettestvars}%
{$0\leq\textrm{integer}$}%
{$100$}%
{offset of variables to try the chosen method on (additional to the percentage of testvars)}%
{}

\printoption{separating/oddcycle/percenttestvars}%
{$0\leq\textrm{integer}\leq100$}%
{$0$}%
{percentage of variables to try the chosen method on [0-100]}%
{}

\printoption{separating/oddcycle/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$-15000$}%
{priority of separator $<$oddcycle$>$}%
{}

\printoption{separating/oddcycle/recalcliftcoef}%
{boolean}%
{TRUE}%
{calculate lifting coefficient of every candidate in every step (or only if its chosen)}%
{}

\printoption{separating/oddcycle/repaircycles}%
{boolean}%
{TRUE}%
{try to repair violated cycles with double appearance of a variable}%
{}

\printoption{separating/oddcycle/scalingfactor}%
{$1\leq\textrm{integer}$}%
{$1000$}%
{factor for scaling of the arc-weights}%
{}

\printoption{separating/oddcycle/sortrootneighbors}%
{boolean}%
{TRUE}%
{sort level of the root neighbors by fractionality (maxfrac)}%
{}

\printoption{separating/oddcycle/sortswitch}%
{$0\leq\textrm{integer}\leq4$}%
{$3$}%
{use sorted variable array (unsorted(0),maxlp(1),minlp(2),maxfrac(3),minfrac(4))}%
{}

\printoption{separating/orthofac}%
{$0\leq\textrm{real}$}%
{$1$}%
{factor to scale orthogonality of cut in separation score calculation (0.0 to disable orthogonality calculation)}%
{}

\printoption{separating/orthofunc}%
{character}%
{e}%
{function used for calc. scalar prod. in orthogonality test ('e'uclidean, 'd'iscrete)}%
{}

\printoption{separating/rapidlearning/applybdchgs}%
{boolean}%
{TRUE}%
{should the found global bound deductions be applied in the original SCIP?}%
{}

\printoption{separating/rapidlearning/applyconflicts}%
{boolean}%
{TRUE}%
{should the found conflicts be applied in the original SCIP?}%
{}

\printoption{separating/rapidlearning/applyinfervals}%
{boolean}%
{TRUE}%
{should the inference values be used as initialization in the original SCIP?}%
{}

\printoption{separating/rapidlearning/applyprimalsol}%
{boolean}%
{TRUE}%
{should the incumbent solution be copied to the original SCIP?}%
{}

\printoption{separating/rapidlearning/applysolved}%
{boolean}%
{TRUE}%
{should a solved status be copied to the original SCIP?}%
{}

\printoption{separating/rapidlearning/contvars}%
{boolean}%
{FALSE}%
{should rapid learning be applied when there are continuous variables?}%
{}

\printoption{separating/rapidlearning/contvarsquot}%
{$0\leq\textrm{real}\leq1$}%
{$0.3$}%
{maximal portion of continuous variables to apply rapid learning}%
{}

\printoption{separating/rapidlearning/copycuts}%
{boolean}%
{TRUE}%
{should all active cuts from cutpool be copied to constraints in subproblem?}%
{}

\printoption{separating/rapidlearning/delay}%
{boolean}%
{FALSE}%
{should separator be delayed, if other separators found cuts?}%
{}

\printoption{separating/rapidlearning/lpiterquot}%
{$0\leq\textrm{real}$}%
{$0.2$}%
{maximal fraction of LP iterations compared to node LP iterations}%
{}

\printoption{separating/rapidlearning/maxbounddist}%
{$0\leq\textrm{real}\leq1$}%
{$1$}%
{maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying separator $<$rapidlearning$>$ (0.0: only on current best node, 1.0: on all nodes)}%
{}

\printoption{separating/rapidlearning/maxnconss}%
{$0\leq\textrm{integer}$}%
{$10000$}%
{maximum problem size (constraints) for which rapid learning will be called}%
{}

\printoption{separating/rapidlearning/maxnodes}%
{$0\leq\textrm{integer}$}%
{$5000$}%
{maximum number of nodes considered in rapid learning run}%
{}

\printoption{separating/rapidlearning/maxnvars}%
{$0\leq\textrm{integer}$}%
{$10000$}%
{maximum problem size (variables) for which rapid learning will be called}%
{}

\printoption{separating/rapidlearning/minnodes}%
{$0\leq\textrm{integer}$}%
{$500$}%
{minimum number of nodes considered in rapid learning run}%
{}

\printoption{separating/rapidlearning/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$-1200000$}%
{priority of separator $<$rapidlearning$>$}%
{}

\printoption{separating/rapidlearning/reducedinfer}%
{boolean}%
{FALSE}%
{should the inference values only be used when rapidlearning found other reductions?}%
{}

\printoption{separating/strongcg/delay}%
{boolean}%
{FALSE}%
{should separator be delayed, if other separators found cuts?}%
{}

\printoption{separating/strongcg/maxbounddist}%
{$0\leq\textrm{real}\leq1$}%
{$0$}%
{maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying separator $<$strongcg$>$ (0.0: only on current best node, 1.0: on all nodes)}%
{}

\printoption{separating/strongcg/maxweightrange}%
{$1\leq\textrm{real}$}%
{$10000$}%
{maximal valid range max($|$weights$|$)/min($|$weights$|$) of row weights}%
{}

\printoption{separating/strongcg/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$-2000$}%
{priority of separator $<$strongcg$>$}%
{}

\printoption{separating/zerohalf/delay}%
{boolean}%
{FALSE}%
{should separator be delayed, if other separators found cuts?}%
{}

\printoption{separating/zerohalf/ignoreprevzhcuts}%
{boolean}%
{FALSE}%
{should zerohalf cuts found in previous callbacks ignored?}%
{}

\printoption{separating/zerohalf/maxbounddist}%
{$0\leq\textrm{real}\leq1$}%
{$0$}%
{maximal relative distance from current node's dual bound to primal bound compared to best node's dual bound for applying separator $<$zerohalf$>$ (0.0: only on current best node, 1.0: on all nodes)}%
{}

\printoption{separating/zerohalf/maxcutsfound}%
{$0\leq\textrm{integer}$}%
{$100$}%
{maximal number of {0,1/2}-cuts determined per separation round\\   \#                      (this includes separated but inefficacious cuts)}%
{}

\printoption{separating/zerohalf/maxcutsfoundroot}%
{$0\leq\textrm{integer}$}%
{$1000$}%
{maximal number of {0,1/2}-cuts determined per separation round in the root node\\   \#                      (this includes separated but inefficacious cuts)}%
{}

\printoption{separating/zerohalf/maxdepth}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{separating cuts only if depth $<$= maxdepth (-1: unlimited)}%
{}

\printoption{separating/zerohalf/maxncalls}%
{$-1\leq\textrm{integer}$}%
{$-1$}%
{maximal number of calls (-1: unlimited)}%
{}

\printoption{separating/zerohalf/maxtestdelta}%
{$-1\leq\textrm{integer}$}%
{$10$}%
{maximal number of different deltas to try for cmir (-1: unlimited, 0: delta=1)}%
{}

\printoption{separating/zerohalf/onlyorigrows}%
{boolean}%
{FALSE}%
{should only original LP rows be considered (i.e. ignore previously added LP rows)?}%
{}

\printoption{separating/zerohalf/priority}%
{$-536870912\leq\textrm{integer}\leq536870911$}%
{$-6000$}%
{priority of separator $<$zerohalf$>$}%
{}

\printoption{separating/zerohalf/relaxcontvars}%
{boolean}%
{FALSE}%
{should continuous variables be relaxed by adding variable bounds?}%
{}

\printoption{separating/zerohalf/scalefraccoeffs}%
{boolean}%
{TRUE}%
{should rows be scaled to make fractional coefficients integer?}%
{}

\printoption{separating/zerohalf/trynegscaling}%
{boolean}%
{TRUE}%
{should negative values also be tested in scaling for cmir?}%
{}

\printoption{separating/zerohalf/usezhcutpool}%
{boolean}%
{TRUE}%
{should zerohalf cuts be filtered using a cutpool?}%
{}

\printoptioncategory{Timing}
\printoption{timing/clocktype}%
{$1\leq\textrm{integer}\leq2$}%
{$1$}%
{default clock type (1: CPU user seconds, 2: wall clock time)}%
{}

\printoption{timing/enabled}%
{boolean}%
{TRUE}%
{is timing enabled?}%
{}

\printoption{timing/reading}%
{boolean}%
{FALSE}%
{belongs reading time to solving time?}%
{}

