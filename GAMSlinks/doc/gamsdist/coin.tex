%%%
%%% tabular with the option-table header
%%%
\renewenvironment{option_tabular}%
{\begin{tabular}{p{.16\textwidth}p{.65\textwidth}p{.11\textwidth}}
\hline
\textbf{Option}      &
\textbf{Description} &
\textbf{Default}     \\
\hline}
{\end{tabular}}

%%%
%%% list to use inside a tabular cell
%%%
\renewenvironment{tab_list}[1]%
{\begin{list}{}{\vspace*{-1.5ex}\renewcommand{\makelabel}{\desclabel}\parsep-0.15cm\labelwidth#1\leftmargin#1\setlength{\labelsep}{\itemindent}\topsep0cm\parskip0cm\partopsep0cm}}%
{\end{list}}


\chapter{COIN-OR}
\textbf{Stefan Vigerske, Humboldt University Berlin, Germany}
\vspace{1cm}

\minitoc


\section{Introduction}

COIN-OR (\textbf{CO}mputational \textbf{IN}frastructure for \textbf{O}perations \textbf{R}esearch, \texttt{http://www.coin-or.org}) is an initiative to spur the development of open-source software for the operations research community.
One of the projects hosted at COIN-OR is the GAMSlinks project (\texttt{https://projects.coin-or.org/GAMSlinks}).
It is dedicated to the development of interfaces between GAMS and open source solvers.
Some of these links and solvers have also found their way into the regular GAMS distribution.
They are currently available for Linux (32 and 64 bit), Windows (32 and 64 bit), Sun Solaris (Intel 64 bit), and Darwin (Intel 32 bit) systems.
With the availability of source code for the GAMSlinks the user is not limited to the out of the box solvers that come with a regular GAMS distribution, but can extend and build these interfaces by themselves.

As of GAMS Distribution 22.7, available solvers include:
\begin{itemize}
\item CoinBonmin 0.9: Basic Open-source Nonlinear Mixed Integer programming\\
(model types: LP, RMIP, MIP, DNLP, NLP, RMINLP, MINLP, QCP, RMIQCP, MIQCP)
\item CoinCbc 2.0: COIN-OR Branch and Cut\\
(model types: LP, MIP, RMIP)
\item CoinGlpk 4.26: Gnu Linear Programming Kit\\
(model types: LP, MIP, RMIP)
\item CoinIpopt 3.4: Interior Point Optimizer\\
(model types: LP, RMIP, DNLP, NLP, RMINLP, QCP, RMIQCP)
\item CoinScip 1.00: Solving Constrained Integer Programs\\
(model types: LP, MIP, RMIP)
\end{itemize}

% The open source concept opens new possibilities for our advanced users:
% 
% \begin{itemize}
% \item Make modifications to the existing links
% \item Port the links to another platform supported by GAMS
% \item Connect new solvers to GAMS/COIN-OR
% \item Extend the documentation
% \end{itemize}

For more information see the COIN-OR/GAMSlinks web site at
\texttt{https://projects.coin-or.org/GAMSlinks}.

\section{CoinBonmin}

GAMS/CoinBonmin brings the open source MINLP solver Bonmin from the COIN-OR foundation to the broad audience of GAMS users.

Bonmin (\textbf{B}asic \textbf{O}pen-source \textbf{N}onlinear \textbf{M}ixed \textbf{In}teger programming) 0.9 is an open-source solver for mixed-integer nonlinear programming (MINLPs), whereof some parts are still experimental.
The code is developed in a joined project of IBM and the Carnegie Mellon University.
The COIN-OR project leader for Bonmin is Pierre Bonami.

Bonmin implements five different algorithms:
\begin{itemize}
\item {B-BB}: a simple branch-and-bound algorithm based on solving a continuous nonlinear program at each node of the search tree and branching on variables (default)
\item {B-OA}: an outer-approximation based decomposition algorithm
\item {B-QG}: an outer-approximation based branch-and-cut algorithm (by Queseda and Grossmann)
\item {B-Hyb}: a hybrid outer-approximation/nonlinear programming based branch-and-cut algorithm
\item {B-Ecp}: an ECP cuts based branch-and-cut algorithm a la FilMINT
\end{itemize}
The algorithms are exact when the problem is convex, otherwise they are heuristics.

For convex MINLPs, experiments on a reasonably large test set of problems have shown that B-Hyp is the algorithm of choice (it solved most of the problems in 3 hours of computing time).
Nevertheless, there are cases where B-OA is much faster than B-Hyb and others where B-BB is interesting.
B-QG corresponds mainly to a specific parameter setting of B-Hyb where some features are disabled.
B-Ecp has just been added to Bonmin and is still experimental.
For nonconvex MINLPs, it is strongly recommend to use B-BB, even though it is only a heuristic for such problems too.
% Therefore, it is the default algorithm in Bonmin.

For more information we refer to
\begin{itemize}
\item the Bonmin web site \texttt{https://projects.coin-or.org/Bonmin} and
\item the paper P. Bonami, L.T. Biegler, A.R. Conn, G. Cornuejols, I.E. Grossmann, C.D. Laird, J. Lee, A. Lodi, F. Margot, N.Sawaya and A. W\"achter, An Algorithmic Framework for Convex Mixed Integer Nonlinear Programs, \emph{IBM Research Report} RC23771, Oct. 2005.
\end{itemize}
Most of the Bonmin documentation in the section is taken from the Bonmin manual available on the Bonmin web site.

\subsection{Model requirements}

Bonmin can handle mixed-integer nonlinear programming models which functions can be nonconvex, but should be twice continuously differentiable.
The Bonmin link in GAMS supports continuous, binary, and integer variables, special ordered sets, branching priorities, but no semi-continuous or semi-integer variables (see chapter 17.1 of the GAMS User's Guide).

If GAMS/CoinBonmin is called for a model with only continuous variables, the interface directly calls Ipopt.

\subsection{Usage of CoinBonmin}

The following statement can be used inside your GAMS program to specify using CoinBonmin
\begin{verbatim}
  Option MINLP = CoinBonmin;     { or LP, RMIP, MIP, DNLP, NLP, RMINLP, QCP, RMIQCP, MIQCP }
\end{verbatim}

The above statement should appear before the Solve statement.
If CoinBonmin was specified as the default solver during GAMS installation, the above statement is not necessary.

\subsection{Specification of CoinBonmin Options}
\label{sub:bonminoptionspec}

A Bonmin option file contains both Ipopt and Bonmin options, for clarity all Bonmin options should be preceded with the prefix ``\texttt{bonmin.}''.
%Bonmin has many options that can be adjusted for the algorithm (see Section \ref{sub:bonminoptions}).
The scheme to name option files is the same as for all other GAMS solvers.
Specifying \texttt{optfile=1} let Gams/CoinBonmin read \texttt{coinbonmin.opt}, \texttt{optfile=2} corresponds to \texttt{coinbonmin.op2}, and so on.
The format of the option file is the same as for Ipopt (see Section \ref{sub:ipoptoptionspec}).

The most important option in Bonmin is the choice of the solution algorithm.
This can be set by using the option named \texttt{bonmin.algorithm} which can be set to \texttt{B-BB}, \texttt{B-OA}, \texttt{B-QG}, \texttt{B-Hyb}, or \texttt{B-Ecp} (its default value is \texttt{B-BB}).
Depending on the value of this option, certain other options may be available or not.

In the context of outer approximation decomposition, several options are available for configuring the MIP subsolver CBC.
By setting the option \texttt{bonmin.milp\_subsolver} to \texttt{Cbc\_Par}, a version of CBC is chosen that can be parameterized by the user.
The options that can be set are the node-selection strategy, the number of strong-branching candidates, the number of branches before pseudo costs are to be trusted, and the frequency of some cut generators.
Their name coincide with Bonmins options, except that the ``\texttt{bonmin.}'' prefix is replaced with  ``\texttt{milp\_sub.}''.

An example of a \texttt{bonmin.opt} file is the following:
\begin{verbatim}
   bonmin.algorithm B-Hyb
   bonmin.oa_log_level 4
   bonmin.milp_subsolver Cbc_Par
   milp_sub.cover_cuts 0
   print_level 6
\end{verbatim}
This sets the algorithm to be used to the hybrid algorithm, the level of outer approximation related output to $4$, the print level for \texttt{Ipopt} to $6$, the MIP subsolver for outer approximation to a parameterized version of CBC, and switches off cover cutting planes for the MIP subsolver.

GAMS/CoinBonmin understands currently the following GAMS parameters: reslim (time limit), iterlim (iteration limit), nodlim (node limit), cutoff, optca (absolute gap tolerance), and optcr (relative gap tolerance).
You can set them either on the command line, e.g. \verb+nodlim=1000+, or inside your GAMS program, e.g. \verb+Option nodlim=1000;+.

\subsection{Description of CoinBonmin Options}
\label{sub:bonminoptions}

The following tables gives the list of options together with their types, default values and availability in each of the four main algorithms.
The column labeled `type' indicates the type of the parameter (`F' stands for float, `I' for integer, and `S' for
string).
The column labeled `default' indicates the global default value.
Then for each of the four algorithm \texttt{B-BB}, \texttt{B-OA}, \texttt{B-QG}, and \texttt{B-Hyb}, `$+$' indicates that the option is available for that particular algorithm while `$-$' indicates that it is not.
Options that are marked with $^*$ are those that can be used to configure the MIP subsolver.

\begin{center}
\begin{tabular}{|l|r|r|r|r|r|r|}\hline
Option & type &  default & {\tt B-BB} & {\tt B-OA} & {\tt B-QG} & {\tt B-Hyb} \\
\hline
\hline
\multicolumn{1}{|c}{} & \multicolumn{6}{l|}{Algorithm choice}\\
\hline
algorithm& S& B-BB& +& +& +& +\\
\hline
\multicolumn{1}{|c}{} & \multicolumn{6}{l|}{Branch-and-bound}\\
\hline
allowable\_fraction\_gap& F& optrc (0.1)& +& +& +& +\\
allowable\_gap& F& optca (0)& +& +& +& +\\
cutoff& F& cutoff or $10^{100}$& +& +& +& +\\
cutoff\_decr& F& $10^{-5}$& +& +& +& +\\
integer\_tolerance& F& $10^{-6}$& +& +& +& +\\
iteration\_limit& I& $\infty$& +& +& +& +\\
nlp\_failure\_behavior& S& stop& +& +& +& +\\
node\_comparison$^*$& S& dynamic& +& +& +& +\\
node\_limit& I& nodlim or iterlim (10000)& +& +& +& +\\
num\_cut\_passes& I& 1& --& +& +& +\\
num\_cut\_passes\_at\_root& I& 20& --& +& +& +\\
number\_before\_trust$^*$& I& 8& +& +& +& +\\
number\_strong\_branch$^*$& I& 20& +& +& +& +\\
solution\_limit& I& $\infty$& +& +& +& +\\
% sos\_constraints& S& enable& +& --& +& +\\
time\_limit& F& reslim (1000)& +& +& +& +\\
tree\_search\_strategy& S& top\-node& +& +& +& +\\
varselect\_stra& S& strong\-branching& +& +& +& +\\
\hline
\multicolumn{1}{|c}{} & \multicolumn{6}{l|}{Outer Approximation decomposition}\\
\hline
milp\_subsolver& S& Cbc\_D& --& +& --& +\\
oa\_dec\_time\_limit& F& 30& +& +& +& +\\
\hline
\multicolumn{1}{|c}{} & \multicolumn{6}{l|}{Outer Approximation cuts}\\
\hline
add\_only\_violated\_oa& S& no& --& +& +& +\\
cut\_strengthening\_type& S& none& --& +& +& +\\
disjunctive\_cut\_type& S& none& --& +& +& +\\
oa\_cuts\_scope& S& global& --& +& +& +\\
tiny\_element& F& $10^{-8}$& --& +& +& +\\
very\_tiny\_element& F& $10^{-7}$& --& +& +& +\\
\hline
\multicolumn{1}{|c}{} & \multicolumn{6}{l|}{Ecp based strong branching}\\
\hline
ecp\_abs\_tol& F& $10^{-6}$& --& --& --& +\\
ecp\_abs\_tol\_strong& F& $10^{-6}$& +& +& +& +\\
ecp\_max\_rounds& I& 5& --& --& --& +\\
ecp\_max\_rounds\_strong& I& 5& +& +& +& +\\
ecp\_propability\_factor& F& 1000& --& --& --& +\\
ecp\_rel\_tol& F& 0& --& --& --& +\\
ecp\_rel\_tol\_strong& F& 0.1& +& +& +& +\\
filmint\_ecp\_cuts& I& 0& --& --& --& +\\
\hline
\multicolumn{1}{|c}{} & \multicolumn{6}{l|}{Output}\\
\hline
bb\_log\_interval& I& 100& +& --& +& +\\
bb\_log\_level& I& 1& +& --& +& +\\
lp\_log\_level& I& 0& --& --& +& +\\
milp\_log\_level& I& 0& --& +& --& +\\
nlp\_log\_level& I& 1& +& +& +& +\\
oa\_cuts\_log\_level& I& 0& --& +& +& +\\
oa\_log\_frequency& F& 100& +& +& +& +\\
oa\_log\_level& I& 1& +& +& +& +\\
\hline
\end{tabular}

\begin{tabular}{|l|r|r|r|r|r|r|}\hline
Option & type &  default & {\tt B-BB} & {\tt B-OA} & {\tt B-QG} & {\tt B-Hyb} \\
\hline
\hline
\multicolumn{1}{|c}{} & \multicolumn{6}{l|}{NLP interface}\\
\hline
nlp\_solve\_frequency& I& 10& --& --& --& +\\
nlp\_solve\_max\_depth& I& 10& --& --& --& +\\
% file\_solution& S& no& +& +& +& +\\
% nlp\_solver& S& Ipopt& +& +& +& +\\
warm\_start& S& none& +& --& --& --\\
\hline
\multicolumn{1}{|c}{} & \multicolumn{6}{l|}{MIP cutting planes}\\
\hline
2mir\_cuts& I& 0& --& +& --& +\\
Gomory\_cuts$^*$& I& \-5& --& +& --& +\\
clique\_cuts& I& \-5& --& +& --& +\\
cover\_cuts$^*$& I& \-5& --& +& --& +\\
flow\_covers\_cuts& I& \-5& --& +& --& +\\
lift\_and\_project\_cuts& I& 0& --& +& --& +\\
mir\_cuts$^*$& I& \-5& --& +& --& +\\
probing\_cuts& I& \-5& --& +& --& +\\
reduce\_and\_split\_cuts& I& 0& --& +& --& +\\
\hline
\multicolumn{1}{|c}{} & \multicolumn{6}{l|}{Options for non-convex problems}\\
\hline
max\_consecutive\_infeasible& I& 0& +& +& +& +\\
num\_resolve\_at\_infeasibles& I& 0& +& --& --& --\\
num\_resolve\_at\_node& I& 0& +& --& --& --\\
num\_resolve\_at\_root& I& 0& +& --& --& --\\
\hline
\multicolumn{1}{|c}{} & \multicolumn{6}{l|}{Robustness}\\
\hline
max\_consecutive\_failures& I& 10& +& +& +& +\\
max\_random\_point\_radius& F& 100000& +& --& --& --\\
num\_iterations\_suspect& I& \-1& +& +& +& +\\
num\_retry\_unsolved\_random\_point& I& 0& +& +& +& +\\
random\_point\_perturbation\_interval& F& 1& +& --& --& --\\
random\_point\_type& S& Jon& +& --& --& --\\
\hline
\multicolumn{1}{|c}{} & \multicolumn{6}{l|}{Diving}\\
\hline
max\_backtracks\_in\_dive& I& 5& +& +& +& +\\
max\_dive\_depth& I& $\infty$& +& +& +& +\\
stop\_diving\_on\_cutoff& S& no& +& +& +& +\\
\hline
\multicolumn{1}{|c}{} & \multicolumn{6}{l|}{Experimental options}\\
\hline
maxmin\_crit\_have\_sol& F& 0.1& +& +& +& +\\
maxmin\_crit\_no\_sol& F& 0.7& +& +& +& +\\
number\_before\_trust\_list& I& 0& +& +& +& +\\
number\_strong\_branch\_root& I& $\infty$& +& +& +& +\\
setup\_pseudo\_frac& F& 0.5& +& +& +& +\\
\hline
\end{tabular}
\end{center}

\input{optbonmin_a}

\subsubsection{Ipopt}
All Ipopt options are available in CoinBonmin, please refer to section \ref{sub:ipoptoptions} for a detailed description.
The default value of the following Ipopt parameters are changed in Gams/CoinBonmin:
\begin{itemize}
\item \texttt{mu\_strategy} and \texttt{mu\_oracle} are set, respectively, to {\tt adaptive} and {\tt probing} by default.
\item \texttt{gamma\_phi} and \texttt{gamma\_theta} are set to $10^{-8}$ and $10^{-4}$ respectively. This has the effect of reducing the size of the filter in the line search performed by Ipopt.
\item \texttt{required\_infeasibility\_reduction} is set to $0.1$.
This increases the required infeasibility reduction when Ipopt enters the restoration phase and should thus help
detect infeasible problems faster.
\item \texttt{expect\_infeasible\_problem} is set to {\tt yes} which enables some heuristics to detect infeasible problems faster.
\item \texttt{warm\_start\_init\_point} is set to {\tt yes} when a full primal/dual starting point is available (generally for all the optimizations after the continuous relaxation has been solved).
\item \texttt{print\_level} is set to $0$ by default to turn off Ipopt output.
\item \texttt{bound\_relax\_factor} is set to $0.0$.
\end{itemize}

\section{CoinCbc}
\label{sec:coincbc}
\hypertarget{sec:coincbc}{}

GAMS/CoinCBC brings the open source LP/MIP solver CBC from the COIN-OR foundation to the broad audience of GAMS users.

CBC (COIN-OR Branch and Cut) is an open-source mixed integer programming solver working with the COIN-OR LP solver CLP and the COIN-OR Cut generator library Cgl.
The code has been written primarily by John J. Forrest, who is the COIN-OR project leader for Cbc.

For more information we refer to
\begin{itemize}
\item the CBC web site \texttt{https://projects.coin-or.org/Cbc},
\item the Cgl web site \texttt{https://projects.coin-or.org/Cgl}, and
\item the CLP web site \texttt{https://projects.coin-or.org/Clp}.
\end{itemize}
Most of the CBC documentation in the section was copied from the help in the CBC standalone version.

\subsection{Model requirements}

The CBC link in GAMS supports continuous, binary, integer, semicontinuous, semiinteger variables, special ordered sets of type 1 and 2, and branching priorities (see chapter 17.1 of the GAMS User's Guide).
% Quadratic objective functions are not supported yet.

\subsection{Usage of CoinCbc}

The following statement can be used inside your GAMS program to specify using CoinCBC
\begin{verbatim}
  Option LP = CoinCbc;     { or MIP or RMIP }
\end{verbatim}

The above statement should appear before the Solve statement.
If CoinCBC was specified as the default solver during GAMS installation, the above statement is not necessary.

There are many parameters which can affect the performance the CBCs Branch and Cut Algorithm.
First just try with default settings and look carefully at the log file.
Did cuts help? Did they take too long? Look at the output to see which cuts were effective and then do some tuning (see the option \hyperlink{cuts}{cuts}).
If the \hyperlink{preprocess}{preprocessing} reduced the size of the problem or strengthened many coefficients then it is probably wise to leave it on.
Switch off \hyperlink{heuristics}{heuristics} which did not provide solutions.
The other major area to look at is the search. Hopefully good solutions were obtained fairly early in the search so the important point is to select the best variable to branch on.
See whether strong branching did a good job - or did it just take a lot of iterations.
Adjust the options \hyperlink{strongbranching}{strongbranching} and \hyperlink{trustpseudocosts}{trustpseudocosts}.

The GAMS/CoinCBC options file consists of one option or comment per line.
An asterisk (*) at the beginning of a line causes the entire line to be ignored.
Otherwise, the line will be interpreted as an option name and value separated by any amount of white space (blanks or tabs).
Following is an example options file coincbc.opt.
\begin{verbatim}
  cuts root
  perturbation off
\end{verbatim}
It will cause CoinCBC to use cut generators only in the root node and turns off the perturbation of the LP relaxation.

GAMS/CoinCBC now support the GAMS Branch-and-Cut-and-Heuristic (BCH) Facility.
The GAMS BCH facility automates all major steps necessary to define, execute, and control the use of user defined routines within the framework of general purpose MIP codes.
Currently supported are user defined cut generators and heuristics.
Please see the BCH documentation at \texttt{http://www.gams.com/docs/bch.htm} for further information.

% \subsection{CoinCbc output}
% \subsection{Some CoinCbc features}

\input{optcbc_s}
\input{optcbc_a}



\section{CoinGlpk}

GAMS/CoinGlpk brings the open source LP/MIP solver Glpk from the GNU Open Software foundation to the broad audience of GAMS users.

The code has been written primarily by A. Makhorin.
The interface uses the OSI Glpk interface written by Vivian De Smedt, Braden Hunsaker, and Lou Hafer.

For more information we refer to
\begin{itemize}
\item the Glpk web site \texttt{http://www.gnu.org/software/glpk/glpk.html} and
\item the Osi web site \texttt{https://projects.coin-or.org/Osi}.
\end{itemize}
Most of the Glpk documentation in the section was taken from the Glpk manual.

\subsection{Model requirements}

Glpk supports continuous, binary, and integer variables, but no special ordered sets, semi-continuous or semi-integer variables (see chapter 17.1 of the GAMS User's Guide).
Also branching priorities are not supported.

\subsection{Usage of CoinGlpk}

The following statement can be used inside your GAMS program to specify using CoinGlpk
\begin{verbatim}
  Option LP = CoinGlpk;     { or MIP or RMIP }
\end{verbatim}

The above statement should appear before the Solve statement.
If CoinGlpk was specified as the default solver during GAMS installation, the above statement is not necessary.

The GAMS/CoinGlpk options file consists of one option or comment per line.
An asterisk (*) at the beginning of a line causes the entire line to be ignored.
Otherwise, the line will be interpreted as an option name and value separated by any amount of white space (blanks or tabs).
Following is an example options file coincbc.opt.
\begin{verbatim}
  factorization givens
  initbasis standard
\end{verbatim}
It will cause CoinGlpk to use Givens rotation updates for the factorization and to use a standard initial basis. (This option setting might help to avoid numerical difficulties in some cases.)

\input{optglpk_s}
\input{optglpk_a}



\section{CoinIpopt}

GAMS/CoinIpopt brings the open source NLP solver Ipopt from the COIN-OR foundation to the broad audience of GAMS users.

Ipopt (\textbf{I}nterior \textbf{P}oint \textbf{Opt}imizer) is an open-source solver for large-scale nonlinear programming.
The code has been written primarily by Andreas W\"achter, who is the COIN-OR project leader for Ipopt.

For more information we refer to
\begin{itemize}
\item the Ipopt web site \texttt{https://projects.coin-or.org/Ipopt} and
\item the \emph{implementation paper} A. W\"achter and L. T. Biegler, On the Implementation of a Primal-Dual Interior Point Filter Line Search Algorithm for Large-Scale Nonlinear Programming, \emph{Mathematical Programming} 106(1), pp. 25-57, 2006.
\end{itemize}
Most of the Ipopt documentation in the section was taken from the Ipopt manual available on the Ipopt web site.

\subsection{Model requirements}

Ipopt can handle nonlinear programming models which functions can be nonconvex, but should be twice continuously differentiable.
GAMS/CoinIpopt now supports user-defined scalings of variables and equations using the .scale suffix and scaleopt option (see chapter 17.2 of the GAMS User's Guide).

\subsection{Usage of CoinIpopt}

The following statement can be used inside your GAMS program to specify using CoinIpopt
\begin{verbatim}
  Option NLP = CoinIpopt;     { or LP, RMIP, DNLP, RMINLP, QCP, RMIQCP }
\end{verbatim}

The above statement should appear before the Solve statement.
If CoinIpopt was specified as the default solver during GAMS installation, the above statement is not necessary.

\subsection{The linear solver in Ipopt}
\label{ipoptlinearsolver}
\hypertarget{ipoptlinearsolver}{}

The performance and robustness of Ipopt on larger models heavily relies on the used solver for sparse symmetric indefinite linear systems.
GAMS/CoinIpopt includes the multifrontal massively parallel sparse direct solver MUMPS (\texttt{http://graal.ens-lyon.fr/MUMPS}).
The user can provide the Parallel Sparse Direct Solver PARDISO or routines from the Harwell Subroutine Library (HSL) as shared (or dynamic) libraries to replace MUMPS.

\subsubsection{Using Harwell Subroutine Library routines with GAMS/CoinIpopt}

If you have routines from the HSL available and want Gams/CoinIpopt to use them, you can provide them in a shared library.
GAMS/CoinIpopt can use MA27, MA28, MA57, and MC19.
By telling Ipopt to use one of these routines (see options linear\_solver, linear\_system\_scaling, nlp\_scaling\_method, dependency\_detector) GAMS/CoinIpopt attempts to load the required routines from the library libhsl.so (Unix-Systems), libhsl.dylib (MacOS X), or libhsl.dll (Windows).
You can also specify the path and name for this library with the option hsl\_library.

For example,
\begin{verbatim}
 linear_solver ma27
 hsl_library /my/path/to/the/hsllib/myhsllib.so
\end{verbatim}
tells Ipopt to use the linear solver MA27 from the HSL library \verb=myhsllib.so= under the specified path.

The HSL routines MA27, MA28, and MC19 are available at \texttt{http://www.cse.clrc.ac.uk/nag/hsl}.
Note that it is your responsibility to ensure that you are entitled to download and use these routines!
You can build a shared library using the ThirdParty/HSL project at COIN-OR.

\subsubsection{Using PARDISO routines with GAMS/CoinIpopt}

If you have the linear solver PARDISO available, then you can tell Gams/CoinIpopt to use by setting the linear\_solver option to pardiso.
GAMS/CoinIpopt then attempts to load the library libpardiso.so (Unix-Systems), libpardiso.dylib (MacOS X), or libpardiso.dll (Windows).
You can also specify the path and name for this library with the option pardiso\_library.

For example,
\begin{verbatim}
 linear_solver pardiso
 pardiso_library /my/path/to/the/pardisolib/mypardisolib.so
\end{verbatim}
tells Ipopt to use the linear solver PARDISO from the library \verb=mypardisolib.so= under the specified path.

PARDISO is available as compiled shared library for several platforms at \texttt{http://www.pardiso-project.org}.
Note that it is your responsibility to ensure that you are entitled to download and use this package!

\subsection{Output}

This section describes the standard Ipopt console output.
The output is designed to provide a quick summary of each iteration as Ipopt solves the problem.

Before Ipopt starts to solve the problem, it displays the problem statistics (number of nonzero-elements in the matrices, number of variables, etc.).
Note that if you have fixed variables (both upper and lower bounds are equal), Ipopt may remove these variables from the problem internally and not include them in the problem statistics.

Following the problem statistics, Ipopt will begin to solve the problem and you will see output resembling the following,
\begin{verbatim}
iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
   0  1.6109693e+01 1.12e+01 5.28e-01   0.0 0.00e+00    -  0.00e+00 0.00e+00   0
   1  1.8029749e+01 9.90e-01 6.62e+01   0.1 2.05e+00    -  2.14e-01 1.00e+00f  1
   2  1.8719906e+01 1.25e-02 9.04e+00  -2.2 5.94e-02   2.0 8.04e-01 1.00e+00h  1
\end{verbatim}
and the columns of output are defined as
\begin{description}
\item[iter]
The current iteration count.
This includes regular iterations and iterations while in restoration phase.
If the algorithm is in the restoration phase, the letter r' will be appended to the iteration number.
\item[objective]
The unscaled objective value at the current point.
During the restoration phase, this value remains the unscaled objective value for the original problem.
\item[inf\_pr]
The scaled primal infeasibility at the current point.
During the restoration phase, this value is the primal infeasibility of the original problem at the current point.
\item[inf\_du]
The scaled dual infeasibility at the current point.
During the restoration phase, this is the value of the dual infeasibility for the restoration phase problem.
\item[lg(mu)]
$\log_{10}$ of the value of the barrier parameter mu.
\item[$\Vert d\Vert$]
The infinity norm (max) of the primal step (for the original variables $x$ and the internal slack variables $s$).
During the restoration phase, this value includes the values of additional variables, $p$ and $n$.
\item[lg(rg)]
$\log_{10}$ of the value of the regularization term for the Hessian of the Lagrangian in the augmented system.
\item[alpha\_du]
The stepsize for the dual variables.
\item[alpha\_pr]
The stepsize for the primal variables.
\item[ls]
The number of backtracking line search steps.
\end{description}

When the algorithm terminates, IPOPT will output a message to the screen based on the return status of the call to Optimize.
The following is a list of the possible output messages to the console, and a brief description.

\begin{description}
\item[Optimal Solution Found.] ~

    This message indicates that IPOPT found a (locally) optimal point within the desired tolerances.

\item[Solved To Acceptable Level.] ~

    This indicates that the algorithm did not converge to the ``desired'' tolerances, but that it was able to obtain a point satisfying the ``acceptable'' tolerance level as specified by acceptable-* options.
    This may happen if the desired tolerances are too small for the current problem.

\item[Converged to a point of local infeasibility. Problem may be infeasible.] ~

    The restoration phase converged to a point that is a minimizer for the constraint violation (in the $\ell_1$-norm), but is not feasible for the original problem.
    This indicates that the problem may be infeasible (or at least that the algorithm is stuck at a locally infeasible point).
    The returned point (the minimizer of the constraint violation) might help you to find which constraint is causing the problem.
    If you believe that the NLP is feasible, it might help to start the optimization from a different point.

\item[Search Direction is becoming Too Small.] ~

    This indicates that Ipopt is calculating very small step sizes and making very little progress.
    This could happen if the problem has been solved to the best numerical accuracy possible given the current scaling.

\item[Iterates divering; problem might be unbounded.] ~

    This message is printed if the max-norm of the iterates becomes larger than the value of the option diverging\_iterates\_tol.
    This can happen if the problem is unbounded below and the iterates are diverging.

\item[Stopping optimization at current point as requested by user.] ~

    This message is printed if either the time limit or the domain violation limit is reached.

\item[Maximum Number of Iterations Exceeded.] ~

    This indicates that Ipopt has exceeded the maximum number of iterations as specified by the option max\_iter.

\item[Restoration Failed!] ~

    This indicates that the restoration phase failed to find a feasible point that was acceptable to the filter line search for the original problem.
    This could happen if the problem is highly degenerate or does not satisfy the constraint qualification, or if an external function in GAMS provides incorrect derivative information.

\item[Error in step computation (regularization becomes too large?)!] ~

    This messages is printed if Ipopt is unable to compute a search direction, despite several attempts to modify the iteration matrix.
    Usually, the value of the regularization parameter then becomes too large.

\item[Problem has too few degrees of freedom.] ~

    This indicates that your problem, as specified, has too few degrees of freedom.
    This can happen if you have too many equality constraints, or if you fix too many variables (Ipopt removes fixed variables).

\item[Not enough memory.] ~

    An error occurred while trying to allocate memory.
    The problem may be too large for your current memory and swap configuration.

\item[INTERNAL ERROR: Unknown SolverReturn value - Notify IPOPT Authors.] ~

    An unknown internal error has occurred. Please notify the authors of the GAMS/CoinIpopt link or IPOPT (refer to \url{https://projects.coin-or.org/GAMSlinks} or \url{https://projects.coin-or.org/Ipopt}).
\end{description}


\subsection{Specification of CoinIpopt Options}
\label{sub:ipoptoptionspec}

Ipopt has many options that can be adjusted for the algorithm (see Section \ref{sub:ipoptoptions}).
Options are all identified by a string name, and their values can be of one of three types: Number (real), Integer, or String.
Number options are used for things like tolerances, integer options are used for things like maximum number of iterations, and string options are used for setting algorithm details, like the NLP scaling method.
Options can be set by creating a \texttt{ipopt.opt} file in the directory you are executing Ipopt.

The \texttt{ipopt.opt} file is read line by line and each line should contain the option name, followed by whitespace, and then the value.
Comments can be included with the \# symbol. Don't forget to ensure you have a newline at the end of the file. For example,
\begin{verbatim}
# This is a comment

# Turn off the NLP scaling
nlp_scaling_method none

# Change the initial barrier parameter
mu_init 1e-2

# Set the max number of iterations
max_iter 500
\end{verbatim}
is a valid \texttt{ipopt.opt} file.

% You can print the documentation for all Ipopt options by using the option
% \begin{verbatim}
% print_options_documentation yes
% \end{verbatim}
% and running IPOPT.
% This will output all of the options documentation to the console.

Note, that GAMS/CoinIpopt overwrites the Ipopt default setting for the parameters bound\_relax\_factor (set to 0.0) and mu\_strategy (set to adaptive).
You can change these values by specifying these options in your Ipopt options file.

GAMS/CoinIpopt understand currently the following GAMS parameters: reslim (time limit), iterlim (iteration limit), domlim (domain violation limit).
You can set them either on the command line, e.g. \verb+iterlim=500+, or inside your GAMS program, e.g. \verb+Option iterlim=500;+.

\subsection{Detailed Description of CoinIpopt Options}
\label{sub:ipoptoptions}
\input{optipopt_a}


\section{CoinScip}

GAMS/CoinScip brings the MIP solver from the Constrained Integer Programming framework SCIP to the broad audience of academic GAMS users.

The code is developed at the Konrad-Zuse-Zentrum f\"ur Informationstechnik Berlin (ZIB) and has been written primarily by T. Achterberg.
It is distributed under the ZIB Academic License.

For more information we refer to
\begin{itemize}
\item the SCIP web site \texttt{http://scip.zib.de} and
\item the Ph.D. thesis ``Constraint Integer Programming'' by Tobias Achterberg, Berlin 2007.
\end{itemize}

GAMS/CoinScip uses the COIN-OR linear solver CLP from J.J. Forrest as LP solver, see \hyperlink{sec:coincbc}{Section \ref{sec:coincbc}}.

\subsection{Model requirements}

SCIP supports continuous, binary, and integer variables, but no special ordered sets, semi-continuous or semi-integer variables (see chapter 17.1 of the GAMS User's Guide).
Branching priorities are supported.

\subsection{Usage of CoinScip}

The following statement can be used inside your GAMS program to specify using CoinScip
\begin{verbatim}
  Option MIP = CoinScip;     { or LP or RMIP }
\end{verbatim}

The above statement should appear before the Solve statement.
If CoinScip was specified as the default solver during GAMS installation, the above statement is not necessary.

GAMS/CoinScip now support the GAMS Branch-and-Cut-and-Heuristic (BCH) Facility.
The GAMS BCH facility automates all major steps necessary to define, execute, and control the use of user defined routines within the framework of general purpose MIP codes.
Currently supported are user defined cut generators and heuristics and the incumbent reporting callback.
Please see the BCH documentation at \texttt{http://www.gams.com/docs/bch.htm} for further information.

Information on the use of BCH callback routines is displayed in an extra column in the SCIP iteration output.
The first number in this column (below the ``BCH'' in the header) is the number of callbacks to GAMS models that have been made so far (accumulated from cutgeneration, heuristic, and incumbent callbacks).
The number below ``cut'' or ``cuts'' gives the number of cutting planes that have been generated by the users cutgenerator.
Finally, the number below ``sol'' or ``sols'' gives the number of primal solutions that have been generated by the users heuristic.
If SCIP accepts a heuristic solution as new incumbent solution, it prints a `G' in the first column of the iteration output.

\subsection{Specification of CoinScip Options}

GAMS/CoinScip currently supports the GAMS parameters reslim, iterlim, nodlim, optcr, and optca.

Further, for a MIP solve the user can specify options by a SCIP options file.
A SCIP options file consists of one option or comment per line.
A pound sign (\#) at the beginning of a line causes the entire line to be ignored.
Otherwise, the line will be interpreted as an option name and value separated by an equal sign (=) and any amount of white space (blanks or tabs).
Further, string values have to be enclosed in quotation marks.

A small example for a coinscip.opt file is:
\begin{verbatim}
  separating/maxrounds     = 0
  separating/maxroundsroot = 0
  gams/solvefinal          = FALSE
  gams/usercutcall         = "bchcutgen.gms"
\end{verbatim}
It will cause SCIP to turn off all cut generators and the final solve of the MIP with fixed discrete variables is skipped.

\subsection{Description of CoinScip options}

SCIP supports a large set of options.
Sample option files can be obtained from
\begin{verbatim}
     http://www.gams.com/~svigerske/scip
\end{verbatim}

Further, there is a set of options that are specific to the GAMS/CoinScip interface, most of them for control of the GAMS BCH facility.

\begin{description}
\item[\label{scipnames}\hypertarget{scipnames}
{\textbf{gams/names (\slshape{integer})}}]\hspace{1.0in}

This option causes GAMS names for the variables and equations to be loaded into SCIP.
These names will then be used for error messages, log entries, and so forth.
Turning names off may help if memory is very tight.

\textsl{(default = 0)}
\begin{itemize}
\item[0] Do not load variable and equation names.
\item[1] Load variable and equation names.
\end{itemize}


\item[\label{scipsolvefinal}\hypertarget{scipsolvefinal}
{\textbf{gams/solvefinal (\slshape{integer})}}]\hspace{1.0in}

Sometimes the solution process after the branch-and-cut that solves the problem with fixed discrete variables takes a long time and the user is interested in the primal values of the solution only.
In these cases, this option can be used to turn this final solve off.
Without the final solve no proper marginal values are available and only zeros are returned to GAMS.

\textsl{(default = 1)}
\begin{itemize}
\item[0] Do not solve the fixed problem.
\item[1] Solve the fixed problem and return duals.
\end{itemize}


\item[\label{scipmipstart}\hypertarget{scipmipstart}
{\textbf{gams/mipstart (\slshape{integer})}}]\hspace{1.0in}

This option controls the use of advanced starting values for mixed integer programs.
A setting of 1 indicates that the variable level values should be checked to see if they provide an integer feasible solution before starting optimization.

\textsl{(default = 1)}
\begin{itemize}
\item[0] Do not use the initial variable levels.
\item[1] Try to use the initial variable levels as a MIP starting solution.
\end{itemize}


\item[\label{scipusercutcall}\hypertarget{scipusercutcall}
{\textbf{gams/usercutcall (\slshape{string})}}]\hspace{1.0in}

The GAMS command line (minus the gams executable name) to call the cut generator.


\item[\label{scipusercutfirst}\hypertarget{scipusercutfirst}
{\textbf{gams/usercutfirst (\slshape{integer})}}]\hspace{1.0in}

Calls the cut generator for the first $n$ nodes.

\textsl{(default = 10)}

\item[\label{scipusercutfreq}\hypertarget{scipusercutfreq}
{\textbf{gams/usercutfreq (\slshape{integer})}}]\hspace{1.0in}

Determines the frequency of the cut generator model calls.

\textsl{(default = 10)}

\item[\label{scipusercutinterval}\hypertarget{scipusercutinterval}
{\textbf{gams/usercutinterval (\slshape{integer})}}]\hspace{1.0in}

Determines the interval when to apply the multiplier for the frequency of the cut generator model calls.
See gams/userheurinterval for details.

\textsl{(default = 100)}

\item[\label{scipusercutmult}\hypertarget{scipusercutmult}
{\textbf{gams/usercutmult (\slshape{integer})}}]\hspace{1.0in}

Determines the multiplier for the frequency of the cut generator model calls.

\textsl{(default = 2)}

\item[\label{scipusercutnewint}\hypertarget{scipusercutnewint}
{\textbf{gams/usercutnewint (\slshape{integer})}}]\hspace{1.0in}

Calls the cut generator if the solver found a new integer feasible solution.

\textsl{(default = 1)}
\begin{itemize}
\item[0] .
Do not call cut generator because a new integer feasible solution is found.
\item[1] .
Let SCIP call the cut generator if a new integer feasible solution is found.
\end{itemize}

\item[\label{scipusergdxin}\hypertarget{scipusergdxin}
{\textbf{gams/usergdxin (\slshape{string})}}]\hspace{1.0in}

The name of the GDX file read back into SCIP.

\textsl{(default =} \verb=bchin.gdx=)

\item[\label{scipusergdxname}\hypertarget{scipusergdxname}
{\textbf{gams/usergdxname (\slshape{string})}}]\hspace{1.0in}

The name of the GDX file exported from the solver with the solution at the node.

\textsl{(default =} \verb=bchout.gdx=)

\item[\label{scipusergdxnameinc}\hypertarget{scipusergdxnameinc}
{\textbf{gams/usergdxnameinc (\slshape{string})}}]\hspace{1.0in}

The name of the GDX file exported from the solver with the incumbent solution.

\textsl{(default =} \verb=bchout_i.gdx=)

\item[\label{scipusergdxprefix}\hypertarget{scipusergdxprefix}
{\textbf{gams/usergdxprefix (\slshape{string})}}]\hspace{1.0in}

Prefixes to use for gams/usergdxin, gams/usergdxname, and gams/usergdxnameinc.


\item[\label{scipuserheurcall}\hypertarget{scipuserheurcall}
{\textbf{gams/userheurcall (\slshape{string})}}]\hspace{1.0in}

The GAMS command line (minus the gams executable name) to call the heuristic.


\item[\label{scipuserheurfirst}\hypertarget{scipuserheurfirst}
{\textbf{gams/userheurfirst (\slshape{integer})}}]\hspace{1.0in}

Calls the heuristic for the first $n$ nodes.

\textsl{(default = 10)}

\item[\label{scipuserheurfreq}\hypertarget{scipuserheurfreq}
{\textbf{gams/userheurfreq (\slshape{integer})}}]\hspace{1.0in}

Determines the frequency of the heuristic model calls.

\textsl{(default = 10)}

\item[\label{scipuserheurinterval}\hypertarget{scipuserheurinterval}
{\textbf{gams/userheurinterval (\slshape{integer})}}]\hspace{1.0in}

Determines the interval when to apply the multiplier for the frequency of the heuristic model calls.
For example, for the first 100 (gams/userheurinterval) nodes, the solver call every 10th (gams/userheurfreq) node the heuristic.
After 100 nodes, the frequency gets multiplied by 10 (gams/userheurmult), so that for the next 100 node the solver calls the heuristic every 20th node.
For nodes 200-300, the heuristic get called every 40th node, for nodes 300-400 every 80th node and after node 400 every 100th node.

\textsl{(default = 100)}

\item[\label{scipuserheurmult}\hypertarget{scipuserheurmult}
{\textbf{gams/userheurmult (\slshape{integer})}}]\hspace{1.0in}

Determines the multiplier for the frequency of the heuristic model calls.

\textsl{(default = 2)}

\item[\label{scipuserheurnewint}\hypertarget{scipuserheurnewint}
{\textbf{gams/userheurnewint (\slshape{integer})}}]\hspace{1.0in}

Calls the heuristic if the solver found a new integer feasible solution.

\textsl{(default = 1)}
\begin{itemize}
\item[0] .
Do not call heuristic because a new integer feasible solution is found.
\item[1] .
Let SCIP call the heuristic if a new integer feasible solution is found.
\end{itemize}

\item[\label{scipuserheurobjfirst}\hypertarget{scipuserheurobjfirst}
{\textbf{gams/userheurobjfirst (\slshape{integer})}}]\hspace{1.0in}

Similar to gams/userheurfirst but only calls the heuristic if the relaxed objective value promises a significant improvement of the current incumbent, i.e., the LP value of the node has to be closer to the best bound than the current incumbent.

\textsl{(default = 0)}

\item[\label{scipuserjobid}\hypertarget{scipuserjobid}
{\textbf{gams/userjobid (\slshape{string})}}]\hspace{1.0in}

Postfixes to use for gams/gdxname, gams/gdxnameinc, and gams/gdxin.


\item[\label{scipuserkeep}\hypertarget{scipuserkeep}
{\textbf{gams/userkeep (\slshape{integer})}}]\hspace{1.0in}

Calls gamskeep instead of gams

\textsl{(default = 0)}

\end{description}

\chapterend
