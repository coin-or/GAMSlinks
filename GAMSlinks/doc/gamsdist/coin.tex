%%%
%%% tabular with the option-table header
%%%
\renewenvironment{option_tabular}%
{\begin{tabular}{p{.16\textwidth}p{.65\textwidth}p{.11\textwidth}}
\hline
\textbf{Option}      &
\textbf{Description} &
\textbf{Default}     \\
\hline}
{\end{tabular}}

%%%
%%% list to use inside a tabular cell
%%%
\renewenvironment{tab_list}[1]%
{\begin{list}{}{\vspace*{-1.5ex}\renewcommand{\makelabel}{\desclabel}\parsep-0.15cm\labelwidth#1\leftmargin#1\setlength{\labelsep}{\itemindent}\topsep0cm\parskip0cm\partopsep0cm}}%
{\end{list}}


\chapter{COIN-OR}
\textbf{Stefan Vigerske, Humboldt University Berlin, Germany}
\vspace{1cm}

\minitoc


\section{Introduction}

COIN-OR (\textbf{CO}mputational \textbf{IN}frastructure for \textbf{O}perations \textbf{R}esearch, \texttt{http://www.coin-or.org}) is an initiative to spur the development of open-source software for the operations research community.
One of the projects hosted at COIN-OR is the GAMSlinks project (\texttt{https://projects.coin-or.org/GAMSlinks}).
It is dedicated to the development of interfaces between GAMS and open source solvers.
Some of these links and solvers have also found their way into the regular GAMS distribution.
They are currently available for Linux (32 and 64 bit), Windows (32 and 64 bit), Sun Solaris (Intel 64 bit), and Darwin (Intel 32 and 64 bit) systems.
With the availability of source code for the GAMSlinks the user is not limited to the out of the box solvers that come with a regular GAMS distribution, but can extend and build these interfaces by themselves.

Available solvers and tools include:
\begin{itemize}
\item CoinBonmin 1.1: Basic Open-source Nonlinear Mixed Integer programming\\
(model types: LP, RMIP, MIP, DNLP, NLP, RMINLP, MINLP, QCP, RMIQCP, MIQCP)
\item CoinCbc 2.3: COIN-OR Branch and Cut\\
(model types: LP, MIP, RMIP)
\item CoinCouenne 0.2: Convex Over and Under Envelopes for Nonlinear Estimation\\
(model types: LP, RMIP, MIP, DNLP, NLP, RMINLP, MINLP, QCP, RMIQCP, MIQCP)
\item CoinGlpk 4.39: Gnu Linear Programming Kit\\
(model types: LP, MIP, RMIP)
\item CoinIpopt 3.7: Interior Point Optimizer\\
(model types: LP, RMIP, DNLP, NLP, RMINLP, QCP, RMIQCP)
\item CoinOS 2.0: Optimization Services\\
(model types: LP, RMIP, MIP, DNLP, NLP, RMINLP, MINLP, QCP, RMIQCP, MIQCP)
\item CoinScip 1.2.0: Solving Constrained Integer Programs\\
(model types: LP, MIP, RMIP)
\end{itemize}

% The open source concept opens new possibilities for our advanced users:
% 
% \begin{itemize}
% \item Make modifications to the existing links
% \item Port the links to another platform supported by GAMS
% \item Connect new solvers to GAMS/COIN-OR
% \item Extend the documentation
% \end{itemize}

For more information see the COIN-OR/GAMSlinks web site at
\texttt{https://projects.coin-or.org/GAMSlinks}.

\section{CoinBonmin and CoinBonminD}

GAMS/CoinBonmin brings the open source MINLP solver Bonmin to the broad audience of GAMS users.

Bonmin (\textbf{B}asic \textbf{O}pen-source \textbf{N}onlinear \textbf{M}ixed \textbf{In}teger programming) is an open-source solver for convex mixed-integer nonlinear programming (MINLPs).
The code is developed in a joined project of IBM and the Carnegie Mellon University.
The COIN-OR project leader for Bonmin is Pierre Bonami.

Bonmin implements five different algorithms:
\begin{itemize}
\item {B-BB} (\textbf{default}): a simple branch-and-bound algorithm based on solving a continuous nonlinear program at each node of the search tree and branching on integer variables; this algorithm is similar to the one implemented in the solver SBB
\item {B-OA}: an outer-approximation based decomposition algorithm based on iterating solving and improving of a MIP relaxation and solving NLP subproblems; this algorithm is similar to the one implemented in the solvers DICOPT and AlphaECP
\item {B-QG}: an outer-approximation based branch-and-cut algorithm (by Queseda and Grossmann) based on solving a continuous linear program at each node of the search tree, improving the linear program by outer approximation, and branching on integer variables
\item {B-Hyb}: a branch-and-bound algorithm which is a hybrid of B-BB and B-QG and is based on solving either a continuous nonlinear or a continuous linear program at each node of the search tree, improving the linear program by outer approximation, and branching on integer variables
\item {B-Ecp}: an ECP cuts based branch-and-cut algorithm a la FilMINT
\end{itemize}
The algorithms are exact when the problem is \textbf{convex}, otherwise they are heuristics.

For convex MINLPs, experiments on a reasonably large test set of problems have shown that B-Hyb is the algorithm of choice (it solved most of the problems in 3 hours of computing time).
Nevertheless, there are cases where B-OA is much faster than B-Hyb and others where B-BB is interesting.
B-QG corresponds mainly to a specific parameter setting of B-Hyb where some features are disabled.
B-Ecp has recently been added to Bonmin and is still experimental.
For \textbf{nonconvex} MINLPs, it is strongly recommend to use B-BB, even though it is a heuristic for such problems too.
% Therefore, it is the default algorithm in Bonmin.

For more information we refer to
\begin{itemize}
\item the Bonmin web site \texttt{https://projects.coin-or.org/Bonmin} and
\item the paper P. Bonami, L.T. Biegler, A.R. Conn, G. Cornuejols, I.E. Grossmann, C.D. Laird, J. Lee, A. Lodi, F. Margot, N.Sawaya and A. W\"achter, An Algorithmic Framework for Convex Mixed Integer Nonlinear Programs, \emph{Discrete Optimization} 5, 186--204, 2008, and \emph{IBM Research Report} RC23771, Oct. 2005.
\end{itemize}
Most of the Bonmin documentation in the section is taken from the Bonmin manual available on the Bonmin web site.

Gams/BonminD is an experimental in-core communication link.
It offers in-core communication between GAMS and the solver, making potentially large model scratch files unnecessary.
This links supports all features of the traditional link except for the GAMS branch-cut-heuristic facility (BCH).

\subsection{Model requirements}

Bonmin can handle mixed-integer nonlinear programming models which functions can be nonconvex, but should be twice continuously differentiable.
The Bonmin link in GAMS supports continuous, binary, and integer variables, special ordered sets, branching priorities, but no semi-continuous or semi-integer variables (see chapter 17.1 of the GAMS User's Guide).

If GAMS/CoinBonmin is called for a model with only continuous variables, the interface directly calls Ipopt.

\subsection{Usage of CoinBonmin}

The following statement can be used inside your GAMS program to specify using CoinBonmin
\begin{verbatim}
  Option MINLP = CoinBonmin;     { or LP, RMIP, MIP, DNLP, NLP, RMINLP, QCP, RMIQCP, MIQCP }
\end{verbatim}

The above statement should appear before the Solve statement.
If CoinBonmin was specified as the default solver during GAMS installation, the above statement is not necessary.

GAMS/CoinBonmin supports the GAMS Branch-and-Cut-and-Heuristic (BCH) Facility.
The GAMS BCH facility automates all major steps necessary to define, execute, and control the use of user defined routines within the framework of general purpose MIP and MINLP codes.
Currently supported are user defined cut generators and heuristics, where cut generator cannot be used in Bonmins pure B\&B algorithm (B-BB).
Please see the BCH documentation at \texttt{http://www.gams.com/docs/bch.htm} for further information.

\subsection{Specification of CoinBonmin Options}
\label{sub:bonminoptionspec}

A Bonmin option file contains both Ipopt and Bonmin options, for clarity all Bonmin options should be preceded with the prefix ``\texttt{bonmin.}'', except those corresponding to the BCH facility.
%Bonmin has many options that can be adjusted for the algorithm (see Section \ref{sub:bonminoptions}).
The scheme to name option files is the same as for all other GAMS solvers.
Specifying \texttt{optfile=1} let Gams/CoinBonmin read \texttt{coinbonmin.opt}, \texttt{optfile=2} corresponds to \texttt{coinbonmin.op2}, and so on.
The format of the option file is the same as for Ipopt (see Section \ref{sub:ipoptoptionspec}).

The most important option in Bonmin is the choice of the solution algorithm.
This can be set by using the option named \texttt{bonmin.algorithm} which can be set to \texttt{B-BB}, \texttt{B-OA}, \texttt{B-QG}, \texttt{B-Hyb}, or \texttt{B-Ecp} (its default value is \texttt{B-BB}).
Depending on the value of this option, certain other options may be available or not.

In the context of outer approximation decomposition (B-OA), several options are available for configuring the MIP subsolver CBC.
By setting the option \texttt{bonmin.milp\_subsolver} to \texttt{Cbc\_Par}, a version of CBC is chosen that can be parameterized by the user.
The options that can be set are the node-selection strategy, the number of strong-branching candidates, the number of branches before pseudo costs are to be trusted, and the frequency of some cut generators.
Their name coincide with Bonmins options, except that the ``\texttt{bonmin.}'' prefix is replaced with  ``\texttt{milp\_sub.}''.

An example of a \texttt{bonmin.opt} file is the following:
\begin{verbatim}
   bonmin.algorithm       B-Hyb
   bonmin.oa_log_level    4
   bonmin.milp_subsolver  Cbc_Par
   milp_sub.cover_cuts    0
   print_level            6
   userheurcall           "bchheur.gms reslim 10"
\end{verbatim}
This sets the algorithm to be used to the hybrid algorithm, the level of outer approximation related output to $4$, the MIP subsolver for outer approximation to a parameterized version of CBC, switches off cover cutting planes for the MIP subsolver, sets the print level for \texttt{Ipopt} to $6$, and let Bonmin call a user defined heuristic specified in the model \texttt{bchheur.gms} with a timelimit of 10 seconds.

GAMS/CoinBonmin understands currently the following GAMS parameters: reslim (time limit), iterlim (iteration limit), nodlim (node limit), cutoff, optca (absolute gap tolerance), and optcr (relative gap tolerance).
You can set them either on the command line, e.g. \verb+nodlim=1000+, or inside your GAMS program, e.g. \verb+Option nodlim=1000;+.

\subsection{Description of CoinBonmin Options}
\label{sub:bonminoptions}

The following tables gives the list of options together with their types, default values and availability in each of the four main algorithms.
The column labeled `type' indicates the type of the parameter (`F' stands for float, `I' for integer, and `S' for
string).
The column labeled `default' indicates the global default value.
Then for each of the four algorithm \texttt{B-BB}, \texttt{B-OA}, \texttt{B-QG}, and \texttt{B-Hyb}, `$+$' indicates that the option is available for that particular algorithm while `$-$' indicates that it is not.
Options that are marked with $^*$ are those that can be used to configure the MIP subsolver.

\begin{center}
\begin{tabular}{|l|r|r|r|r|r|r|}\hline
Option & type &  default & {\tt B-BB} & {\tt B-OA} & {\tt B-QG} & {\tt B-Hyb} \\
\hline
\hline
\multicolumn{1}{|c}{} & \multicolumn{6}{l|}{Algorithm choice}\\
\hline
algorithm& S& B-BB& +& +& +& +\\
\hline
\multicolumn{1}{|c}{} & \multicolumn{6}{l|}{Output}\\
\hline
bb\_log\_interval& I& 100& +&--& +& +\\
bb\_log\_level& I& 1& +&--& +& +\\
lp\_log\_level& I& 0&--&--& +& +\\
milp\_log\_level& I& 0&--& +&--& +\\
nlp\_log\_level& I& 1& +& +& +& +\\
oa\_cuts\_log\_level& I& 0&--& +& +& +\\
oa\_log\_frequency& F& 100& +& +& +& +\\
oa\_log\_level& I& 1& +& +& +& +\\
\hline
\end{tabular}

\begin{tabular}{|l|r|r|r|r|r|r|}\hline
Option & type &  default & {\tt B-BB} & {\tt B-OA} & {\tt B-QG} & {\tt B-Hyb} \\
\hline
\hline
\multicolumn{1}{|c}{} & \multicolumn{6}{l|}{Branch-and-bound options}\\
\hline
allowable\_fraction\_gap& F& optcr ($0.1$)& +& +& +& +\\
allowable\_gap& F& optca ($0$)& +& +& +& +\\
cutoff& F& cutoff or $10^{100}$& +& +& +& +\\
cutoff\_decr& F& $10^{-5}$& +& +& +& +\\
integer\_tolerance& F& $10^{-6}$& +& +& +& +\\
iteration\_limit& I& $\infty$& +& +& +& +\\
nlp\_failure\_behavior& S& stop& +& +& +& +\\
node\_comparison& S& best-bound& +& +& +& +\\
node\_limit& I& nodlim or iterlim ($\infty$)& +& +& +& +\\
num\_cut\_passes& I& 1&--& +& +& +\\
num\_cut\_passes\_at\_root& I& 20&--& +& +& +\\
number\_before\_trust& I& 8& +& +& +& +\\
number\_strong\_branch& I& 20& +& +& +& +\\
solution\_limit& I& $\infty$& +& +& +& +\\
time\_limit& F& reslim ($1000$)& +& +& +& +\\
tree\_search\_strategy& S& probed-dive& +& +& +& +\\
variable\_selection& S& strong-branching& +& +& +& +\\
\hline
\multicolumn{1}{|c}{} & \multicolumn{6}{l|}{Diving options}\\
\hline
max\_backtracks\_in\_dive& I& 5& +& +& +& +\\
max\_dive\_depth& I& $\infty$& +& +& +& +\\
stop\_diving\_on\_cutoff& S& no& +& +& +& +\\
\hline
\multicolumn{1}{|c}{} & \multicolumn{6}{l|}{ECP based strong branching}\\
\hline
ecp\_abs\_tol\_strong& F& $10^{-6}$& +& +& +& +\\
ecp\_max\_rounds\_strong& I& 0& +& +& +& +\\
ecp\_rel\_tol\_strong& F& 0.1& +& +& +& +\\
lp\_strong\_warmstart\_method& S& Basis& +& +& +& +\\
\hline
\multicolumn{1}{|c}{} & \multicolumn{6}{l|}{ECP cuts generation}\\
\hline
ecp\_abs\_tol& F& $10^{-6}$&--&--&--& +\\
ecp\_max\_rounds& I& 5&--&--&--& +\\
ecp\_propability\_factor& F& 1000&--&--&--& +\\
ecp\_rel\_tol& F& 0&--&--&--& +\\
filmint\_ecp\_cuts& I& 0&--&--&--& +\\
\hline
\multicolumn{1}{|c}{} & \multicolumn{6}{l|}{GAMS Branch Cut and Heuristic Facility}\\
\hline
usercutcall& S& none& --& +& +& +\\
usercutfirst& I& 10& --& +& +& +\\
usercutfreq& I& 10& --& +& +& +\\
usercutinterval& I& 100& --& +& +& +\\
usercutmult& I& 2& --& +& +& +\\
usercutnewint& I& 0& --& +& +& +\\
usergdxin& S& bchin.gdx& +& +& +& +\\
usergdxname& S& bchout.gdx& +& +& +& +\\
usergdxnameinc& S& bchout\_i.gdx& +& +& +& +\\
usergdxprefix& S&none & +& +& +& +\\
userheurcall& S& none& +& +& +& +\\
userheurfirst& I& 10& +& +& +& +\\
userheurfreq& I& 10& +& +& +& +\\
userheurinterval& I& 100& +& +& +& +\\
userheurmult& I& 2& +& +& +& +\\
userheurnewint& I& 0& +& +& +& +\\
userheurobjfirst& I& 0& +& +& +& +\\
userjobid& S& none& +& +& +& +\\
userkeep& I& 0& +& +& +& +\\
\hline
\end{tabular}

\begin{tabular}{|l|r|r|r|r|r|r|}\hline
Option & type &  default & {\tt B-BB} & {\tt B-OA} & {\tt B-QG} & {\tt B-Hyb} \\
\hline
\hline
\multicolumn{1}{|c}{} & \multicolumn{6}{l|}{MILP cutting planes in hybrid algorithm}\\
\hline
2mir\_cuts& I& 0&--& +&--& +\\
Gomory\_cuts& I& -5&--& +&--& +\\
clique\_cuts& I& -5&--& +&--& +\\
cover\_cuts& I& -5&--& +&--& +\\
flow\_covers\_cuts& I& -5&--& +&--& +\\
lift\_and\_project\_cuts& I& 0&--& +&--& +\\
mir\_cuts& I& -5&--& +&--& +\\
% probing\_cuts& I& -5&--& +&--& +\\
reduce\_and\_split\_cuts& I& 0&--& +&--& +\\
\hline
\multicolumn{1}{|c}{} & \multicolumn{6}{l|}{NLP interface}\\
\hline
warm\_start& S& none& +&--&--&--\\
\hline
\multicolumn{1}{|c}{} & \multicolumn{6}{l|}{NLP solution robustness}\\
\hline
max\_consecutive\_failures& I& 10& +& +& +& +\\
max\_random\_point\_radius& F& 100000& +&--&--&--\\
num\_iterations\_suspect& I& -1& +& +& +& +\\
num\_retry\_unsolved\_random\_point& I& 0& +& +& +& +\\
random\_point\_perturbation\_interval& F& 1& +&--&--&--\\
random\_point\_type& S& Jon& +&--&--&--\\
\hline
\multicolumn{1}{|c}{} & \multicolumn{6}{l|}{NLP solves in hybrid algorithm}\\
\hline
nlp\_solve\_frequency& I& 10&--&--&--& +\\
nlp\_solve\_max\_depth& I& 10&--&--&--& +\\
nlp\_solves\_per\_depth& F& $10^{30}$&--&--&--& +\\
\hline
\multicolumn{1}{|c}{} & \multicolumn{6}{l|}{Nonconvex problems}\\
\hline
max\_consecutive\_infeasible& I& 0& +& +& +& +\\
num\_resolve\_at\_infeasibles& I& 0& +&--&--&--\\
num\_resolve\_at\_node& I& 0& +&--&--&--\\
num\_resolve\_at\_root& I& 0& +&--&--&--\\
\hline
\multicolumn{1}{|c}{} & \multicolumn{6}{l|}{Outer Approximation decomposition}\\
\hline
milp\_subsolver& S& Cbc\_D&--& +&--& +\\
oa\_dec\_time\_limit& F& 30& +& +& +& +\\
\hline
\multicolumn{1}{|c}{} & \multicolumn{6}{l|}{Outer Approximation cuts generation}\\
\hline
add\_only\_violated\_oa& S& no&--& +& +& +\\
cut\_strengthening\_type& S& none&--& +& +& +\\
disjunctive\_cut\_type& S& none&--& +& +& +\\
oa\_cuts\_scope& S& global&--& +& +& +\\
tiny\_element& F& $10^{-8}$&--& +& +& +\\
very\_tiny\_element& F& $10^{-17}$&--& +& +& +\\
\hline
\multicolumn{1}{|c}{} & \multicolumn{6}{l|}{Strong branching setup}\\
\hline
candidate\_sort\_criterion& S& best-ps-cost& +& +& +& +\\
maxmin\_crit\_have\_sol& F& 0.1& +& +& +& +\\
maxmin\_crit\_no\_sol& F& 0.7& +& +& +& +\\
min\_number\_strong\_branch& I& 0& +& +& +& +\\
number\_before\_trust\_list& I& 0& +& +& +& +\\
number\_look\_ahead& I& 0& +& +& +& +\\
number\_strong\_branch\_root& I& $\infty$& +& +& +& +\\
setup\_pseudo\_frac& F& 0.5& +& +& +& +\\
trust\_strong\_branching\_for\_pseudo\_cost& S& yes& +& +& +& +\\
\hline
\end{tabular}
\end{center}

\input{optbonmin_a}

\subsubsection{Ipopt}
All Ipopt options are available in CoinBonmin, please refer to section \ref{sub:ipoptoptions} for a detailed description.
The default value of the following Ipopt parameters are changed in Gams/CoinBonmin:
\begin{itemize}
\item \texttt{mu\_strategy} and \texttt{mu\_oracle} are set, respectively, to {\tt adaptive} and {\tt probing} by default.
\item \texttt{gamma\_phi} and \texttt{gamma\_theta} are set to $10^{-8}$ and $10^{-4}$ respectively. This has the effect of reducing the size of the filter in the line search performed by Ipopt.
\item \texttt{required\_infeasibility\_reduction} is set to $0.1$.
This increases the required infeasibility reduction when Ipopt enters the restoration phase and should thus help
detect infeasible problems faster.
\item \texttt{expect\_infeasible\_problem} is set to {\tt yes} which enables some heuristics to detect infeasible problems faster.
\item \texttt{warm\_start\_init\_point} is set to {\tt yes} when a full primal/dual starting point is available (generally for all the optimizations after the continuous relaxation has been solved).
\item \texttt{print\_level} is set to $0$ by default to turn off Ipopt output.
\item \texttt{bound\_relax\_factor} is set to $10^{-10}$.
\end{itemize}

\section{CoinCbc and CoinCbcD}
\label{sec:coincbc}
\hypertarget{sec:coincbc}{}

GAMS/CoinCBC brings the open source LP/MIP solver CBC to the broad audience of GAMS users.

CBC (COIN-OR Branch and Cut) is an open-source mixed integer programming solver working with the COIN-OR LP solver CLP and the COIN-OR Cut generator library Cgl.
The code has been written primarily by John J. Forrest, who is the COIN-OR project leader for Cbc.

For more information we refer to
\begin{itemize}
\item the CBC web site \texttt{https://projects.coin-or.org/Cbc},
\item the Cgl web site \texttt{https://projects.coin-or.org/Cgl}, and
\item the CLP web site \texttt{https://projects.coin-or.org/Clp}.
\end{itemize}
Most of the CBC documentation in the section was copied from the help in the CBC standalone version.

Gams/CbcD is an experimental in-core communication link.
It offers in-core communication between GAMS and the solver, making potentially large model scratch files unnecessary.
This links supports all features of the traditional link except for the GAMS branch-cut-heuristic facility (BCH).

\subsection{Model requirements}

The CBC link in GAMS supports continuous, binary, integer, semicontinuous, semiinteger variables, special ordered sets of type 1 and 2, and branching priorities (see chapter 17.1 of the GAMS User's Guide).
% Quadratic objective functions are not supported yet.

\subsection{Usage of CoinCbc}

The following statement can be used inside your GAMS program to specify using CoinCBC
\begin{verbatim}
  Option LP = CoinCbc;     { or MIP or RMIP }
\end{verbatim}

The above statement should appear before the Solve statement.
If CoinCBC was specified as the default solver during GAMS installation, the above statement is not necessary.

There are many parameters which can affect the performance the CBCs Branch and Cut Algorithm.
First just try with default settings and look carefully at the log file.
Did cuts help? Did they take too long? Look at the output to see which cuts were effective and then do some tuning (see the option \hyperlink{cuts}{cuts}).
If the \hyperlink{preprocess}{preprocessing} reduced the size of the problem or strengthened many coefficients then it is probably wise to leave it on.
Switch off \hyperlink{heuristics}{heuristics} which did not provide solutions.
The other major area to look at is the search. Hopefully good solutions were obtained fairly early in the search so the important point is to select the best variable to branch on.
See whether strong branching did a good job - or did it just take a lot of iterations.
Adjust the options \hyperlink{strongbranching}{strongbranching} and \hyperlink{trustpseudocosts}{trustpseudocosts}.

The GAMS/CoinCBC options file consists of one option or comment per line.
An asterisk (*) at the beginning of a line causes the entire line to be ignored.
Otherwise, the line will be interpreted as an option name and value separated by any amount of white space (blanks or tabs).
Following is an example options file coincbc.opt.
\begin{verbatim}
  cuts root
  perturbation off
\end{verbatim}
It will cause CoinCBC to use cut generators only in the root node and turns off the perturbation of the LP relaxation.

GAMS/CoinCBC supports the GAMS Branch-and-Cut-and-Heuristic (BCH) Facility.
The GAMS BCH facility automates all major steps necessary to define, execute, and control the use of user defined routines within the framework of general purpose MIP codes.
Currently supported are user defined cut generators and heuristics.
Please see the BCH documentation at \texttt{http://www.gams.com/docs/bch.htm} for further information.

% \subsection{CoinCbc output}
% \subsection{Some CoinCbc features}

\input{optcbc_s}
\input{optcbc_a}

\section{CoinCouenne}

GAMS/CoinCouenne brings the open source MINLP solver Couenne to the broad audience of GAMS users.

Couenne (\textbf{C}onvex \textbf{O}ver and \textbf{U}nder \textbf{En}velopes for \textbf{N}onlinear \textbf{E}stimation) is an open-source solver for nonconvex mixed-integer nonlinear programming (MINLPs).
The code is developed in a joined project of IBM, Carnegie Mellon University, and Lehigh University.
The COIN-OR project leader for Couenne is Pietro Belotti.

Couenne solves convex and nonconvex MINLPs by an LP based spatial branch-and-bound algorithm that is similar to BARON.
The implementation extends Bonmin by routines to compute valid linear outer approximations for nonconvex problems and methods for bound tightening and branching on nonlinear continuous variables.

For more information we refer to
\begin{itemize}
\item the Couenne web site \texttt{https://projects.coin-or.org/Couenne} and
\item the paper P. Belotti, J. Lee, L. Liberti, F. Margot and A. Waechter, Branching and bounds tightening techniques for non-convex MINLP, \emph{IBM Research Report} RC24620, 2008.
\end{itemize}
Most of the Couenne documentation in the section is taken from the Couenne manual available on the Couenne web site.

\subsection{Model requirements}

Couenne can handle mixed-integer nonlinear programming models which functions can be nonconvex, but should be twice continuously differentiable.
The Couenne link in GAMS supports continuous, binary, and integer variables, but no special ordered sets, semi-continuous or semi-integer variables (see chapter 17.1 of the GAMS User's Guide).

If GAMS/CoinCouenne is called for a linear model, the interface directly calls CBC.

\subsection{Usage of CoinCouenne}

The following statement can be used inside your GAMS program to specify using CoinCouenne
\begin{verbatim}
  Option MINLP = CoinCouenne;     { or LP, RMIP, MIP, DNLP, NLP, RMINLP, QCP, RMIQCP, MIQCP }
\end{verbatim}

The above statement should appear before the Solve statement.
If CoinCouenne was specified as the default solver during GAMS installation, the above statement is not necessary.

\subsection{Specification of CoinCouenne Options}
\label{sub:couenneoptionspec}

A Couenne option file contains Ipopt, Bonmin, and Couenne options, for clarity all Bonmin options should be preceded with the prefix ``\texttt{bonmin.}'' and all Couenne options should be preceded with the prefix ``\texttt{couenne.}''.
All Ipopt and many Bonmin options are available in CoinCouenne, please refer to sections \ref{sub:ipoptoptions} and \ref{sub:bonminoptions} for a detailed description.
The scheme to name option files is the same as for all other GAMS solvers.
Specifying \texttt{optfile=1} let Gams/CoinCouenne read \texttt{coincouenne.opt}, \texttt{optfile=2} corresponds to \texttt{coincouenne.op2}, and so on.
The format of the option file is the same as for Ipopt (see Section \ref{sub:ipoptoptionspec}).

GAMS/CoinCouenne understands currently the following GAMS parameters: reslim (time limit), nodlim (node limit), cutoff, optca (absolute gap tolerance), and optcr (relative gap tolerance).
You can set them either on the command line, e.g. \verb+nodlim=1000+, or inside your GAMS program, e.g. \verb+Option nodlim=1000;+.

\subsection{Description of CoinCouenne Options}
\label{sub:couenneoptions}

The following tables gives the list of options together with their types, default values and availability in each of the four main algorithms.
The column labeled `type' indicates the type of the parameter (`F' stands for float, `I' for integer, and `S' for
string).
The column labeled `default' indicates the global default value.
% Then for each of the four Bonmin algorithms \texttt{B-BB}, \texttt{B-OA}, \texttt{B-QG}, and \texttt{B-Hyb}, `$+$' indicates that the option is available for that particular algorithm while `$-$' indicates that it is not.

\begin{center}
\begin{tabular}{|l|r|r|}\hline
Option & type &  default \\
\hline
\hline
\multicolumn{3}{|c|}{Output options}\\
\hline
boundtightening\_print\_level& I& 0\\
branching\_print\_level& I& 0\\
convexifying\_print\_level& I& 0\\
disjcuts\_print\_level& I& 4\\
nlpheur\_print\_level& I& 4\\
problem\_print\_level& I& 2\\
reformulate\_print\_level& I& 4\\\hline
\multicolumn{3}{|c|}{Reformulation and Linearization options}\\
\hline
convexification\_cuts& I& 1\\
convexification\_type& S& current-point-only\\
convexification\_points& I& 4\\
violated\_cuts\_only& S& yes\\
delete\_redundant& S& yes\\
use\_quadratic& S& no\\\hline
\end{tabular}

\begin{tabular}{|l|r|r|}\hline
Option & type &  default \\
\hline
\hline
\multicolumn{3}{|c|}{Branching options}\\
\hline
cont\_var\_priority& I& 2000\\
branch\_conv\_cuts& S& yes\\
branch\_fbbt& S& yes\\
branch\_pt\_select& S& mid-point\\
branch\_pt\_select\_cube& S& branch\_pt\_select\\
branch\_pt\_select\_div& S& branch\_pt\_select\\
branch\_pt\_select\_exp& S& branch\_pt\_select\\
branch\_pt\_select\_log& S& branch\_pt\_select\\
branch\_pt\_select\_negpow& S& branch\_pt\_select\\
branch\_pt\_select\_pow& S& branch\_pt\_select\\
branch\_pt\_select\_prod& S& branch\_pt\_select\\
branch\_pt\_select\_sqr& S& branch\_pt\_select\\
branch\_pt\_select\_trig& S& branch\_pt\_select\\
branch\_lp\_clamp& F& 0.2\\
branch\_lp\_clamp\_cube& F& 0.2\\
branch\_lp\_clamp\_div& F& 0.2\\
branch\_lp\_clamp\_exp& F& 0.2\\
branch\_lp\_clamp\_log& F& 0.2\\
branch\_lp\_clamp\_negpow& F& 0.2\\
branch\_lp\_clamp\_pow& F& 0.2\\
branch\_lp\_clamp\_prod& F& 0.2\\
branch\_lp\_clamp\_sqr& F& 0.2\\
branch\_lp\_clamp\_trig& F& 0.2\\
branch\_midpoint\_alpha& F& 0.25\\
branching\_object& S& var\_obj\\
red\_cost\_branching& S& no\\
pseudocost\_mult& S& interval\_br\_rev\\
pseudocost\_mult\_lp& S& no\\\hline
\multicolumn{3}{|c|}{Bound tightening options}\\
\hline
feasibility\_bt& S& yes\\
aggressive\_fbbt& S& yes\\
optimality\_bt& S& yes\\
redcost\_bt& S& yes\\
% enable\_lp\_implied\_bounds& S& no\\
log\_num\_abt\_per\_level& I& 2\\
log\_num\_obbt\_per\_level& I& 1\\\hline
\multicolumn{3}{|c|}{Disjunctive cut options}\\
\hline
minlp\_disj\_cuts& I& 0\\
disj\_depth\_level& I& 5\\
disj\_depth\_stop& I& 20\\
disj\_active\_cols& S& no\\
disj\_active\_rows& S& no\\
disj\_cumulative& S& no\\
disj\_init\_number& I& 10\\
disj\_init\_perc& F& 0.5\\\hline
\multicolumn{3}{|c|}{Nonlinear solver options}\\
\hline
local\_optimization\_heuristic& S& yes\\
log\_num\_local\_optimization\_per\_level& I& 2\\\hline
\multicolumn{3}{|c|}{Tolerance options}\\
\hline
feas\_tolerance& F& $10^{-5}$\\\hline
\end{tabular}

\begin{tabular}{|l|r|r|}\hline
Option & type &  default \\
\hline
\hline
\multicolumn{3}{|c|}{MIP cut generators options}\\
\hline
Gomory\_cuts& I& 0\\
clique\_cuts& I& 0\\
cover\_cuts& I& 0\\
flow\_covers\_cuts& I& 0\\
lift\_and\_project\_cuts& I& 0\\
mir\_cuts& I& 0\\
2mir\_cuts& I& 0\\
probing\_cuts& I& 0\\
reduce\_split\_cuts& I& 0\\
% art\_cutoff& F& DBL\_MAX\\
% art\_lower& F& -DBL\_MAX\\
% check\_lp& S& no\\
% couenne\_check& F& DBL\_MAX\\
% display\_stats& S& no\\
% enable\_sos& S& no\\
% opt\_window& F& DBL\_MAX\\
% test\_mode& S& no\\
\hline
\end{tabular}
\end{center}

\input{optcouenne_a}

\section{CoinGlpk}

GAMS/CoinGlpk brings the open source LP/MIP solver Glpk from the GNU Open Software foundation to the broad audience of GAMS users.

The code has been written primarily by A. Makhorin.
The interface uses the OSI Glpk interface written by Vivian De Smedt, Braden Hunsaker, and Lou Hafer.

For more information we refer to
\begin{itemize}
\item the Glpk web site \texttt{http://www.gnu.org/software/glpk/glpk.html} and
\item the Osi web site \texttt{https://projects.coin-or.org/Osi}.
\end{itemize}
Most of the Glpk documentation in the section was taken from the Glpk manual.

\subsection{Model requirements}

Glpk supports continuous, binary, and integer variables, but no special ordered sets, semi-continuous or semi-integer variables (see chapter 17.1 of the GAMS User's Guide).
Also branching priorities are not supported.

\subsection{Usage of CoinGlpk}

The following statement can be used inside your GAMS program to specify using CoinGlpk
\begin{verbatim}
  Option LP = CoinGlpk;     { or MIP or RMIP }
\end{verbatim}

The above statement should appear before the Solve statement.
If CoinGlpk was specified as the default solver during GAMS installation, the above statement is not necessary.

The GAMS/CoinGlpk options file consists of one option or comment per line.
An asterisk (*) at the beginning of a line causes the entire line to be ignored.
Otherwise, the line will be interpreted as an option name and value separated by any amount of white space (blanks or tabs).
Following is an example options file coincbc.opt.
\begin{verbatim}
  factorization givens
\end{verbatim}
It will cause CoinGlpk to use Givens rotation updates for the factorization. (This option setting might help to avoid numerical difficulties in some cases.)

\input{optglpk_s}
\input{optglpk_a}



\section{CoinIpopt and CoinIpoptD}

GAMS/CoinIpopt brings the open source NLP solver Ipopt to the broad audience of GAMS users.

Ipopt (\textbf{I}nterior \textbf{P}oint \textbf{Opt}imizer) is an open-source solver for large-scale nonlinear programming.
The code has been written primarily by Andreas W\"achter, who is the COIN-OR project leader for Ipopt.

For more information we refer to
\begin{itemize}
\item the Ipopt web site \texttt{https://projects.coin-or.org/Ipopt} and
\item the \emph{implementation paper} A. W\"achter and L. T. Biegler, On the Implementation of a Primal-Dual Interior Point Filter Line Search Algorithm for Large-Scale Nonlinear Programming, \emph{Mathematical Programming} 106(1), pp. 25-57, 2006.
\end{itemize}
Most of the Ipopt documentation in the section was taken from the Ipopt manual available on the Ipopt web site.

Gams/IpoptD is an experimental in-core communication link.
It offers in-core communication between GAMS and the solver, making potentially large model scratch files unnecessary.
This links supports all features of the traditional link except.

\subsection{Model requirements}

Ipopt can handle nonlinear programming models which functions can be nonconvex, but should be twice continuously differentiable.

\subsection{Usage of CoinIpopt}

The following statement can be used inside your GAMS program to specify using CoinIpopt
\begin{verbatim}
  Option NLP = CoinIpopt;     { or LP, RMIP, DNLP, RMINLP, QCP, RMIQCP }
\end{verbatim}

The above statement should appear before the Solve statement.
If CoinIpopt was specified as the default solver during GAMS installation, the above statement is not necessary.

\subsection{The linear solver in Ipopt}
\label{ipoptlinearsolver}
\hypertarget{ipoptlinearsolver}{}

The performance and robustness of Ipopt on larger models heavily relies on the used solver for sparse symmetric indefinite linear systems.
GAMS/CoinIpopt includes the sparse solver MUMPS 4.8.3 (\url{http://graal.ens-lyon.fr/MUMPS}).
The user can provide the Parallel Sparse Direct Solver PARDISO or routines from the Harwell Subroutine Library (HSL) as shared (or dynamic) libraries to replace MUMPS.

\subsubsection{Using Harwell Subroutine Library routines with GAMS/CoinIpopt}

If you have routines from the HSL available and want Gams/CoinIpopt to use them, you can provide them in a shared library.
GAMS/CoinIpopt can use MA27, MA28, MA57, and MC19.
By telling Ipopt to use one of these routines (see options linear\_solver, linear\_system\_scaling, nlp\_scaling\_method, dependency\_detector) GAMS/CoinIpopt attempts to load the required routines from the library libhsl.so (Unix-Systems), libhsl.dylib (MacOS X), or libhsl.dll (Windows).
You can also specify the path and name for this library with the option hsl\_library.

For example,
\begin{verbatim}
 linear_solver ma27
 hsl_library /my/path/to/the/hsllib/myhsllib.so
\end{verbatim}
tells Ipopt to use the linear solver MA27 from the HSL library \verb=myhsllib.so= under the specified path.

The HSL routines MA27, MA28, and MC19 are available at \texttt{http://www.cse.clrc.ac.uk/nag/hsl}.
Note that it is your responsibility to ensure that you are entitled to download and use these routines!
You can build a shared library using the ThirdParty/HSL project at COIN-OR.

\subsubsection{Using PARDISO routines with GAMS/CoinIpopt}

If you have the linear solver PARDISO available, then you can tell Gams/CoinIpopt to use by setting the linear\_solver option to pardiso.
GAMS/CoinIpopt then attempts to load the library libpardiso.so (Unix-Systems), libpardiso.dylib (MacOS X), or libpardiso.dll (Windows).
You can also specify the path and name for this library with the option pardiso\_library.

For example,
\begin{verbatim}
 linear_solver pardiso
 pardiso_library /my/path/to/the/pardisolib/mypardisolib.so
\end{verbatim}
tells Ipopt to use the linear solver PARDISO from the library \verb=mypardisolib.so= under the specified path.

PARDISO is available as compiled shared library for several platforms at \texttt{http://www.pardiso-project.org}.
Note that it is your responsibility to ensure that you are entitled to download and use this package!

\subsection{Output}

This section describes the standard Ipopt console output.
The output is designed to provide a quick summary of each iteration as Ipopt solves the problem.

Before Ipopt starts to solve the problem, it displays the problem statistics (number of nonzero-elements in the matrices, number of variables, etc.).
Note that if you have fixed variables (both upper and lower bounds are equal), Ipopt may remove these variables from the problem internally and not include them in the problem statistics.

Following the problem statistics, Ipopt will begin to solve the problem and you will see output resembling the following,
\begin{verbatim}
iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
   0  1.6109693e+01 1.12e+01 5.28e-01   0.0 0.00e+00    -  0.00e+00 0.00e+00   0
   1  1.8029749e+01 9.90e-01 6.62e+01   0.1 2.05e+00    -  2.14e-01 1.00e+00f  1
   2  1.8719906e+01 1.25e-02 9.04e+00  -2.2 5.94e-02   2.0 8.04e-01 1.00e+00h  1
\end{verbatim}
and the columns of output are defined as
\begin{description}
\item[iter]
The current iteration count.
This includes regular iterations and iterations while in restoration phase.
If the algorithm is in the restoration phase, the letter r' will be appended to the iteration number.
\item[objective]
The unscaled objective value at the current point.
During the restoration phase, this value remains the unscaled objective value for the original problem.
\item[inf\_pr]
The scaled primal infeasibility at the current point.
During the restoration phase, this value is the primal infeasibility of the original problem at the current point.
\item[inf\_du]
The scaled dual infeasibility at the current point.
During the restoration phase, this is the value of the dual infeasibility for the restoration phase problem.
\item[lg(mu)]
$\log_{10}$ of the value of the barrier parameter mu.
\item[$\Vert d\Vert$]
The infinity norm (max) of the primal step (for the original variables $x$ and the internal slack variables $s$).
During the restoration phase, this value includes the values of additional variables, $p$ and $n$.
\item[lg(rg)]
$\log_{10}$ of the value of the regularization term for the Hessian of the Lagrangian in the augmented system.
\item[alpha\_du]
The stepsize for the dual variables.
\item[alpha\_pr]
The stepsize for the primal variables.
\item[ls]
The number of backtracking line search steps.
\end{description}

When the algorithm terminates, IPOPT will output a message to the screen based on the return status of the call to Optimize.
The following is a list of the possible output messages to the console, and a brief description.

\begin{description}
\item[Optimal Solution Found.] ~

    This message indicates that IPOPT found a (locally) optimal point within the desired tolerances.

\item[Solved To Acceptable Level.] ~

    This indicates that the algorithm did not converge to the ``desired'' tolerances, but that it was able to obtain a point satisfying the ``acceptable'' tolerance level as specified by acceptable-* options.
    This may happen if the desired tolerances are too small for the current problem.

\item[Converged to a point of local infeasibility. Problem may be infeasible.] ~

    The restoration phase converged to a point that is a minimizer for the constraint violation (in the $\ell_1$-norm), but is not feasible for the original problem.
    This indicates that the problem may be infeasible (or at least that the algorithm is stuck at a locally infeasible point).
    The returned point (the minimizer of the constraint violation) might help you to find which constraint is causing the problem.
    If you believe that the NLP is feasible, it might help to start the optimization from a different point.

\item[Search Direction is becoming Too Small.] ~

    This indicates that Ipopt is calculating very small step sizes and making very little progress.
    This could happen if the problem has been solved to the best numerical accuracy possible given the current scaling.

\item[Iterates divering; problem might be unbounded.] ~

    This message is printed if the max-norm of the iterates becomes larger than the value of the option diverging\_iterates\_tol.
    This can happen if the problem is unbounded below and the iterates are diverging.

\item[Stopping optimization at current point as requested by user.] ~

    This message is printed if either the time limit or the domain violation limit is reached.

\item[Maximum Number of Iterations Exceeded.] ~

    This indicates that Ipopt has exceeded the maximum number of iterations as specified by the option max\_iter.

\item[Restoration Failed!] ~

    This indicates that the restoration phase failed to find a feasible point that was acceptable to the filter line search for the original problem.
    This could happen if the problem is highly degenerate or does not satisfy the constraint qualification, or if an external function in GAMS provides incorrect derivative information.

\item[Error in step computation (regularization becomes too large?)!] ~

    This messages is printed if Ipopt is unable to compute a search direction, despite several attempts to modify the iteration matrix.
    Usually, the value of the regularization parameter then becomes too large.

\item[Problem has too few degrees of freedom.] ~

    This indicates that your problem, as specified, has too few degrees of freedom.
    This can happen if you have too many equality constraints, or if you fix too many variables (Ipopt removes fixed variables).

\item[Not enough memory.] ~

    An error occurred while trying to allocate memory.
    The problem may be too large for your current memory and swap configuration.

\item[INTERNAL ERROR: Unknown SolverReturn value - Notify IPOPT Authors.] ~

    An unknown internal error has occurred. Please notify the authors of the GAMS/CoinIpopt link or IPOPT (refer to \url{https://projects.coin-or.org/GAMSlinks} or \url{https://projects.coin-or.org/Ipopt}).
\end{description}


\subsection{Specification of CoinIpopt Options}
\label{sub:ipoptoptionspec}

Ipopt has many options that can be adjusted for the algorithm (see Section \ref{sub:ipoptoptions}).
Options are all identified by a string name, and their values can be of one of three types: Number (real), Integer, or String.
Number options are used for things like tolerances, integer options are used for things like maximum number of iterations, and string options are used for setting algorithm details, like the NLP scaling method.
Options can be set by creating a \texttt{ipopt.opt} file in the directory you are executing Ipopt.

The \texttt{ipopt.opt} file is read line by line and each line should contain the option name, followed by whitespace, and then the value.
Comments can be included with the \# symbol. Don't forget to ensure you have a newline at the end of the file. For example,
\begin{verbatim}
# This is a comment

# Turn off the NLP scaling
nlp_scaling_method none

# Change the initial barrier parameter
mu_init 1e-2

# Set the max number of iterations
max_iter 500
\end{verbatim}
is a valid \texttt{ipopt.opt} file.

% You can print the documentation for all Ipopt options by using the option
% \begin{verbatim}
% print_options_documentation yes
% \end{verbatim}
% and running IPOPT.
% This will output all of the options documentation to the console.

Note, that GAMS/CoinIpopt overwrites the Ipopt default setting for the parameters bound\_relax\_factor (set to 0.0) and mu\_strategy (set to adaptive).
You can change these values by specifying these options in your Ipopt options file.

GAMS/CoinIpopt understand currently the following GAMS parameters: reslim (time limit), iterlim (iteration limit), domlim (domain violation limit).
You can set them either on the command line, e.g. \verb+iterlim=500+, or inside your GAMS program, e.g. \verb+Option iterlim=500;+.

\subsection{Detailed Description of CoinIpopt Options}
\label{sub:ipoptoptions}
\input{optipopt_a}

\section{CoinOS}

GAMS/CoinOS brings the Optimization Services project to the broad audience of GAMS users.

OS (\textbf{O}ptimization \textbf{S}ervices) is an initiative to provide a set of standards for representing optimization instances, results, solver options, and communication between clients and solvers in a distributed environment using Web Services.
The code has been written primarily by Horand Gassmann, Jun Ma, and Kipp Martin.
Kipp Martin is the COIN-OR project leader for OS.

For more information we refer to
\begin{itemize}
\item the official OS web site \texttt{http://www.optimizationservices.org},
\item the OS developer web site \texttt{https://projects.coin-or.org/OS}, and
\item the OS manual available on the OS websites.
\end{itemize}

The OS link in GAMS allows you to convert instances of GAMS models into the OS instance language (OSiL) format, let an Optimization Services Server solve your instances remotely, or solve your models locally via the OS solver interfaces (currently Bonmin, Cbc, Clp, Couenne, Glpk, and Ipopt).

\subsection{Model requirements}

OS supports continuous, binary, and integer variables, linear and nonlinear equations.

\subsection{Usage of CoinOS}

The following statement can be used inside your GAMS program to specify using CoinOS
\begin{verbatim}
  Option MINLP = CoinOS;     { or LP, RMIP, MIP, DNLP, NLP, RMINLP, QCP, RMIQCP, MIQCP }
\end{verbatim}

The above statement should appear before the Solve statement.

By default, for a given instance of a GAMS model, CoinOS selects a suitable solver, let the solver solve this instance (locally) via the corresponding OS solver interface and returns the solution to GAMS.
For continuous linear models (LP and RMIP), CoinOS chooses Clp.
For continuous nonlinear models (NLP, DNLP, RMINLP, QCP, RMIQCP), CoinOS chooses Ipopt.
For mixed-integer linear models (MIP), CoinOS chooses Cbc.
For mixed-integer nonlinear models (MIQCP, MINLP), CoinOS chooses Bonmin.
You can change the choice of the solver by setting the ``solver'' option.

For a remove solve, you have to specify the URL of an Optimization Services Server via the option ``service''.
Remove solves are experimental in CoinOS.

Solver options can be specified with an OSoL (Optimization Services Options Language) file.
The osol file is specified with the ``readosol'' option.

\input{optosd_a}

\section{CoinScip}

GAMS/CoinScip brings the MIP solver from the Constrained Integer Programming framework SCIP to the broad audience of academic GAMS users.

The code is developed at the Konrad-Zuse-Zentrum f\"ur Informationstechnik Berlin (ZIB) and has been written primarily by T. Achterberg.
It is distributed under the ZIB Academic License.

For more information we refer to
\begin{itemize}
\item the SCIP web site \texttt{http://scip.zib.de} and
\item the Ph.D. thesis ``Constraint Integer Programming'' by Tobias Achterberg, Berlin 2007.
\end{itemize}

GAMS/CoinScip uses the COIN-OR linear solver CLP from J.J. Forrest as LP solver, see \hyperlink{sec:coincbc}{Section \ref{sec:coincbc}}.

\subsection{Model requirements}

SCIP supports continuous, binary, and integer variables, special ordered sets, and branching priorities.
Semi-continuous or semi-integer variables (see chapter 17.1 of the GAMS User's Guide) and indicator constraints are not supported by the interface yet.

\subsection{Usage of CoinScip}

The following statement can be used inside your GAMS program to specify using CoinScip
\begin{verbatim}
  Option MIP = CoinScip;     { or LP or RMIP }
\end{verbatim}

The above statement should appear before the Solve statement.
If CoinScip was specified as the default solver during GAMS installation, the above statement is not necessary.

GAMS/CoinScip supports the GAMS Branch-and-Cut-and-Heuristic (BCH) Facility.
The GAMS BCH facility automates all major steps necessary to define, execute, and control the use of user defined routines within the framework of general purpose MIP codes.
Currently supported are user defined cut generators and heuristics and the incumbent reporting callback.
Please see the BCH documentation at \texttt{http://www.gams.com/docs/bch.htm} for further information.

Information on the use of BCH callback routines is displayed in an extra column in the SCIP iteration output.
The first number in this column (below the ``BCH'' in the header) is the number of callbacks to GAMS models that have been made so far (accumulated from cutgeneration, heuristic, and incumbent callbacks).
The number below ``cut'' or ``cuts'' gives the number of cutting planes that have been generated by the users cutgenerator.
Finally, the number below ``sol'' or ``sols'' gives the number of primal solutions that have been generated by the users heuristic.
If SCIP accepts a heuristic solution as new incumbent solution, it prints a `G' in the first column of the iteration output.

\subsection{Specification of CoinScip Options}

GAMS/CoinScip currently supports the GAMS parameters reslim, iterlim, nodlim, optcr, and optca.

Further, for a MIP solve the user can specify options by a SCIP options file.
A SCIP options file consists of one option or comment per line.
A pound sign (\#) at the beginning of a line causes the entire line to be ignored.
Otherwise, the line will be interpreted as an option name and value separated by an equal sign (=) and any amount of white space (blanks or tabs).
Further, string values have to be enclosed in quotation marks.

A small example for a coinscip.opt file is:
\begin{verbatim}
  separating/maxrounds     = 0
  separating/maxroundsroot = 0
  gams/solvefinal          = FALSE
  gams/usercutcall         = "bchcutgen.gms"
\end{verbatim}
It causes GAMS/CoinScip to turn off all cut generators, to skip the final solve of the MIP with fixed discrete variables, and to use a user defined cut generator.

\subsection{Description of CoinScip options}

SCIP supports a large set of options.
Sample option files can be obtained from
\begin{verbatim}
     http://www.gams.com/~svigerske/scip1.2
\end{verbatim}

Further, there is a set of options that are specific to the GAMS/CoinScip interface, most of them for control of the GAMS BCH facility.

\begin{description}
\item[\label{scipnames}\hypertarget{scipnames}
{\textbf{gams/names (\slshape{integer})}}]\hspace{1.0in}

This option causes GAMS names for the variables and equations to be loaded into SCIP.
These names will then be used for error messages, log entries, and so forth.
Turning names off may help if memory is very tight.

\textsl{(default = FALSE)}
\begin{itemize}
\item[FALSE] Do not load variable and equation names.
\item[TRUE] Load variable and equation names.
\end{itemize}


\item[\label{scipsolvefinal}\hypertarget{scipsolvefinal}
{\textbf{gams/solvefinal (\slshape{integer})}}]\hspace{1.0in}

Sometimes the solution process after the branch-and-cut that solves the problem with fixed discrete variables takes a long time and the user is interested in the primal values of the solution only.
In these cases, this option can be used to turn this final solve off.
Without the final solve no proper marginal values are available and only zeros are returned to GAMS.

\textsl{(default = TRUE)}
\begin{itemize}
\item[FALSE] Do not solve the fixed problem.
\item[TRUE] Solve the fixed problem and return duals.
\end{itemize}


\item[\label{scipmipstart}\hypertarget{scipmipstart}
{\textbf{gams/mipstart (\slshape{integer})}}]\hspace{1.0in}

This option controls the use of advanced starting values for mixed integer programs.
A setting of TRUE indicates that the variable level values should be checked to see if they provide an integer feasible solution before starting optimization.

\textsl{(default = TRUE)}
\begin{itemize}
\item[FALSE] Do not use the initial variable levels.
\item[TRUE] Try to use the initial variable levels as a MIP starting solution.
\end{itemize}


\item[\label{scipprintstat}\hypertarget{scipprintstat}
{\textbf{gams/print\_statistics (\slshape{integer})}}]\hspace{1.0in}

This option controls the printing of solve statistics after a MIP solve.
Turning on this option indicates that statistics like the number of
generated cuts of each type or the calls of heuristics are printed after the
MIP solve.

\textsl{(default = FALSE)}
\begin{itemize}
\item[FALSE] Do not print statistics.
\item[TRUE] Print statistics.
\end{itemize}


\item[\label{scipusercutcall}\hypertarget{scipusercutcall}
{\textbf{gams/usercutcall (\slshape{string})}}]\hspace{1.0in}

The GAMS command line (minus the gams executable name) to call the cut generator.


\item[\label{scipusercutfirst}\hypertarget{scipusercutfirst}
{\textbf{gams/usercutfirst (\slshape{integer})}}]\hspace{1.0in}

Calls the cut generator for the first $n$ nodes.

\textsl{(default = 10)}

\item[\label{scipusercutfreq}\hypertarget{scipusercutfreq}
{\textbf{gams/usercutfreq (\slshape{integer})}}]\hspace{1.0in}

Determines the frequency of the cut generator model calls.

\textsl{(default = 10)}

\item[\label{scipusercutinterval}\hypertarget{scipusercutinterval}
{\textbf{gams/usercutinterval (\slshape{integer})}}]\hspace{1.0in}

Determines the interval when to apply the multiplier for the frequency of the cut generator model calls.
See gams/userheurinterval for details.

\textsl{(default = 100)}

\item[\label{scipusercutmult}\hypertarget{scipusercutmult}
{\textbf{gams/usercutmult (\slshape{integer})}}]\hspace{1.0in}

Determines the multiplier for the frequency of the cut generator model calls.

\textsl{(default = 2)}

\item[\label{scipusercutnewint}\hypertarget{scipusercutnewint}
{\textbf{gams/usercutnewint (\slshape{integer})}}]\hspace{1.0in}

Calls the cut generator if the solver found a new integer feasible solution.

\textsl{(default = TRUE)}
\begin{itemize}
\item[FALSE] Do not call cut generator because a new integer feasible solution is found.
\item[TRUE] Let SCIP call the cut generator if a new integer feasible solution is found.
\end{itemize}

\item[\label{scipusergdxin}\hypertarget{scipusergdxin}
{\textbf{gams/usergdxin (\slshape{string})}}]\hspace{1.0in}

The name of the GDX file read back into SCIP.

\textsl{(default =} \verb=bchin.gdx=)

\item[\label{scipusergdxname}\hypertarget{scipusergdxname}
{\textbf{gams/usergdxname (\slshape{string})}}]\hspace{1.0in}

The name of the GDX file exported from the solver with the solution at the node.

\textsl{(default =} \verb=bchout.gdx=)

\item[\label{scipusergdxnameinc}\hypertarget{scipusergdxnameinc}
{\textbf{gams/usergdxnameinc (\slshape{string})}}]\hspace{1.0in}

The name of the GDX file exported from the solver with the incumbent solution.

\textsl{(default =} \verb=bchout_i.gdx=)

\item[\label{scipusergdxprefix}\hypertarget{scipusergdxprefix}
{\textbf{gams/usergdxprefix (\slshape{string})}}]\hspace{1.0in}

Prefixes to use for gams/usergdxin, gams/usergdxname, and gams/usergdxnameinc.


\item[\label{scipuserheurcall}\hypertarget{scipuserheurcall}
{\textbf{gams/userheurcall (\slshape{string})}}]\hspace{1.0in}

The GAMS command line (minus the gams executable name) to call the heuristic.


\item[\label{scipuserheurfirst}\hypertarget{scipuserheurfirst}
{\textbf{gams/userheurfirst (\slshape{integer})}}]\hspace{1.0in}

Calls the heuristic for the first $n$ nodes.

\textsl{(default = 10)}

\item[\label{scipuserheurfreq}\hypertarget{scipuserheurfreq}
{\textbf{gams/userheurfreq (\slshape{integer})}}]\hspace{1.0in}

Determines the frequency of the heuristic model calls.

\textsl{(default = 10)}

\item[\label{scipuserheurinterval}\hypertarget{scipuserheurinterval}
{\textbf{gams/userheurinterval (\slshape{integer})}}]\hspace{1.0in}

Determines the interval when to apply the multiplier for the frequency of the heuristic model calls.
For example, for the first 100 (gams/userheurinterval) nodes, the solver call every 10th (gams/userheurfreq) node the heuristic.
After 100 nodes, the frequency gets multiplied by 10 (gams/userheurmult), so that for the next 100 node the solver calls the heuristic every 20th node.
For nodes 200-300, the heuristic get called every 40th node, for nodes 300-400 every 80th node and after node 400 every 100th node.

\textsl{(default = 100)}

\item[\label{scipuserheurmult}\hypertarget{scipuserheurmult}
{\textbf{gams/userheurmult (\slshape{integer})}}]\hspace{1.0in}

Determines the multiplier for the frequency of the heuristic model calls.

\textsl{(default = 2)}

\item[\label{scipuserheurnewint}\hypertarget{scipuserheurnewint}
{\textbf{gams/userheurnewint (\slshape{integer})}}]\hspace{1.0in}

Calls the heuristic if the solver found a new integer feasible solution.

\textsl{(default = TRUE)}
\begin{itemize}
\item[FALSE] Do not call heuristic because a new integer feasible solution is found.
\item[TRUE] Let SCIP call the heuristic if a new integer feasible solution is found.
\end{itemize}

\item[\label{scipuserheurobjfirst}\hypertarget{scipuserheurobjfirst}
{\textbf{gams/userheurobjfirst (\slshape{integer})}}]\hspace{1.0in}

Similar to gams/userheurfirst but only calls the heuristic if the relaxed objective value promises a significant improvement of the current incumbent, i.e., the LP value of the node has to be closer to the best bound than the current incumbent.

\textsl{(default = FALSE)}

\item[\label{scipuserjobid}\hypertarget{scipuserjobid}
{\textbf{gams/userjobid (\slshape{string})}}]\hspace{1.0in}

Postfixes to use for gams/gdxname, gams/gdxnameinc, and gams/gdxin.


\item[\label{scipuserkeep}\hypertarget{scipuserkeep}
{\textbf{gams/userkeep (\slshape{integer})}}]\hspace{1.0in}

Calls gamskeep instead of gams

\textsl{(default = FALSE)}

\end{description}

\section{CoinCplex, CoinGurobi, CoinMosek, CoinXpress}

GAMS/CoinCplex, GAMS/CoinGurobi, GAMS/CoinMosek, GAMS/CoinXpress bring the open source Open Solver Interface (OSI) to the broad audience of GAMS users.

These ``bare bone'' solver links allow users to solve their GAMS models with a standalone license of Cplex, Gurobi, Mosek, or Xpress.
The links use the COIN-OR Open Solver Interface (OSI) to communicate with these solvers.
The Osi/Cplex link has been written primarily by Tobias Achterberg,
the Osi/Gurobi link has been written primarily by Stefan Vigerske,
the Osi/Mosek link has been written primarily by Bo Jensen, and
the Osi/Xpress link has been written primarily by John Doe.
Matthew Saltzman is the COIN-OR project leader for OSI.

For more information we refer to the OSI web site \texttt{https://projects.coin-or.org/Osi}.

\subsection{Model requirements}

The OSI links support linear equations and continuous, binary, and integer variables.
Semicontinuous and Semiinteger variables, special ordered sets, branching priorities, and indicator constraints are not supported by OSI.

\subsection{Usage of these links}

The following statement can be used inside your GAMS program to specify using CoinGurobi
\begin{verbatim}
  Option MIP = CoinGurobi;     { or LP or RMIP }
\end{verbatim}

The above statement should appear before the Solve statement.

The links only support the general GAMS options reslim, optca (except for Gurobi), optcr, nodlim, and iterlim.
In addition an option file in the format required by the solver can be provided via the GAMS optfile option.

\chapterend
