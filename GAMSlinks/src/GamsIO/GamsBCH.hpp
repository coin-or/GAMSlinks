// Copyright (C) GAMS Development 2007
// All Rights Reserved.
// This code is published under the Common Public License.
//
// $Id$
//
// Author: Stefan Vigerske

#ifndef GAMSBCH_HPP_
#define GAMSBCH_HPP_

#include "GAMSlinksConfig.h"
// from CoinUtils
#include "CoinPragma.hpp"

#include <vector>

// lets see, maybe we can make this optional later in order to allow smag also
#include "GamsModel.hpp"
#include "GamsOptions.hpp"

/** Interface to GAMS BCH facility.
 * To use this interface, it is assumed that you have initialized the GDX I/O library (use gdxGetReady or gdxCreate).
 */
class GamsBCH {
public:
	/** Structure to store a Cut generated by a Gams BCH cut generator.
	 */
	class Cut {
	public:
		double lb;
		double ub;
		int nnz;
		int* indices;
		double* coeff;
		
		Cut();
		~Cut();
	};
	
private:
	GamsModel& gm;
	GamsOptions& opt;

	struct dictRec* dict;
	
	/* storage of size iolib.ncols for node relaxation solution */
  double    *node_x;
	/* storage of size iolib.ncols for node lower bound */
  double    *node_lb;
	/* storage of size iolib.ncols for node upper bound */
  double    *node_ub;

  bool have_incumbent;
  bool new_incumbent;
	/* storage of size iolib.ncols for incumbent solution */
  double    *incumbent;
	/* storage of size iolib.ncols for global lower bounds */
  double    *global_lb;
	/* storage of size iolib.ncols for global upper bounds */
  double    *global_ub;
  
  bool       userkeep;       /* indicator for running gamskeep */

  int       heurfreq;       /* heuristic frequency */
  int       heurinterval;
  int       heurmult;
  int       heurfirst;      /* heuristic at first nodes */
  int       heurnewint;     /* heuristic if new incumbent */
  int       heurobjfirst;   /* heurisitc at first nodes if node obj is good */
  char      heurcall[1024];      /* command line minus gams for the heuristic */

  char      cutcall[1024];       /* command line minus gams for the cut generation */
  int       cutfreq;        /* cut frequency */
  int       cutinterval;
  int       cutmult;
  int       cutfirst;       /* cuts at first nodes */
  bool      cutnewint;      /* cuts if new incumbent */

//  char      *incbcall;      /* command line minus gams for the incumbent callback */
//  char      *incbicall;     /* command line minus gams for the information incumbent callback */

  char      userjobid[1024];     /* jobid added to gdxname, gdxnameinc, usergdxin, adds --userjobid to the calls and o and lf */

  char      gdxname[1024];       /* GDX file name for solution read by the GAMS models */
  char      gdxnameinc[1024];    /* GDX file name for incumbent read by the GAMS models */
  char      usergdxin[1024];     /* GDX file name for reading stuff back */
	
	int       ncalls;

	void init();
	
	void translateToGamsSpaceX(const double* x_, double objval_, double* x);
	void translateToGamsSpaceLB(const double* lb_, double* lb);
	void translateToGamsSpaceUB(const double* ub_, double* ub);
	void translateFromGamsSpaceX(const double* x_, double* x);

public:	
	GamsBCH(GamsModel& gm_, GamsOptions& opt_);

	~GamsBCH();
	
	/** The global bounds are initialized with the one taken from the GamsModel.
	 * But you can use this routine to overwrite them, if convenient.
	 */
	void setGlobalBounds(const double* lb_, const double* ub_);

	/** Sets the solution and bounds of the current node.
	 * Should be called before generateCuts() and runHeuristics().
	 */
	void setNodeSolution(const double* x_, double objval_, const double* lb_, const double* ub_);

	/** Informs BCH about the current incumbent.
	 * Should be called before generateCuts() and runHeuristics().
	 * Checks whether the objective value changed, and does nothing if its the same.
	 */
	void setIncumbentSolution(const double* x_, double objval_);
	
	/** Returns true if generateCuts should be called, otherwise false.
	 * You should call this method before generateCuts().
	 */
	bool doCuts();
	
	/** Calls the GAMS cut generator.
	 * Note, that you need to set the solution of the current nodes relaxation with.
	 * Note, that you should call this method only if doCuts() returned true.
	 * @return True, if everything worked fine (even though we might not have found cuts), false if something went wrong.
	 */
	bool generateCuts(std::vector<Cut>& cuts);
	
	/** Returns true if runHeuristic should be called, otherwise false.
	 * You should call this method before doHeuristic().
	 */
	bool doHeuristic(double bestbnd, double curobj);

	/** Calls the GAMS heuristic.
	 * @param x Space to store a solution.
	 * @param objvalue A double to store objective value of new solution.
	 * @return True, if a point has been found, false otherwise.  
	 */
	bool runHeuristic(double* x, double& objvalue);
};

#endif /*GAMSBCH_HPP_*/
