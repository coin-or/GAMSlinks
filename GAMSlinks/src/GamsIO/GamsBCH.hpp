// Copyright (C) GAMS Development 2007
// All Rights Reserved.
// This code is published under the Common Public License.
//
// $Id$
//
// Author: Stefan Vigerske

#ifndef GAMSBCH_HPP_
#define GAMSBCH_HPP_

#include "GAMSlinksConfig.h"
// from CoinUtils
#include "CoinPragma.hpp"

#include <vector>

// lets see, maybe we can make this optional later in order to allow smag also
#include "GamsModel.hpp"

/** Interface to GAMS BCH facility.
 */
class GamsBCH {
public:
	/** Structure to store a Cut generated by a Gams BCH cut generator.
	 */
	class Cut {
	public:
		double lb;
		double ub;
		int nnz;
		int* indices;
		double* coeff;
		
		Cut();
		~Cut();
	};
	
private:
	GamsModel& gm;

	struct dictRec* dict;
	
	/* storage of size iolib.ncols for node relaxation solution */
  double    *node_x;
	/* storage of size iolib.ncols for node lower bound */
  double    *node_lb;
	/* storage of size iolib.ncols for node upper bound */
  double    *node_ub;

  bool have_incumbent;
	/* storage of size iolib.ncols for incumbent solution */
  double    *incumbent;
	/* storage of size iolib.ncols for global lower bounds */
  double    *global_lb;
	/* storage of size iolib.ncols for global upper bounds */
  double    *global_ub;
  
  bool       userkeep;       /* indicator for running gamskeep */

//  int       heurfreq;       /* heuristic frequency */
//  int       heurinterval;
//  int       heurmult;
//  int       heurfirst;      /* heuristic at first nodes */
//  int       heurnewint;     /* heuristic if new incumbent */
//  int       heurobjfirst;   /* heurisitc at first nodes if node obj is good */
//  char      *heurcall;      /* command line minus gams for the heuristic */

  char      cutcall[1024];       /* command line minus gams for the cut generation */
  int       cutfreq;        /* cut frequency */
  int       cutinterval;
  int       cutmult;
  int       cutfirst;       /* cuts at first nodes */
  bool      cutnewint;      /* cuts if new incumbent */

//  char      *incbcall;      /* command line minus gams for the incumbent callback */
//  char      *incbicall;     /* command line minus gams for the information incumbent callback */

//  char      *userprefix[1024];    /* prefix gdxname, gdxnameinc, and usergdxin */
  char      userjobid[1024];     /* jobid added to gdxname, gdxnameinc, usergdxin, adds --userjobid to the calls and o and lf */

//  int       objvar;         /* index of objective variables */
//  int       objrow;         /* index of objective row, if there is one, otherwise -1 */
//  double    objvarcoef;     /* objective variable coefficient */
//  double    lastincumbent;  /* last incumbent */
//  int       numcols;        /* number of variables */
  char      gdxname[1024];       /* GDX file name for solution read by the GAMS models */
  char      gdxnameinc[1024];    /* GDX file name for incumbent read by the GAMS models */
  char      usergdxin[1024];     /* GDX file name for reading stuff back */
	
	int ncalls;

	
	void init();
	
	void translateToGamsSpaceX(const double* x_, double objval_, double* x);
	void translateToGamsSpaceLB(const double* lb_, double* lb);
	void translateToGamsSpaceUB(const double* ub_, double* ub);
	
public:	
	GamsBCH(GamsModel& gm_);

	~GamsBCH();
	
	/** The global bounds are initialized with the one taken from the GamsModel.
	 * But you can use this routine to overwrite them, if convenient.
	 */
	void setGlobalBounds(const double* lb_, const double* ub_);

	void setNodeSolution(const double* x_, double objval_, const double* lb_, const double* ub_);
	void setIncumbentSolution(const double* x_, double objval_);
	
	/** Calls the GAMS cut generator.
	 * Note, that you need to set the solution of the current nodes relaxation with.
	 */
	bool generateCuts(std::vector<Cut>& cuts);
};

#endif /*GAMSBCH_HPP_*/
