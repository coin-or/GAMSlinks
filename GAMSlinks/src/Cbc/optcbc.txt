introduction
GAMS/CoinCBC brings the open source LP/MIP solver Cbc from the COIN-OR foundation to the broad audience of GAMS users.<BR>
CBC (COIN-OR branch and cut) is an open-source mixed integer programming solver working with the COIN-OR LP solver CLP and the COIN-OR Cut generator libraries CGL.
The code has been written primarily by John J. Forrest, who is the COIN-OR project leader for CBC.
The GAMS interface for Cbc is maintained by Stefan Vigerske, Humboldt-University Berlin, in a separate COIN-OR project called GAMSLinks.<BR>
For more information visit the web site for
<a href="http://www.coin-or.org">COIN-OR</a>,
<a href="https://projects.coin-or.org/Cbc">Cbc<a>,
<a href="https://projects.coin-or.org/Cgl">Cgl<a>,
<a href="https://projects.coin-or.org/Clp">Clp<a>, and  
<a href="https://projects.coin-or.org/GAMSlinks">GAMSlinks</a>.<BR>
For documentation of GAMS parameters, see the <A href="http://www.gams.com/docs/parame.htm">GAMS parameters documentation</A>.<BR><BR>
CBC implements a branch and cut algorithm.
There are many parameters which can affect the performance.<BR>
First just try with default settings and look carefully at the log file.<BR>
Did cuts help? Did they take too long? Look at the output to see which cuts were effective and then do some tuning (see the option cuts).<BR>
If the pre-processing reduced the size of the problem or strengthened many coefficients then it is probably wise to leave it on.<BR>
Switch off heuristics which did not provide solutions.<BR>
The other major area to look at is the search.
Hopefully good solutions were obtained fairly early in the search so the important point is to select the best variable to branch on.
See whether strong branching did a good job - or did it just take a lot of iterations.
Adjust the options strongbranching and trustpseudocosts.


iterlim
For an LP, this is the maximum number of iterations to solve the LP.
For a MIP, this option is ignored.


reslim
Maximum time in seconds.


special
This parameter let you specify CBC options which are not supported by the GAMS/CoinCBC interface.<BR>
The string value given to this parameter is split up into parts at each space and added to the array of parameters given to CBC (in front of the -solve command).
Hence, you can use it like the command line parameters for the CBC standalone version.


writemps
Write the problem formulation in MPS format.
The parameter value is the name of the MPS file.


idiotcrash
This is a type of `crash' which works well on some homogeneous problems.
It works best on problems with unit elements and right hand sides but will do something to any model.
It should only be used before the primal simplex algorithm.<BR>
A positive number determines the number of passes that idiotcrash is called.


idiotcrash.'-1'
Let CLP decide by itself whether to use it.


idiotcrash.0
Switch this method off.


sprintcrash
For long and thin problems this method may solve a series of small problems created by taking a subset of the columns.
Cplex calls it `sifting'.
A positive number determines the number of passes that sprintcrash is called.


sprintcrash.'-1'
Let CLP decide by itself whether to use it.


sprintcrash.0
Switch this method off.


sifting
Synonym for <a href="#sprintcrash">sprintcrash</a>.


crash
Determines whether CLP should use a crash algorithm to find a dual feasible basis.


crash.off
Switch off the creation of dual feasible basis by the crash method.


crash.on
Switch on the creation of dual feasible basis by the crash method.


crash.solow_halim
Switch on a crash variant due to Solow and Halim.


crash.halim_solow
Switch on a crash variant due to Solow and Halim with modifications of John J. Forrest.


maxfactor
Maximum number of iterations between refactorizations in CLP.<BR>
If this is left at the default value of 200 then CLP will guess at a value to use.
CLP may decide to refactorize earlier for accuracy.


crossover
Determines whether CLP should crossover to the simplex algorithm after the barrier algorithm finished.<BR>
Interior point algorithms do not obtain a basic solution.
This option will crossover to a basic solution suitable for ranging or branch and cut.
With the current state of the quadratic solver it may be a good idea to switch off the crossover for quadratic problems (and maybe presolve as well).
CLP does this.


crossover.0
Turn off crossover to simplex algorithm after barrier algorithm finished.


crossover.1
Turn on crossover to simplex algorithm after barrier algorithm finished.


dualpivot
Choice of the pivoting strategy in the dual simplex algorithm.


dualpivot.dantzig
Let CLP use the pivoting strategy due to Dantzig.


dualpivot.steepest
Let CLP use the steepest choice method.


dualpivot.partial
Let CLP use a variant of the steepest choice method which scans only a subset of the primal infeasibilities to select the pivot step.


dualpivot.auto
Let CLP use a variant of the steepest choice method which starts like partial, i.e., scans only a subset of the primal infeasibilities,
and later changes to full pricing when the factorization becomes denser.


primalpivot
Choice of the pivoting strategy in the primal simplex algorithm.


primalpivot.auto
Let CLP use a variant of the exact devex method.


primalpivot.exact
Let CLP use the exact devex method.


primalpivot.dantzig
Let CLP use the pivoting strategy due to Dantzig.


primalpivot.steepest
Let CLP use the steepest choice method.


primalpivot.partial
Let CLP use a variant of the exact devex method which scans only a subset of the primal infeasibilities to select the pivot step.


primalpivot.change
Let CLP initially use Dantzig pivot method until the factorization becomes denser.


primalpivot.sprint
Let CLP use the sprint pivot method.


perturbation
Determines whether CLP should perturb the problem before starting.
Perturbation helps to stop cycling, but CLP uses other measures for this.
However, large problems and especially ones with unit elements and unit right hand sides or costs benefit from perturbation.
Normally CLP tries to be intelligent, but you can switch this off.


perturbation.0
Turns off perturbation of LP.


perturbation.1
Turns on perturbation of LP.


scaling
Scaling can help in solving problems which might otherwise fail because of lack of accuracy.
It can also reduce the number of iterations.
It is not applied if the range of elements is small.
Both methods do several passes alternating between rows and columns using current scale factors from one and applying them to the other.


scaling.off
Turns off scaling.


scaling.equilibrium
Let CLP use an equilibrium based scaling method which uses the largest scaled element.


scaling.geometric
Let CLP use a geometric based scaling method which uses the squareroot of the product of largest and smallest element.


scaling.auto
Let CLP choose the scaling method automatically.
It decides for one of these methods depending on which gives the better ratio of the largest element to the smallest one.


presolve
Presolve analyzes the model to find such things as redundant constraints, constraints which fix some variables, constraints which can be transformed into bounds, etc.
For the initial solve of any problem this is worth doing unless you know that it will have no effect.


presolve.0
Turns off the initial presolve.


presolve.1
Turns on the initial presolve.


tol_presolve
The tolerance used in presolve.


tol_dual
The maximum amount the dual constraints can be violated and still be considered feasible.


tol_primal
The maximum amount the primal constraints can be violated and still be considered feasible.


startalg
Determines the algorithm to use for an LP or the initial LP relaxation if the problem is a MIP.


startalg.primal
Let CLP use the primal simplex algorithm.


startalg.dual
Let CLP use the dual simplex algorithm.


startalg.barrier
Let CLP use a primal dual predictor corrector algorithm.


tol_integer
For an optimal solution, no integer variable may be farther than this from an integer value.


mipstart
This option controls the use of advanced starting values for mixed integer programs.
A setting of 1 indicates that the variable level values should be checked to see if they provide an integer feasible solution before starting optimization.


mipstart.0
Do not use the initial variable levels.


mipstart.1
Try to use the initial variable levels as a MIP starting solution.


sollim
A limit on number of feasible solutions that CBC should find for a MIP.


sollim.'-1'
No limit on the number of feasible solutions.


strongbranching
Determines the number of variables to look at in strong branching.<BR>
In order to decide which variable to branch on, the code will choose up to this number of unsatisfied variables and try minimal up and down branches.
The most effective one is chosen.
If a variable is branched on many times then the previous average up and down costs may be used - see the <a href="#trustpseudocosts">option trustpseudocosts</a>.


trustpseudocosts
Using strong branching computes pseudo-costs.
This parameter determines after how many branches for a variable we just trust the pseudo costs and do not do any more strong branching.


coststrategy
This parameter influence the branching variable selection.<BR>
If turned on, then the variables are sorted in order of their absolute costs, and branching is done first on variables with largest cost.
This primitive strategy can be surprisingly effective.


coststrategy.off
Turns off a specific cost strategy.


coststrategy.priorities
Assigns highest priority to variables with largest absolute cost.


coststrategy.columnorder
Assigns the priorities 1, 2, 3,.. with respect to the column ordering.


coststrategy.binaryfirst
Handles two sets of priorities such that binary variables get high priority.


coststrategy.binarylast
Handles two sets of priorities such that binary variables get low priority.


coststrategy.length
Assigns high priority to variables that are at most nonzero.


nodestrategy
This determines the strategy used to select the next node from the branch and cut tree.


nodestrategy.hybrid
Let CBC do first a breath search on nodes with a small depth in the tree and then switch to choose nodes with fewest infeasibilities.


nodestrategy.fewest
This will let CBC choose the node with the fewest infeasibilities.


nodestrategy.depth
This will let CBC always choose the node deepest in tree.
It gives minimum tree size but may take a long time to find the best solution.


nodestrategy.upfewest
This will let CBC choose the node with the fewest infeasibilities and do up branches first.


nodestrategy.downfewest
This will let CBC choose the node with the fewest infeasibilities and do down branches first.


nodestrategy.updepth
This will let CBC choose the node deepest in tree and do up branches first.


nodestrategy.downdepth
This will let CBC choose the node deepest in tree and do down branches first.


preprocess
This option controls the MIP specific presolve routines.
They try to reduce the size of the model in a similar way to presolve and also try to strengthen the model.
This can be very useful and is worth trying.


preprocess.off
Turns off the presolve routines.


preprocess.on
Turns on the presolve routines.


preprocess.equal
Turns on the presolve routines and let CBC turn inequalities with more than 5 elements into equalities (cliques) by adding slack variables.


preprocess.equalall
Turns on the presolve routines and let CBC turn all inequalities into equalities by adding slack variables.


preprocess.sos
This option let CBC search for rows with upper bound 1 and where all nonzero coefficients are 1 and creates special ordered sets if the sets are not overlapping and all integer variables (except for at most one) are in the sets.


preprocess.trysos
This option is similar to sos, but allows any number integer variables to be outside of the sets.


threads
The option controls the multithreading feature of CBC.
To use multiple threads, set the number of threads you want.
It may be better to use one or two more than number of available CPUs.
If the value is 100+n, then n threads are used in sub-trees.
If the value is 200+n, then n threads are used for root cuts.
If the value is 300+n, then n threads are used for both.


printfrequency
Controls the number of nodes that are evaluated between status prints.


printfrequency.0
Automatic choice, which is 100 for large problems and 1000 for small problems.


increment
A valid solution must be at least this much better than last integer solution.<BR>
If this option is not set then it CBC will try and work one out.
E.g., if all objective coefficients are multiples of 0.01 and only integer variables have entries in objective then this can be set to 0.01.


nodelim
Maximum number of nodes that are considered in the Branch and Bound.


nodlim
Maximum number of nodes that are considered in the Branch and Bound.
This option is overwritten by nodelim, if set.


optca
Absolute optimality criterion for a MIP.
CBC stops if the gap between the best known solution and the best possible solution is less than this value.


optcr
Relative optimality criterion for a MIP.
CBC stops if the relative gap between the best known solution and the best possible solution is less than this value.


cutoff
CBC stops if the objective function values exceeds (in case of maximization) or falls below (in case of minimization) this value.


cutdepth
If the depth in the tree is a multiple of cutdepth, then cut generators are applied.<BR>
Cut generators may be off, on only at the root, on if they look useful, or on at some interval.
Setting this option to a positive value K let CBC call a cutgenerator on a node whenever the depth in the tree is a multiple of K.


cutdepth.'-1'
Does not turn on cut generators because the depth of the tree is a multiple of a value.


cut_passes_root
Determines the number of rounds that the cut generators are applied in the root node.<BR>
A negative value -n means that n passes are also applied if the objective does not drop.


cut_passes_tree
Determines the number of rounds that the cut generators are applied in the nodes of the tree other than the root node.<BR>
A negative value -n means that n passes are also applied if the objective does not drop.


cuts
A global switch to turn on or off the cutgenerators.<BR>
This can be used to switch on or off all default cut generators.
Then you can set individual ones off or on using the specific options.


cuts.off
Turns off all cut generators.


cuts.on
Turns on all default cut generators and CBC will try them in the branch and cut tree (see the <a href="#cutdepth">option cutdepth</a> on how to fine tune the behaviour).


cuts.root
Let CBC generate cuts only at the root node.


cuts.ifmove
Let CBC use cut generators in the tree if they look as if they are doing some good and moving the objective value.


cuts.forceon
Turns on all default cut generators and force CBC to use the cut generator at every node.


cliquecuts
Determines whether and when CBC should try to generate <a href="https://projects.coin-or.org/Cgl/wiki/CglClique">clique cuts</a>.
See the <a href="#cuts">option cuts</a> for an explanation on the different values.<BR>
Clique cuts are of the form "sum of a set of variables <= 1".<BR>
Reference: M. Eso, Parallel branch and cut for set partitioning, Cornell University, 1999.


flowcovercuts
Determines whether and when CBC should try to generate <a href="https://projects.coin-or.org/Cgl/wiki/CglFlowCover">flow cover cuts</a>.<BR>
See the <a href="#cuts">option cuts</a> for an explanation on the different values.<BR>
The flow cover cut generator generates lifted simple generalized flow cover inequalities.
Since flow cover inequalities are generally not facet-defining, they are lifted to obtain stronger inequalities.
Although flow cover inequalities requires a special problem structure to be generated, they are quite useful for solving general mixed integer linear programs.<BR>
Reference: Z. Gu, G.L. Nemhauser, M.W.P. Savelsbergh, Lifted flow cover inequalities for mixed 0-1 integer programs, Math. Programming A 85 (1999) 439-467.


gomorycuts
Determines whether and when CBC should try to generate <a href="https://projects.coin-or.org/Cgl/wiki/CglGomory">mixed-integer Gomory cuts</a>.<BR>
See the <a href="#cuts">option cuts</a> for an explanation on the different values.<BR>
Reference: Laurence A. Wolsey, Integer Programming, Wiley, John & Sons, (1998) 124-132.


knapsackcuts
Determines whether and when CBC should try to generate <a href="https://projects.coin-or.org/Cgl/wiki/CglKnapsackCover">knapsack cover cuts</a>.<BR>
See the <a href="#cuts">option cuts</a> for an explanation on the different values.<BR>
The knapsack cover cut generator looks for a series of different types of minimal covers.
If a minimal cover is found, it lifts the associated minimal cover inequality and adds the lifted cut to the cut set.<BR>
Reference: S. Martello, and P. Toth, Knapsack Problems, Wiley, 1990, p30.


liftandprojectcuts
Determines whether and when CBC should try to generate <a href="https://projects.coin-or.org/Cgl/wiki/CglLandP">lift and project cuts</a>.
They might be expensive to compute, thus they are switched off by default.<BR>
See the <a href="#cuts">option cuts</a> for an explanation on the different values.<BR>
Reference: E. Balas and M. Perregaard, A precise correspondence between lift-and-project cuts, simple disjunctive cuts, and mixed integer Gomory cuts for 0-1 programming. Math. Program., 94(203,Ser. B):221-245,2003.


mircuts
Determines whether and when CBC should try to generate <a href="https://projects.coin-or.org/Cgl/wiki/CglMixedIntegerRounding2">mixed integer rounding cuts</a>.<BR>
See the <a href="#cuts">option cuts</a> for an explanation on the different values.<BR>
Reference: H. Marchand and L. A. Wolsey, Aggregation and Mixed Integer Rounding to Solve MIPs, Operations Research, 49(3), (2001).


twomircuts
Determines whether and when CBC should try to generate <a href="https://projects.coin-or.org/Cgl/wiki/CglTwomir">two phase mixed integer rounding cuts</a>.<BR>
See the <a href="#cuts">option cuts</a> for an explanation on the different values.<BR>
Reference: S. Dash, and O. Guenluek, Valid Inequalities Based on Simple Mixed-integer Sets, to appear in Math. Programming.


probingcuts
Determines whether and when CBC should try to generate cuts based on <a href="https://projects.coin-or.org/Cgl/wiki/CglProbing">probing</a>.<BR>
Additional to the values for the <a href="#cuts">option cuts</a> three more values are possible here.<BR>
Reference: M. Savelsbergh, Preprocessing and Probing Techniques for Mixed Integer Programming Problems, ORSA Journal on Computing 6 (1994), 445.


probingcuts.off
Turns off Probing.


probingcuts.on
Turns on Probing and CBC will try it in the branch and cut tree (see the <a href="#cutdepth">option cutdepth</a> how to fine tune this behaviour).


probingcuts.root
Let CBC do Probing only at the root node.


probingcuts.ifmove
Let CBC do Probing in the tree if it looks as if it is doing some good and moves the objective value.


probingcuts.forceon
Turns on Probing and forces CBC to do Probing at every node.


probingcuts.forceonbut
Turns on Probing and forces CBC to call the cut generator at every node, but does only probing, not strengthening etc.


probingcuts.forceonstrong
If CBC is forced to turn Probing on at every node (by setting this option to force), but this generator produces no cuts, then it is actually turned on only weakly (i.e., just every now and then).
Setting forceonstrong forces CBC strongly to do probing at every node.

  
probingcuts.forceonbutstrong
This is like forceonstrong, but does only probing (column fixing) and turns off row strengthening, so the matrix will not change inside the branch and bound.


reduceandsplitcuts
Determines whether and when CBC should try to generate reduced and split cuts.<BR>
See the <a href="#cuts">option cuts</a> for an explanation on the different values.<BR>
Reduce and split cuts are variants of Gomory cuts.
Starting from the current optimal tableau, linear combinations of the rows of the current optimal simplex tableau are used for generating Gomory cuts.
The choice of the linear combinations is driven by the objective of reducing the coefficients of the non basic continuous variables in the resulting row.<BR>
Reference: K. Anderson, G. Cornuejols, and Yanjun Li, Reduce-and-Split Cuts: Improving the Performance of Mixed Integer Gomory Cuts, Management Science 51 (2005).


residualcapacitycuts
Determines whether and when CBC should try to generate <a href="https://projects.coin-or.org/Cgl/wiki/CglResidualCapacity">residual capacity cuts</a>.<BR>
See the <a href="#cuts">option cuts</a> for an explanation on the different values.<BR>
These inequalities are particularly useful for Network Design and Capacity Planning models.<BR>
References:<BR>
T.L. Magnanti, P. Mirchandani, and R. Vachani, The convex hull of two core capacitated network design problems, Math. Programming, 60 (1993), pp. 233-250.<BR>
A. Atamturk and D. Rajan, On splittable and unsplittable flow capacitated network design arc-set polyhedra, Math. Programming, 92 (2002), pp. 315-333.


heuristics
This parameter can be used to switch on or off all heuristics, except for the local tree search as it dramatically alters the search.
Then you can set individual ones off or on.


heuristics.0
Turns all MIP heuristics off.


heuristics.1
Turns all MIP heuristics on (except <a href="#localtreesearch">local tree search</a>).


combinesolutions
This parameter control the use of a heuristic which does branch and cut on the given problem by just using variables which have appeared in one or more solutions.
It is obviously only tried after two or more solutions.


combinesolutions.0
Turns the combine solutions heuristic off.


combinesolutions.1
Turns the combine solutions heuristic on.


feaspump
This parameter control the use of the feasibility pump heuristic at the root.<BR>
This is due to Fischetti and Lodi and uses a sequence of LPs to try and get an integer feasible solution.
Some fine tuning is available by the <a href="#feaspump_passes">option feaspump_passes</a>.<BR>
Reference: M. Fischetti, F. Glover, and A. Lodi, The feasibility pump, Math. Programming, 104 (2005), pp. 91-104.


feaspump.0
Turns the feasibility pump off.


feaspump.1
Turns the feasiblity pump on.


feaspump_passes
This fine tunes the feasibility pump heuristic by setting the number of passes.


greedyheuristic
This parameter control the use of a pair of greedy heuristic which will try to obtain a solution.
It may just fix a percentage of variables and then try a small branch and cut run.


greedyheuristic.on
Turns on the greedy heuristic.


greedyheuristic.root
Turns on the greedy heuristic only for the root node.


greedyheuristic.off
Turns off the greedy heuristic.


localtreesearch
This parameter control the use of a local search algorithm when a solution is found.<BR>
It is from Fischetti and Lodi and is not really a heuristic although it can be used as one (with limited functionality).
This heuristic is not controlled by the <a href="#heuristics">option heuristics</a>.<BR>
Reference: M. Fischetti and A. Lodi, Local Branching, Math. Programming B, 98 (2003), pp. 23-47.


localtreesearch.0
Turns the local tree search off.


localtreesearch.1
Turns the local tree search on.


rins
This parameter control the use of the relaxed induced neighborhood search heuristic.<BR>
This heuristic compares the current solution with the best incumbent, fixes all discrete variables with the same value, presolves the problem, and does a branch and bound for 200 nodes.<BR>
Reference: E. Danna, E. Rothberg, and C. Le Pape, Exploring relaxation induced neighborhoods to improve MIP solutions, Math. Programming, 102 (1) (2005), pp. 71-91.


rins.0
Turns the relaxed induced neighborhood search off.


rins.1
Turns the relaxed induced neighborhood search on.


roundingheuristic
This parameter control the use of a simple (but effective) rounding heuristic at each node of tree.


roundingheuristic.0
Turns the rounding heuristic off.


roundingheuristic.1
Turns the rounding heuristic on.


names
This option causes GAMS names for the variables and equations to be loaded into Cbc.
These names will then be used for error messages, log entries, and so forth.
Turning names off may help if memory is very tight.


names.0
Do not load variable and equation names.


names.1
Load variable and equation names.


userheurfreq
Determines the frequency of the heuristic model calls.


userheurmult
Determines the multiplier for the frequency of the heuristic model calls.


userheurinterval
Determines the interval when to apply the multiplier for the frequency of the heuristic model calls.
For example, for the first 100 (userheurinterval) nodes, the solver call every 10th (userheurfreq) node
the heuristic.
After 100 nodes, the frequency gets multiplied by 10 (userheurmult), so that for the next 100 node the solver calls the heuristic every 20th node.
For nodes 200-300, the heuristic get called every 40th node, for nodes 300-400 every 80th node and after node 400 every 100th node.


userheurfirst
Calls the heuristic for the first n nodes.


userheurobjfirst
Similar to userheurfirst but only calls the heuristic if the relaxed objective value promises a significant improvement of the current incumbent, i.e., the LP value of the node has to be closer to the best bound than the current incumbent.


userheurnewint
Calls the heuristic if the solver found a new integer feasible solution.


userheurnewint.1
Let CBC call the heuristic if a new integer feasible solution is found.


userheurnewint.0
Do not call heuristic because a new integer feasible solution is found.


userheurcall
The GAMS command line (minus the gams executable name) to call the heuristic.


usercutfreq
Determines the frequency of the cut generator model calls. 


usercutmult
Determines the multiplier for the frequency of the cut generator model calls.


usercutinterval
Determines the interval when to apply the multiplier for the frequency of the cut generator model calls.
See userheurinterval for details.


usercutfirst
Calls the cut generator for the first n nodes.


usercutnewint
Calls the cut generator if the solver found a new integer feasible solution.


usercutnewint.1
Let CBC call the cut generator if a new integer feasible solution is found.


usercutnewint.0
Do not call cut generator because a new integer feasible solution is found.


usercutcall
The GAMS command line (minus the gams executable name) to call the cut generator.


usergdxin
The name of the GDX file read back into CBC.


usergdxname
The name of the GDX file exported from the solver with the solution at the node.


usergdxnameinc
The name of the GDX file exported from the solver with the incumbent solution.


usergdxprefix
Prefixes to use for usergdxin, usergdxname, and usergdxnameinc.


userjobid
Postfixes to use for gdxname, gdxnameinc, and gdxin.


userkeep
Calls gamskeep instead of gams
