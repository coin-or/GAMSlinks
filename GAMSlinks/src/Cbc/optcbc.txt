introduction
GAMS/CoinCBC brings the open source LP/MIP solver Cbc from the COIN-OR foundation to the broad audience of GAMS users.
Cbc (COIN-OR branch and cut) is an open-source mixed integer programming solver working with the COIN-OR LP solver Clp and the COIN-OR Cut generator libraries Cgl.
The code has been written primarily by John J. Forrest, who is the COIN-OR project leader for Cbc.
The GAMS interface for Cbc is maintained by Stefan Vigerske, Humboldt University, in a separate COIN-OR project called GAMSLinks.<BR>
For more information visit the web site for
<a href="http://www.coin-or.org">COIN-OR</a>,
<a href="https://projects.coin-or.org/Cbc">Cbc<a>,
<a href="https://projects.coin-or.org/Cgl">Cgl<a>,
<a href="https://projects.coin-or.org/Clp">Clp<a>, and  
<a href="https://projects.coin-or.org/GAMSlinks">GAMSlinks</a>.<BR>
For documentation of GAMS parameters, see the <A href="http://www.gams.com/docs/parame.htm">GAMS parameters documentation</A>.


roundingheuristic
A simple rounding heuristic to find feasible solutions of the MIP.


roundingheuristic.0
rounding heuristic is not used


roundingheuristic.1
rounding heuristic is used


localsearch
A local search heuristic to find feasible solutions of the MIP.


strongbranching
If strong branching is switched on, then the maximum number of candidates to be evaluated for strong branching is set to 10 (if the problem has less then 5000 variables) or 5 (if the problem has more then 5000 variables).
If strong branching is switched off, the maximum number is set to 0. (However, Cbc reports still some (but less) strong branching operations.)


integerpresolve
If switched on, a preprocessing on the MIP will be performed.
The integer presolve also does probing, independent of the setting of the 'probing' parameter.<BR>
From the CglPreprocess description: 
This method uses other cut generators to strengthen cuts, establish that some cuts are redundant, fix variables and find relationships such as x + y == 1.
While cuts can be added at any time in the tree, some cuts are actually just stronger versions of existing ones.
They can thus replace the existing cuts rather than being added as new cuts. This is awkward in the tree but reasonable at the root node.


findsos
This option switches the identification for special ordered sets of type 1 in the integer preprocessing on.
Cbc then searches for rows with upper bound 1 and where all nonzero coefficients are 1.


cuts
Regulates the use of cut generator routines in Cbc.<BR>
If set to automatic, then the parameters for the single cut generators determine which are added.


probing
This option switches probing on as cut generator.<BR>
From the <A href="https://projects.coin-or.org/Cgl/wiki/CglProbing">CglProbing description</A>:
For selected integer variables (e.g. unsatisfied ones) the effect of setting them up or down is investigated.
Setting a variable up may in turn set other variables (continuous as well as integer).


gomorycuts
This options switches the generation of mixed integer Gomory Cuts on.


knapsackcuts
This options switches the generation of knapsack cover cuts on.<BR>
From the <A href="https://projects.coin-or.org/Cgl/wiki/CglKnapsackCover">CglKnapsackCover description</A>:
CglKnapsackCover looks for a series of different types of minimal covers.
If a minimal cover is found, it lifts the associated minimal cover inequality and adds the lifted cut to the cut set.


oddholecuts
This options switches the generation of odd hole cuts on.<BR>
From the <A href="https://projects.coin-or.org/Cgl/wiki/CglOddHole">CglOddHole description</A>:
This looks at all rows of type "sum x(i) <= 1 (or == 1)" (with x binary) and sees if there is an odd cycle cut.
This is then lifted by using the corresponding Chvatal cut, i.e. by summing up all rows in the cycle.
The right hand side will be odd and all odd coefficients can be reduced by one.
The constraint is
"sum even(j)*x(j) <= odd"
which can be replaced by
"sum (even(j)/2)*x(j) <= (odd-1.0)/2".
A similar cut can be generated for "sum x(i) >= 1". 


cliquecuts            
This options switches the generation of clique cuts on.
Clique cuts are of the form "sum of a set of variables <= 1".
Refer to the <A href="https://projects.coin-or.org/Cgl/wiki/CglClique">CglClique web page</A> for further information.


flowcovercuts
This options switches the generation of flow cover cuts on.<BR>
From the <A href="https://projects.coin-or.org/Cgl/wiki/CglFlowCover">CglFlowCover description</A>:
The Cgl Flow Cover Cut generator generates lifted simple generalized flow cover inequalities.
Since flow cover inequalities are generally not facet-defining, they are lifted to obtain stronger inequalities.
Although flow cover inequalities requires a special problem structure to be generated, they are quite useful for solving general mixed integer linear programs.


mircuts
This options switches the generation of mixed integer rounding cuts on.
Refer to the <A href="https://projects.coin-or.org/Cgl/wiki/CglMixedIntegerRounding2">CglMixedIntegerRounding2 web page</A> for further information.


redsplitcuts
This options switches the generation of reduce and split cuts on.<BR>
From the <A href="https://projects.coin-or.org/Cgl/wiki/CglRedSplit">CglRedSplit description</A>:
Reduce-and-Split cuts are variants of Gomory cuts:
Starting from the current optimal tableau, linear combinations of the rows of the current optimal simplex tableau are used for generating Gomory cuts.
The choice of the linear combinations is driven by the objective of reducing the coefficients of the non basic continuous variables in the resulting row. 


cutsonlyatroot
This option determines whether cuts should be generated only at the root node.


startalg
This option determines whether a primal or dual simplex algorithm should be used to solve the root node.


writemps
Write an MPS problem file.
The parameter value is the name of the MPS file.


integertolerance
An integer variable is deemed to be at an integral value if it is no further than the value of this parameter from the next integral value away.


printfrequency
This option controls the number of nodes evaluated between status prints.


nodecompare
This option determines the comparison method that is used to determine the tree search order.
The following documentation is taken from the <A href="http://www.coin-or.org/Cbc/ch03.html">Cbc manual</A>.


nodecompare.default
This is designed to do a mostly depth-first search until a solution has been found.
It then use estimates that are designed to give a slightly better solution.
If a reasonable number of nodes have been explored (or a reasonable number of solutions found), 
then this class will adopt a breadth-first search (i.e., making a comparison based strictly on objective function values) unless the tree is very large, in which case it will revert to depth-first search.


nodecompare.depth
This will always choose the node deepest in tree.
It gives minimum tree size but may take a long time to find the best solution.


nodecompare.objective
This will always choose the node with the best objective value.
This may give a very large tree.
It is likely that the first solution found will be the best and the search should finish soon after the first solution is found.


reslim
Maximum time in seconds.


iterlim
For an LP, this is the maximum number of iterations to solve the LP.
For a MIP, this option is ignored.



nodelim
Maximum number of nodes that are considered in the Branch and Bound.


nodlim
Maximum number of nodes that are considered in the Branch and Bound.
This option is overwritten by nodelim, if set.


optca
Absolute optimality criterion for a MIP.
Cbc stops if the gap between the best known solution and the best possible solution is less than this value.


optcr
Relative optimality criterion for a MIP.
Cbc stops if the relative gap between the best known solution and the best possible solution is less than this value.


cutoff
Cbc stops if the objective function values exceeds (in case of maximization) or falls below (in case of minimization) this value.
