/* Copyright (C) GAMS Development 2009
   All Rights Reserved.
   This code is published under the Common Public License.

   $Id$

   Author:  Lutz Westermann
*/

/*  C code generated by apiwrapper */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <ctype.h>
#include <errno.h>

#define GEV_MAIN
#include "gevmcc.h"

#if defined(_WIN32)
# include <windows.h>
  static char winErr[] = "Windows error";
  typedef HINSTANCE soHandle_t;
#elif defined(CIA_HP7)
# include <unistd.h>
# include <dl.h>
  typedef shl_t soHandle_t;
#else
# include <unistd.h>
# include <dlfcn.h>
  typedef void *soHandle_t;
#endif

static soHandle_t h;
static int isLoaded = 0;
static int objectCount = 0;
static int ScreenIndicator = 1;
static int ExceptionIndicator = 0;
static int ExitIndicator = 1;
static gevErrorCallback_t ErrorCallBack = NULL;
static int APIErrorCount = 0;

typedef void (GEV_CALLCONV *gevXCreate_t) (gevHandle_t *pgev);
static GEV_FUNCPTR(gevXCreate);
typedef void (GEV_CALLCONV *gevXFree_t)   (gevHandle_t *pgev);
static GEV_FUNCPTR(gevXFree);
typedef int (GEV_CALLCONV *gevXAPIVersion_t) (int api, char *msg, int *cl);
static GEV_FUNCPTR(gevXAPIVersion);
typedef int (GEV_CALLCONV *gevXCheck_t) (const char *ep, int nargs, int s[], char *msg);
static GEV_FUNCPTR(gevXCheck);

#define printNoReturn(f,nargs) { \
  char d_msgBuf[256]; \
  strcpy(d_msgBuf,#f " could not be loaded: "); \
  gevXCheck(#f,nargs,d_s,d_msgBuf+strlen(d_msgBuf)); \
  gevErrorHandling(d_msgBuf); \
}
#define printAndReturn(f,nargs,rtype) { \
  char d_msgBuf[256]; \
  strcpy(d_msgBuf,#f " could not be loaded: "); \
  gevXCheck(#f,nargs,d_s,d_msgBuf+strlen(d_msgBuf)); \
  gevErrorHandling(d_msgBuf); \
  return (rtype) 0; \
}

int  GEV_CALLCONV d_gevInitEnvironmentLegacy (gevHandle_t pgev, const char *cntrfile)
{ int d_s[]={3,11}; printAndReturn(gevInitEnvironmentLegacy,1,int ) }

void  GEV_CALLCONV d_gevRegisterWriteCallback (gevHandle_t pgev, Tgevlswrite_t lsw, int logenabled, void *usrmem)
{ int d_s[]={0,59,15,1}; printNoReturn(gevRegisterWriteCallback,3) }

void  GEV_CALLCONV d_gevCompleteEnvironment (gevHandle_t pgev, void *pA, void *ivec, void *rvec, void *svec)
{ int d_s[]={0,1,1,1,1}; printNoReturn(gevCompleteEnvironment,4) }

int  GEV_CALLCONV d_gevSwitchLogStat (gevHandle_t pgev, int lo, const char *logfn, int logappend, const char *statfn, Tgevlswrite_t lsw, void *usrmem, void **lshandle)
{ int d_s[]={15,3,11,15,11,59,1,2}; printAndReturn(gevSwitchLogStat,7,int ) }

int  GEV_CALLCONV d_gevRestoreLogStat (gevHandle_t pgev, void **lshandle)
{ int d_s[]={15,2}; printAndReturn(gevRestoreLogStat,1,int ) }

void  GEV_CALLCONV d_gevLog (gevHandle_t pgev, const char *s)
{ int d_s[]={0,11}; printNoReturn(gevLog,1) }

void  GEV_CALLCONV d_gevLogPChar (gevHandle_t pgev, const char *p)
{ int d_s[]={0,9}; printNoReturn(gevLogPChar,1) }

void  GEV_CALLCONV d_gevStat (gevHandle_t pgev, const char *s)
{ int d_s[]={0,11}; printNoReturn(gevStat,1) }

void  GEV_CALLCONV d_gevStatPChar (gevHandle_t pgev, const char *p)
{ int d_s[]={0,9}; printNoReturn(gevStatPChar,1) }

void  GEV_CALLCONV d_gevStatAudit (gevHandle_t pgev, const char *s)
{ int d_s[]={0,11}; printNoReturn(gevStatAudit,1) }

void  GEV_CALLCONV d_gevStatCon (gevHandle_t pgev)
{ int d_s[]={0}; printNoReturn(gevStatCon,0) }

void  GEV_CALLCONV d_gevStatCoff (gevHandle_t pgev)
{ int d_s[]={0}; printNoReturn(gevStatCoff,0) }

void  GEV_CALLCONV d_gevStatEOF (gevHandle_t pgev)
{ int d_s[]={0}; printNoReturn(gevStatEOF,0) }

void  GEV_CALLCONV d_gevStatSysout (gevHandle_t pgev)
{ int d_s[]={0}; printNoReturn(gevStatSysout,0) }

void  GEV_CALLCONV d_gevStatAddE (gevHandle_t pgev, int num, const char *s)
{ int d_s[]={0,3,11}; printNoReturn(gevStatAddE,2) }

void  GEV_CALLCONV d_gevStatAddV (gevHandle_t pgev, int num, const char *s)
{ int d_s[]={0,3,11}; printNoReturn(gevStatAddV,2) }

void  GEV_CALLCONV d_gevStatAddJ (gevHandle_t pgev, int num1, int num2, const char *s)
{ int d_s[]={0,3,3,11}; printNoReturn(gevStatAddJ,3) }

void  GEV_CALLCONV d_gevStatEject (gevHandle_t pgev)
{ int d_s[]={0}; printNoReturn(gevStatEject,0) }

void  GEV_CALLCONV d_gevStatEdit (gevHandle_t pgev, const char C)
{ int d_s[]={0,18}; printNoReturn(gevStatEdit,1) }

void  GEV_CALLCONV d_gevStatC (gevHandle_t pgev, const char *s)
{ int d_s[]={0,11}; printNoReturn(gevStatC,1) }

void  GEV_CALLCONV d_gevStatE (gevHandle_t pgev, const char *s1, int num, const char *s2)
{ int d_s[]={0,11,3,11}; printNoReturn(gevStatE,3) }

void  GEV_CALLCONV d_gevStatV (gevHandle_t pgev, const char *s1, int num, const char *s2)
{ int d_s[]={0,11,3,11}; printNoReturn(gevStatV,3) }

void  GEV_CALLCONV d_gevStatT (gevHandle_t pgev)
{ int d_s[]={0}; printNoReturn(gevStatT,0) }

void  GEV_CALLCONV d_gevStatA (gevHandle_t pgev, const char *s)
{ int d_s[]={0,11}; printNoReturn(gevStatA,1) }

void  GEV_CALLCONV d_gevStatB (gevHandle_t pgev, const char *s)
{ int d_s[]={0,11}; printNoReturn(gevStatB,1) }

void  GEV_CALLCONV d_gevLogStat (gevHandle_t pgev, const char *s)
{ int d_s[]={0,11}; printNoReturn(gevLogStat,1) }

void  GEV_CALLCONV d_gevLogStatPChar (gevHandle_t pgev, const char *p)
{ int d_s[]={0,9}; printNoReturn(gevLogStatPChar,1) }

int  GEV_CALLCONV d_gevLicenseCheck (gevHandle_t pgev, int m, int n, int nz, int nlnz, int ndisc)
{ int d_s[]={15,3,3,3,3,3}; printAndReturn(gevLicenseCheck,5,int ) }

int  GEV_CALLCONV d_gevLicenseCheckSubSys (gevHandle_t pgev, char *msg, const char *Lcode)
{ int d_s[]={15,12,11}; printAndReturn(gevLicenseCheckSubSys,2,int ) }

int  GEV_CALLCONV d_gevLicenseCheckSubInternal (gevHandle_t pgev, char *msg, int subsysnum, const char *Lcode)
{ int d_s[]={15,12,3,11}; printAndReturn(gevLicenseCheckSubInternal,3,int ) }

int  GEV_CALLCONV d_gevLicenseQueryOption (gevHandle_t pgev, const char *cstr, const char *ostr, int *oval)
{ int d_s[]={15,11,11,4}; printAndReturn(gevLicenseQueryOption,3,int ) }

void  GEV_CALLCONV d_gevLicenseRegisterSystem (gevHandle_t pgev, int nsubsys, const char *codes, int checksum, int isglobal)
{ int d_s[]={0,3,11,3,3}; printNoReturn(gevLicenseRegisterSystem,4) }

int  GEV_CALLCONV d_gevLicenseGetMessage (gevHandle_t pgev, char *msg)
{ int d_s[]={15,12}; printAndReturn(gevLicenseGetMessage,1,int ) }

int  GEV_CALLCONV d_gevGetExecName (gevHandle_t pgev, const char *algid, char *execname)
{ int d_s[]={3,11,12}; printAndReturn(gevGetExecName,2,int ) }

int  GEV_CALLCONV d_gevGetSlvLibInfo (gevHandle_t pgev, const char *algid, char *libname, char *prefix, int *ifversion)
{ int d_s[]={3,11,12,12,4}; printAndReturn(gevGetSlvLibInfo,4,int ) }

int  GEV_CALLCONV d_gevCapabilityCheck (gevHandle_t pgev, int modeltype, const char *algid, int *check)
{ int d_s[]={3,3,11,4}; printAndReturn(gevCapabilityCheck,3,int ) }

char * GEV_CALLCONV d_gevGetAlg (gevHandle_t pgev, int modeltype, char *buf)
{ int d_s[]={12,3}; printAndReturn(gevGetAlg,1,char *) }

char * GEV_CALLCONV d_gevGetAlgDefault (gevHandle_t pgev, int modeltype, char *buf)
{ int d_s[]={12,3}; printAndReturn(gevGetAlgDefault,1,char *) }

double  GEV_CALLCONV d_gevTimeDiff (gevHandle_t pgev)
{ int d_s[]={13}; printAndReturn(gevTimeDiff,0,double ) }

double  GEV_CALLCONV d_gevTimeDiffStart (gevHandle_t pgev)
{ int d_s[]={13}; printAndReturn(gevTimeDiffStart,0,double ) }

void  GEV_CALLCONV d_gevTerminateInstall (gevHandle_t pgev)
{ int d_s[]={0}; printNoReturn(gevTerminateInstall,0) }

void  GEV_CALLCONV d_gevTerminateSet (gevHandle_t pgev, void *intr, void *ehdler)
{ int d_s[]={0,1,1}; printNoReturn(gevTerminateSet,2) }

int  GEV_CALLCONV d_gevTerminateGet (gevHandle_t pgev)
{ int d_s[]={15}; printAndReturn(gevTerminateGet,0,int ) }

int  GEV_CALLCONV d_gevGetIntOpt (gevHandle_t pgev, const char *optName)
{ int d_s[]={3,11}; printAndReturn(gevGetIntOpt,1,int ) }

double  GEV_CALLCONV d_gevGetDblOpt (gevHandle_t pgev, const char *optName)
{ int d_s[]={13,11}; printAndReturn(gevGetDblOpt,1,double ) }

char * GEV_CALLCONV d_gevGetStrOpt (gevHandle_t pgev, const char *optName, char *buf)
{ int d_s[]={12,11}; printAndReturn(gevGetStrOpt,1,char *) }

void  GEV_CALLCONV d_gevSetIntOpt (gevHandle_t pgev, const char *optName, int ival)
{ int d_s[]={0,11,3}; printNoReturn(gevSetIntOpt,2) }

void  GEV_CALLCONV d_gevSetDblOpt (gevHandle_t pgev, const char *optName, double rval)
{ int d_s[]={0,11,13}; printNoReturn(gevSetDblOpt,2) }

void  GEV_CALLCONV d_gevSetStrOpt (gevHandle_t pgev, const char *optName, const char *sval)
{ int d_s[]={0,11,11}; printNoReturn(gevSetStrOpt,2) }

void * GEV_CALLCONV d_gevGetOptHandle (gevHandle_t pgev)
{ int d_s[]={1}; printAndReturn(gevGetOptHandle,0,void *) }

void  GEV_CALLCONV d_gevSynchronizeOpt (gevHandle_t pgev, void *optr)
{ int d_s[]={0,1}; printNoReturn(gevSynchronizeOpt,1) }

char * GEV_CALLCONV d_gevGetScratchName (gevHandle_t pgev, const char *filename, char *buf)
{ int d_s[]={12,11}; printAndReturn(gevGetScratchName,1,char *) }

int  GEV_CALLCONV d_gevDumpControlLegacy (gevHandle_t pgev, const char *cfin, const char *cfout, void *gmoptr)
{ int d_s[]={3,11,11,1}; printAndReturn(gevDumpControlLegacy,3,int ) }

int  GEV_CALLCONV d_gevWriteSbbInfoLegacy (gevHandle_t pgev, const char *sbbfile, const char *rfile, int bounds, void *gmoptr)
{ int d_s[]={3,11,11,15,1}; printAndReturn(gevWriteSbbInfoLegacy,4,int ) }

int  GEV_CALLCONV d_gevDumpMatrixLegacy (gevHandle_t pgev, const char *mfout, void *gmoptr)
{ int d_s[]={3,11,1}; printAndReturn(gevDumpMatrixLegacy,2,int ) }

void GEV_CALLCONV d_gevSysDirSet (gevHandle_t pgev, const char *x)
{ int d_s[]={0,12}; printNoReturn(gevSysDirSet,1) }

void GEV_CALLCONV d_gevSkipIOLegacySet (gevHandle_t pgev, const int x)
{ int d_s[]={0,15}; printNoReturn(gevSkipIOLegacySet,1) }

/* return dirName on success, NULL on failure */
static char *
extractFileDirFileName (const char *fileName, char *dirName, char *fName)
{
  int fileNameLen, shave=0;
  const char *end, *s;
  char *t;

  if (NULL == fileName || NULL == dirName || fName == NULL) {
    return NULL;
  }
  fileNameLen = (int) strlen(fileName);

#if defined(_WIN32)
  /* get the last delimiter */
  for (end = fileName + fileNameLen - 1;
       end >= fileName && '\\' != *end && ':' != *end;  end--);
  /* shave off the trailing delimiter if:
   *  it isn't the first char,
   *  it is a backslash, and
   *  it is not preceded by a delimiter
   */
  if (end > fileName && '\\' == *end
   && (! ('\\' == *(end-1) || ':' == *(end-1)))
     ) {
    end--; shave=1;
  }
#else
  /* non-Windows: implicitly, this is the Unix version */
  /* get the last delimiter */
  for (end = fileName + fileNameLen - 1;
       end >= fileName && '/' != *end;  end--);

  if (end > fileName && '/' == *end) {
    end--; shave=1;
  }
#endif  /* if defined(_WIN32) */

  for (s = fileName, t = dirName;  s <= end;  s++, t++)
    *t = *s;
  *t = '\0';

  if (shave) s++;
  for (t = fName;  s <= fileName + fileNameLen - 1;  s++, t++)
    *t = *s;
  *t = '\0';

  return dirName;
} /* extractFileDirFileName */

static soHandle_t
loadLib (const char *libName, char **errMsg)
{
  soHandle_t h;
#if defined(CIA_HP7)
  int flag = 0;
#endif

#if defined(_WIN32)
  h = LoadLibrary (libName);
  if (NULL == h) {
    *errMsg = winErr;
  }
  else {
    *errMsg = NULL;
  }
#elif defined(CIA_HP7)
  flag = BIND_IMMEDIATE | BIND_VERBOSE | DYNAMIC_PATH;
  h = shl_load (libName, flag, 0L);
  if (NULL == h) {
    *errMsg = strerror(errno);
  }
  else {
    *errMsg = NULL;
  }
#else
  (void) dlerror();
  h = dlopen (libName, RTLD_NOW);
  if (NULL == h) {
    *errMsg = dlerror();
  }
  else {
    *errMsg = NULL;
  }
#endif

  return h;
} /* loadLib */

static int
unLoadLib (soHandle_t hh)
{
  int rc;

#if defined(_WIN32)
  rc = FreeLibrary (hh);
  return ! rc;
#elif defined(CIA_HP7)
  rc = shl_unload (hh);
#else
  rc = dlclose (hh);
#endif
  return rc;
} /* unLoadLib */

static void *
loadSym (soHandle_t h, const char *sym, char **errMsg)
{
  void *s;
  const char *from;
  char *to;
  const char *tripSym;
  char lcbuf[257];
  char ucbuf[257];
  size_t symLen;
  int trip;
#if defined(CIA_HP7)
  int rc;
#endif

  /* search in this order:
   *  1. lower
   *  2. original
   *  3. upper
   */

  symLen = 0;
  for (trip = 1;  trip <= 3;  trip++) {
    switch (trip) {
    case 1:                             /* lower */
      for (from = sym, to = lcbuf;  *from;  from++, to++) {
        *to = tolower(*from);
      }
      symLen = from - sym;
      lcbuf[symLen] = '\0';
      tripSym = lcbuf;
      break;
    case 2:                             /* original */
      tripSym = sym;
      break;
    case 3:                             /* upper */
      for (from = sym, to = ucbuf;  *from;  from++, to++) {
        *to = toupper(*from);
      }
      ucbuf[symLen] = '\0';
      tripSym = ucbuf;
      break;
    default:
      tripSym = sym;
    } /* end switch */
#if defined(_WIN32)
    s = GetProcAddress (h, tripSym);
    if (NULL != s) {
      return s;
    }
#elif defined(CIA_HP7)
    rc = shl_findsym (&h, tripSym, TYPE_UNDEFINED, &s);
    if (rc) {                     /* failure */
      *errMsg = strerror(errno);
    }
    else {                        /* success */
      *errMsg = NULL;
      return s;
    }
#else
    (void) dlerror();
    s = dlsym (h, tripSym);
    *errMsg = dlerror();
    if (NULL == *errMsg) {
      return s;
    }
#endif
  } /* end loop over symbol name variations */

  return NULL;
} /* loadSym */

/* TNAME = type name, ENAME = exported name */
#define LOADIT(TNAME,ENAME) symName = ENAME; TNAME = (TNAME##_t) loadSym (h, symName, &errMsg); if (NULL == TNAME) goto symMissing
#define LOADIT_ERR_OK(TNAME,ENAME) symName = ENAME; TNAME = (TNAME##_t) loadSym (h, symName, &errMsg)

#define BASENAME "libjoatdclib"
#if defined(CIA_DEX) || defined(CIA_LEX) || defined(CIA_WEX) || defined(CIA_SOX)
# define SUFFIX "64"
#else
# define SUFFIX ""
#endif
#if defined(_WIN32)
# undef BASENAME
# define BASENAME "joatdclib"
# define EXTENSION ".dll"
#elif defined(CIA_HP7)
# define EXTENSION ".sl"
#elif defined(CIA_DAR) || defined(CIA_DEX) || defined(CIA_DII)
# define EXTENSION ".dylib"
#else
# define EXTENSION ".so"
#endif

/* XLibraryLoad: return 0 on success, ~0 on failure */
static int
XLibraryLoad (const char *dllName, char *errBuf, int errBufSize)
{
  char *errMsg;
  char *symName;
  int rc, elen, cl;
  char *ebuf;

  if (isLoaded)
    return 0;
  h = loadLib (dllName, &errMsg);
  if (NULL == h) {
    if (NULL != errBuf) {
      elen = errBufSize;  ebuf = errBuf;
      rc = sprintf (ebuf, "%.*s", elen, "Could not load shared library ");
      elen -= rc;  ebuf+= rc;
      rc = sprintf (ebuf, "%.*s", elen, dllName);
      elen -= rc;  ebuf+= rc;
      rc = sprintf (ebuf, "%.*s", elen, ": ");
      elen -= rc;  ebuf+= rc;
      rc = sprintf (ebuf, "%.*s", elen, errMsg);
      elen -= rc;  ebuf+= rc;
      errBuf[errBufSize-1] = '\0';
    }
    return 1;
  }
  else {
     /* printf ("Loaded shared library %s successfully\n", dllName); */
    if (errBuf && errBufSize)
      errBuf[0] = '\0';
  }

  LOADIT(gevXCreate, "gevXCreate");
  LOADIT(gevXFree, "gevXFree");
  LOADIT(gevXCheck, "CgevXCheck");
  LOADIT(gevXAPIVersion, "CgevXAPIVersion");

  if (!gevXAPIVersion(2,errBuf,&cl))
    return 1;


#define CheckAndLoad(f,nargs,prefix) \
  if (!gevXCheck(#f,nargs,s,errBuf)) \
    f = &d_##f; \
  else { \
    LOADIT(f,prefix #f); \
  }
  {int s[]={3,11}; CheckAndLoad(gevInitEnvironmentLegacy,1,"C"); }
  {int s[]={0,59,15,1}; CheckAndLoad(gevRegisterWriteCallback,3,""); }
  {int s[]={0,1,1,1,1}; CheckAndLoad(gevCompleteEnvironment,4,""); }
  {int s[]={15,3,11,15,11,59,1,2}; CheckAndLoad(gevSwitchLogStat,7,"C"); }
  {int s[]={15,2}; CheckAndLoad(gevRestoreLogStat,1,""); }
  {int s[]={0,11}; CheckAndLoad(gevLog,1,"C"); }
  {int s[]={0,9}; CheckAndLoad(gevLogPChar,1,""); }
  {int s[]={0,11}; CheckAndLoad(gevStat,1,"C"); }
  {int s[]={0,9}; CheckAndLoad(gevStatPChar,1,""); }
  {int s[]={0,11}; CheckAndLoad(gevStatAudit,1,"C"); }
  {int s[]={0}; CheckAndLoad(gevStatCon,0,""); }
  {int s[]={0}; CheckAndLoad(gevStatCoff,0,""); }
  {int s[]={0}; CheckAndLoad(gevStatEOF,0,""); }
  {int s[]={0}; CheckAndLoad(gevStatSysout,0,""); }
  {int s[]={0,3,11}; CheckAndLoad(gevStatAddE,2,"C"); }
  {int s[]={0,3,11}; CheckAndLoad(gevStatAddV,2,"C"); }
  {int s[]={0,3,3,11}; CheckAndLoad(gevStatAddJ,3,"C"); }
  {int s[]={0}; CheckAndLoad(gevStatEject,0,""); }
  {int s[]={0,18}; CheckAndLoad(gevStatEdit,1,""); }
  {int s[]={0,11}; CheckAndLoad(gevStatC,1,"C"); }
  {int s[]={0,11,3,11}; CheckAndLoad(gevStatE,3,"C"); }
  {int s[]={0,11,3,11}; CheckAndLoad(gevStatV,3,"C"); }
  {int s[]={0}; CheckAndLoad(gevStatT,0,""); }
  {int s[]={0,11}; CheckAndLoad(gevStatA,1,"C"); }
  {int s[]={0,11}; CheckAndLoad(gevStatB,1,"C"); }
  {int s[]={0,11}; CheckAndLoad(gevLogStat,1,"C"); }
  {int s[]={0,9}; CheckAndLoad(gevLogStatPChar,1,""); }
  {int s[]={15,3,3,3,3,3}; CheckAndLoad(gevLicenseCheck,5,""); }
  {int s[]={15,12,11}; CheckAndLoad(gevLicenseCheckSubSys,2,"C"); }
  {int s[]={15,12,3,11}; CheckAndLoad(gevLicenseCheckSubInternal,3,"C"); }
  {int s[]={15,11,11,4}; CheckAndLoad(gevLicenseQueryOption,3,"C"); }
  {int s[]={0,3,11,3,3}; CheckAndLoad(gevLicenseRegisterSystem,4,"C"); }
  {int s[]={15,12}; CheckAndLoad(gevLicenseGetMessage,1,"C"); }
  {int s[]={3,11,12}; CheckAndLoad(gevGetExecName,2,"C"); }
  {int s[]={3,11,12,12,4}; CheckAndLoad(gevGetSlvLibInfo,4,"C"); }
  {int s[]={3,3,11,4}; CheckAndLoad(gevCapabilityCheck,3,"C"); }
  {int s[]={12,3}; CheckAndLoad(gevGetAlg,1,"C"); }
  {int s[]={12,3}; CheckAndLoad(gevGetAlgDefault,1,"C"); }
  {int s[]={13}; CheckAndLoad(gevTimeDiff,0,""); }
  {int s[]={13}; CheckAndLoad(gevTimeDiffStart,0,""); }
  {int s[]={0}; CheckAndLoad(gevTerminateInstall,0,""); }
  {int s[]={0,1,1}; CheckAndLoad(gevTerminateSet,2,""); }
  {int s[]={15}; CheckAndLoad(gevTerminateGet,0,""); }
  {int s[]={3,11}; CheckAndLoad(gevGetIntOpt,1,"C"); }
  {int s[]={13,11}; CheckAndLoad(gevGetDblOpt,1,"C"); }
  {int s[]={12,11}; CheckAndLoad(gevGetStrOpt,1,"C"); }
  {int s[]={0,11,3}; CheckAndLoad(gevSetIntOpt,2,"C"); }
  {int s[]={0,11,13}; CheckAndLoad(gevSetDblOpt,2,"C"); }
  {int s[]={0,11,11}; CheckAndLoad(gevSetStrOpt,2,"C"); }
  {int s[]={1}; CheckAndLoad(gevGetOptHandle,0,""); }
  {int s[]={0,1}; CheckAndLoad(gevSynchronizeOpt,1,""); }
  {int s[]={12,11}; CheckAndLoad(gevGetScratchName,1,"C"); }
  {int s[]={3,11,11,1}; CheckAndLoad(gevDumpControlLegacy,3,"C"); }
  {int s[]={3,11,11,15,1}; CheckAndLoad(gevWriteSbbInfoLegacy,4,"C"); }
  {int s[]={3,11,1}; CheckAndLoad(gevDumpMatrixLegacy,2,"C"); }
  {int s[]={0,12}; CheckAndLoad(gevSysDirSet,1,"C"); }
  {int s[]={0,15}; CheckAndLoad(gevSkipIOLegacySet,1,""); }

 return 0;

 symMissing:
  if (errBuf && errBufSize>0) {
    elen = errBufSize;  ebuf = errBuf;
    rc = sprintf (ebuf, "%.*s", elen, "Could not load symbol '");
    elen -= rc;  ebuf+= rc;
    rc = sprintf (ebuf, "%.*s", elen, symName);
    elen -= rc;  ebuf+= rc;
    rc = sprintf (ebuf, "%.*s", elen, "': ");
    elen -= rc;  ebuf+= rc;
    rc = sprintf (ebuf, "%.*s", elen, errMsg);
    elen -= rc;  ebuf+= rc;
    errBuf[errBufSize-1] = '\0';
    /* printf ("%s\n", errBuf); */
    return 2;
  }

 return 0;

} /* XLibraryLoad */

static int
libloader(const char *dllPath, const char *dllName, char *msgBuf, int msgBufSize)
{

  char dllNameBuf[512];
  int myrc = 0;

  if (NULL != msgBuf) msgBuf[0] = '\0';

  if (! isLoaded) {
    if (NULL != dllPath && '\0' != *dllPath) {
      strncpy(dllNameBuf, dllPath, sizeof(dllNameBuf)-1);
      dllNameBuf[sizeof(dllNameBuf)-2] = '\0';
#if defined(_WIN32)
      if ('\\' != dllNameBuf[strlen(dllNameBuf)])
        strcat(dllNameBuf,"\\");
#else
      if ('/' != dllNameBuf[strlen(dllNameBuf)])
        strcat(dllNameBuf,"/");
#endif
    }
    else {
      dllNameBuf[0] = '\0';
    }
    if (NULL != dllName && '\0' != *dllName) {
      strncat(dllNameBuf, dllName, sizeof(dllNameBuf)-strlen(dllNameBuf));
      dllNameBuf[sizeof(dllNameBuf)-1] = '\0';
    }
    else {
      strncat(dllNameBuf, BASENAME SUFFIX EXTENSION, sizeof(dllNameBuf)-strlen(dllNameBuf));
    }
    isLoaded = ! XLibraryLoad (dllNameBuf, msgBuf, msgBufSize);
    if (isLoaded) {
    }
    else {                              /* library load failed */
      myrc |= 1;
    }
  }
  return (myrc & 1) == 0;
}


/* gevGetReady: return false on failure to load library, true on success */
int gevGetReady (char *msgBuf, int msgBufSize)
{
  return libloader(NULL, NULL, msgBuf, msgBufSize);
} /* gevGetReady */

/* gevGetReadyD: return false on failure to load library, true on success */
int gevGetReadyD (const char *dirName, char *msgBuf, int msgBufSize)
{
  return libloader(dirName, NULL, msgBuf, msgBufSize);
} /* gevGetReadyD */

/* gevGetReadyL: return false on failure to load library, true on success */
int gevGetReadyL (const char *libName, char *msgBuf, int msgBufSize)
{
  char dirName[1024],fName[1024];
  extractFileDirFileName (libName, dirName, fName);
  return libloader(dirName, fName, msgBuf, msgBufSize);
} /* gevGetReadyL */

/* gevCreate: return false on failure to load library, true on success */
int gevCreate (gevHandle_t *pgev, char *msgBuf, int msgBufSize)
{
  int gevIsReady;

  gevIsReady = gevGetReady (msgBuf, msgBufSize);
  if (! gevIsReady) {
    return 0;
  }
  assert(gevXCreate);
  gevXCreate(pgev);
  if(pgev == NULL)
  { strcpy(msgBuf,"Error while creating object"); return 0; }
  objectCount++;
  return 1;                     /* return true on successful library load */
} /* gevCreate */

/* gevCreateD: return false on failure to load library, true on success */
int gevCreateD (gevHandle_t *pgev, const char *dirName,
                char *msgBuf, int msgBufSize)
{
  int gevIsReady;

  gevIsReady = gevGetReadyD (dirName, msgBuf, msgBufSize);
  if (! gevIsReady) {
    return 0;
  }
  assert(gevXCreate);
  gevXCreate(pgev);
  if(pgev == NULL)
  { strcpy(msgBuf,"Error while creating object"); return 0; }
  objectCount++;
  return 1;                     /* return true on successful library load */
} /* gevCreateD */

/* gevCreateL: return false on failure to load library, true on success */
int gevCreateL (gevHandle_t *pgev, const char *libName,
                char *msgBuf, int msgBufSize)
{
  int gevIsReady;

  gevIsReady = gevGetReadyL (libName, msgBuf, msgBufSize);
  if (! gevIsReady) {
    return 0;
  }
  assert(gevXCreate);
  gevXCreate(pgev);
  if(pgev == NULL)
  { strcpy(msgBuf,"Error while creating object"); return 0; }
  objectCount++;
  return 1;                     /* return true on successful library load */
} /* gevCreateL */

int gevFree   (gevHandle_t *pgev)
{
  assert(gevXFree);
  gevXFree(pgev); pgev = NULL;
  objectCount--;
  return 1;
} /* gevFree */

int gevLibraryLoaded(void)
{
  return isLoaded;
} /* gevLibraryLoaded */

int gevLibraryUnload(void)
{
  if (objectCount > 0)
    return 0;
  isLoaded = 0;
  (void) unLoadLib(h);
  return 1;
} /* gevLibraryUnload */

int gevGetScreenIndicator(void)
{
  return ScreenIndicator;
}

void gevSetScreenIndicator(int scrind)
{
  ScreenIndicator = scrind ? 1 : 0;
}

int gevGetExceptionIndicator(void)
{
   return ExceptionIndicator;
}

void gevSetExceptionIndicator(int excind)
{
  ExceptionIndicator = excind ? 1 : 0;
}

int gevGetExitIndicator(void)
{
  return ExitIndicator;
}

void gevSetExitIndicator(int extind)
{
  ExitIndicator = extind ? 1 : 0;
}

gevErrorCallback_t gevGetErrorCallback(void)
{
  return ErrorCallBack;
}

void gevSetErrorCallback(gevErrorCallback_t func)
{
  ErrorCallBack = func;
}

int gevGetAPIErrorCount(void)
{
  return APIErrorCount;
}

void gevSetAPIErrorCount(int ecnt)
{
  APIErrorCount = ecnt;
}

void gevErrorHandling(const char *msg)
{
  APIErrorCount++;
  if (ScreenIndicator) { printf("%s\n", msg); fflush(stdout); }
  if (ErrorCallBack)
     if (ErrorCallBack(APIErrorCount, msg)) exit(123);
  assert(!ExceptionIndicator);
  if (ExitIndicator) exit(123);
}

