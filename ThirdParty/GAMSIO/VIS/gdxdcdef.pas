unit gdxdcdef; { Delphi procedure wrapper generated by apiwrapper }

{$P- no open parameters ==> no maxlen byte}
{$V+ force var strings}
{$H- short only }

interface

uses
   {$I p3compat},
   gmsgen,gxdefs;

const dt_set   = 0;  { gdxSyType }
      dt_par   = 1;
      dt_var   = 2;
      dt_equ   = 3;
      dt_alias = 4;

const sv_valund  = 0;  { gdxSpecValue }
      sv_valna   = 1;
      sv_valpin  = 2;
      sv_valmin  = 3;
      sv_valeps  = 4;
      sv_normal  = 5;
      sv_acronym = 6;

type
   TErrorCallback = function(ErrCount:Integer; const Msg:ShortString):Integer; {$I decorate};
   TDataStoreProc = procedure(const Indx: TgdxUELIndex; const Vals: TgdxValues); {$I decorate};

//tries to load DLL from OS default location
//name for the DLL is automatic
function  gdxGetReady(var Msg: ShortString): boolean;
//tries to load DLL from main program directory; if that fails
//loads DLL from OS default location
//name for the DLL is automatic
function  gdxGetReadyX(var Msg: ShortString): boolean;
//loads DLL from specified directory
//name for the DLL is automatic
function gdxGetReadyD(const Dir: ShortString; var Msg: ShortString): boolean;
//loads DLL from the full path specified
//no changes are made to the name (platform and file extension)
function gdxGetReadyL(const LibName: ShortString; var Msg: ShortString): boolean;

//tries to load DLL from OS default location
//name for the DLL is automatic
function gdxCreate(var pgdx: pointer; var Msg: ShortString): boolean;
//tries to load DLL from main program directory; if that fails
//loads DLL from OS default location
//name for the DLL is automatic
function gdxCreateX(var pgdx: pointer; var Msg: ShortString): boolean;
//loads DLL from specified directory
//name for the DLL is automatic
function gdxCreateD(var pgdx: pointer; const Dir: ShortString; var Msg: shortString): boolean;
//loads DLL from the full path specified
function gdxCreateL(var pgdx: pointer; const LibName: ShortString; var Msg: shortString): boolean;

//creates handle from a given pointer
procedure gdxCreateHandle(pgdx: pointer; var mygdx: pointer);
//returns a handle
function  gdxGetHandle(pgdx: pointer): pointer;

procedure gdxFree  (var pgdx: pointer);
procedure gdxLibraryUnload;
function  gdxLibraryLoaded: boolean;

function  gdxGetScreenIndicator: boolean;
procedure gdxSetScreenIndicator(const ScrInd: boolean);
function  gdxGetExceptionIndicator: boolean;
procedure gdxSetExceptionIndicator(const ExcInd: boolean);
function  gdxGetExitIndicator: boolean;
procedure gdxSetExitIndicator(const ExtInd: boolean);
function  gdxGetErrorCount: Integer;
procedure gdxSetErrorCount(const ecnt: Integer);
function  gdxGetErrorCallback: TErrorCallback;
procedure gdxSetErrorCallback(ecb: TErrorCallback);
procedure gdxErrorHandling(const Msg: ShortString);

// functions and procedures
var gdxSetLoadPath          : procedure(const s: shortString); {$I decorate};
var gdxGetLoadPath          : procedure(var s: shortString); {$I decorate};
var gdxAcronymCount         : function (pgdx: pointer): Integer; {$I decorate};
var gdxAcronymGetInfo       : function (pgdx: pointer; N: Integer; var AName: ShortString; var Atext: ShortString; var Indx: Integer): Integer; {$I decorate};
var gdxAcronymIndex         : function (pgdx: pointer; V: Double): Integer; {$I decorate};
var gdxAcronymName          : function (pgdx: pointer; V: Double; var AName: ShortString): Integer; {$I decorate};
var gdxAcronymSetInfo       : function (pgdx: pointer; N: Integer; const AName: ShortString; const Atext: ShortString; Indx: Integer): Integer; {$I decorate};
var gdxAcronymValue         : function (pgdx: pointer; Indx: Integer): Double; {$I decorate};
var gdxAddAlias             : function (pgdx: pointer; const AName1: ShortString; const AName2: ShortString): Integer; {$I decorate};
var gdxAddSetText           : function (pgdx: pointer; const s: ShortString; var N: Integer): Integer; {$I decorate};
var gdxClose                : function (pgdx: pointer): Integer; {$I decorate};
var gdxDataErrorCount       : function (pgdx: pointer): Integer; {$I decorate};
var gdxDataErrorRecord      : function (pgdx: pointer; Rn: Integer; var AElements: TgdxUELIndex; var AVals: TgdxValues): Integer; {$I decorate};
var gdxDataReadDone         : function (pgdx: pointer): Integer; {$I decorate};
var gdxDataReadFilteredStart: function (pgdx: pointer; SyNr: Integer; const ADomainNrs: TgdxUELIndex; var NrRecs: Integer): Integer; {$I decorate};
var gdxDataReadMap          : function (pgdx: pointer; Rn: Integer; var AElements: TgdxUELIndex; var AVals: TgdxValues; var AFDim: Integer): Integer; {$I decorate};
var gdxDataReadMapStart     : function (pgdx: pointer; SyNr: Integer; var NrRecs: Integer): Integer; {$I decorate};
var gdxDataReadRaw          : function (pgdx: pointer; var AElements: TgdxUELIndex; var AVals: TgdxValues; var AFDim: Integer): Integer; {$I decorate};
var gdxDataReadRawStart     : function (pgdx: pointer; SyNr: Integer; var NrRecs: Integer): Integer; {$I decorate};
var gdxDataReadSlice        : function (pgdx: pointer; const AFiltElements: TgdxStrIndex; var ADim: Integer; DP: TDataStoreProc): Integer; {$I decorate};
var gdxDataReadSliceStart   : function (pgdx: pointer; ASyNr: Integer; var ANrElems: TgdxUELIndex): Integer; {$I decorate};
var gdxDataReadStr          : function (pgdx: pointer; var AStrElements: TgdxStrIndex; var AVals: TgdxValues; var AFDim: Integer): Integer; {$I decorate};
var gdxDataReadStrStart     : function (pgdx: pointer; SyNr: Integer; var NrRecs: Integer): Integer; {$I decorate};
var gdxDataSliceUELS        : function (pgdx: pointer; const AIndx: TgdxUELIndex; var AUELs: TgdxStrIndex): Integer; {$I decorate};
var gdxDataWriteDone        : function (pgdx: pointer): Integer; {$I decorate};
var gdxDataWriteMap         : function (pgdx: pointer; const AElements: TgdxUELIndex; const AVals: TgdxValues): Integer; {$I decorate};
var gdxDataWriteMapStart    : function (pgdx: pointer; const AName: ShortString; const Atext: ShortString; ADim: Integer; AType: Integer; AUserInfo: Integer): Integer; {$I decorate};
var gdxDataWriteRaw         : function (pgdx: pointer; const AElements: TgdxUELIndex; const AVals: TgdxValues): Integer; {$I decorate};
var gdxDataWriteRawStart    : function (pgdx: pointer; const AName: ShortString; const Atext: ShortString; ADim: Integer; AType: Integer; AUserInfo: Integer): Integer; {$I decorate};
var gdxDataWriteStr         : function (pgdx: pointer; const AStrElements: TgdxStrIndex; const AVals: TgdxValues): Integer; {$I decorate};
var gdxDataWriteStrStart    : function (pgdx: pointer; const AName: ShortString; const Atext: ShortString; ADim: Integer; AType: Integer; AUserInfo: Integer): Integer; {$I decorate};
var gdxGetDLLVersion        : function (pgdx: pointer; var V: ShortString): Integer; {$I decorate};
var gdxErrorCount           : function (pgdx: pointer): Integer; {$I decorate};
var gdxErrorStr             : function (pgdx: pointer; N: Integer; var s: ShortString): Integer; {$I decorate};
var gdxFileInfo             : function (pgdx: pointer; var FileVer: Integer; var ComprLev: Integer): Integer; {$I decorate};
var gdxFileVersion          : function (pgdx: pointer; var FileStr: ShortString; var ProduceStr: ShortString): Integer; {$I decorate};
var gdxFilterExists         : function (pgdx: pointer; N: Integer): Integer; {$I decorate};
var gdxFilterRegister       : function (pgdx: pointer; V: Integer): Integer; {$I decorate};
var gdxFilterRegisterDone   : function (pgdx: pointer): Integer; {$I decorate};
var gdxFilterRegisterStart  : function (pgdx: pointer; Nr: Integer): Integer; {$I decorate};
var gdxFindSymbol           : function (pgdx: pointer; const AName: ShortString; var AIx: Integer): Integer; {$I decorate};
var gdxGetElemText          : function (pgdx: pointer; N: Integer; var s: ShortString; var Node: Integer): Integer; {$I decorate};
var gdxGetLastError         : function (pgdx: pointer): Integer; {$I decorate};
var gdxGetSpecialValues     : function (pgdx: pointer; var AVals: TgdxSVals): Integer; {$I decorate};
var gdxGetUEL               : function (pgdx: pointer; UelNr: Integer; var s: ShortString): Integer; {$I decorate};
var gdxMapValue             : function (pgdx: pointer; D: Double; var sv: Integer): Integer; {$I decorate};
var gdxOpenRead             : function (pgdx: pointer; const Afn: ShortString; var ErrNr: Integer): Integer; {$I decorate};
var gdxOpenWrite            : function (pgdx: pointer; const Afn: ShortString; const AProducer: ShortString; var ErrNr: Integer): Integer; {$I decorate};
var gdxOpenWriteEx          : function (pgdx: pointer; const Afn: ShortString; const AProducer: ShortString; Compr: Integer; var ErrNr: Integer): Integer; {$I decorate};
var gdxResetSpecialValues   : function (pgdx: pointer): Integer; {$I decorate};
var gdxSetHasText           : function (pgdx: pointer; N: Integer): Integer; {$I decorate};
var gdxSetReadSpecialValues : function (pgdx: pointer; const AVals: TgdxSVals): Integer; {$I decorate};
var gdxSetSpecialValues     : function (pgdx: pointer; const AVals: TgdxSVals): Integer; {$I decorate};
var gdxSetTextNodeNr        : function (pgdx: pointer; N: Integer; Node: Integer): Integer; {$I decorate};
var gdxSetTraceLevel        : function (pgdx: pointer; N: Integer; const s: ShortString): Integer; {$I decorate};
var gdxSymbIndxMaxLength    : function (pgdx: pointer; SyNr: Integer; var DimInfo: TgdxUELIndex): Integer; {$I decorate};
var gdxSymbMaxLength        : function (pgdx: pointer): Integer; {$I decorate};
var gdxSymbolAddComment     : function (pgdx: pointer; SyNr: Integer; const s: ShortString): Integer; {$I decorate};
var gdxSymbolGetComment     : function (pgdx: pointer; SyNr: Integer; N: Integer; var s: ShortString): Integer; {$I decorate};
var gdxSymbolGetDomain      : function (pgdx: pointer; SyNr: Integer; var DomainIDs: TgdxUELIndex): Integer; {$I decorate};
var gdxSymbolInfo           : function (pgdx: pointer; SyNr: Integer; var AName: ShortString; var ADim: Integer; var ATyp: Integer): Integer; {$I decorate};
var gdxSymbolInfoX          : function (pgdx: pointer; SyNr: Integer; var ACount: Integer; var AUserInfo: Integer; var AExplTxt: ShortString): Integer; {$I decorate};
var gdxSymbolSetDomain      : function (pgdx: pointer; const DomainIDs: TgdxStrIndex): Integer; {$I decorate};
var gdxSystemInfo           : function (pgdx: pointer; var NrSy: Integer; var NrUel: Integer): Integer; {$I decorate};
var gdxUELMaxLength         : function (pgdx: pointer): Integer; {$I decorate};
var gdxUELRegisterDone      : function (pgdx: pointer): Integer; {$I decorate};
var gdxUELRegisterMap       : function (pgdx: pointer; UelNr: Integer; const Elem: ShortString): Integer; {$I decorate};
var gdxUELRegisterMapStart  : function (pgdx: pointer): Integer; {$I decorate};
var gdxUELRegisterRaw       : function (pgdx: pointer; const Elem: ShortString): Integer; {$I decorate};
var gdxUELRegisterRawStart  : function (pgdx: pointer): Integer; {$I decorate};
var gdxUELRegisterStr       : function (pgdx: pointer; const Elem: ShortString; var UelNr: Integer): Integer; {$I decorate};
var gdxUELRegisterStrStart  : function (pgdx: pointer): Integer; {$I decorate};
var gdxUMFindUEL            : function (pgdx: pointer; const s: ShortString; var EN: Integer; var UMap: Integer): Integer; {$I decorate};
var gdxUMUelGet             : function (pgdx: pointer; N: Integer; var s: ShortString; var UMap: Integer): Integer; {$I decorate};
var gdxUMUelInfo            : function (pgdx: pointer; var NrElem: Integer; var HighMap: Integer): Integer; {$I decorate};
var gdxCurrentDim           : function (pgdx: pointer): Integer; {$I decorate};
implementation

uses
   gmslibname;

const
   APIVersion     = 7;
   DLLWrapsObject = true;
   Debug          = false;

var
   LibHandle         : TLibHandle;
   LibFileName       : ShortString;
   ScreenIndicator   : Boolean = true;
   ExceptionIndicator: Boolean = false;
   ExitIndicator     : Boolean = false;
   ObjectCount       : Integer = 0;
   APIErrorCount     : Integer = 0;
   ErrorCallback     : TErrorCallback;

var XCreate: procedure (var pgdx: pointer); {$I decorate} ;
var XFree  : procedure (var pgdx: pointer); {$I decorate} ;

var XAPIVersion: function (const api: integer; var msg: ShortString; var comp: Integer): boolean; {$I decorate} ;
var XCheck: function (const funcn: shortString; const NrArg: integer; const sign: PIntegerArray; var msg: ShortString): boolean; {$I decorate};

Function  d_gdxAcronymCount(pgdx: pointer): Integer; {$I decorate};
begin
gdxErrorHandling('gdxAcronymCount could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxAcronymGetInfo(pgdx: pointer; N: Integer; var AName: ShortString; var Atext: ShortString; var Indx: Integer): Integer; {$I decorate};
begin
gdxErrorHandling('gdxAcronymGetInfo could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxAcronymIndex(pgdx: pointer; V: Double): Integer; {$I decorate};
begin
gdxErrorHandling('gdxAcronymIndex could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxAcronymName(pgdx: pointer; V: Double; var AName: ShortString): Integer; {$I decorate};
begin
gdxErrorHandling('gdxAcronymName could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxAcronymSetInfo(pgdx: pointer; N: Integer; const AName: ShortString; const Atext: ShortString; Indx: Integer): Integer; {$I decorate};
begin
gdxErrorHandling('gdxAcronymSetInfo could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxAcronymValue(pgdx: pointer; Indx: Integer): Double; {$I decorate};
begin
gdxErrorHandling('gdxAcronymValue could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0.0;
end;

Function  d_gdxAddAlias(pgdx: pointer; const AName1: ShortString; const AName2: ShortString): Integer; {$I decorate};
begin
gdxErrorHandling('gdxAddAlias could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxAddSetText(pgdx: pointer; const s: ShortString; var N: Integer): Integer; {$I decorate};
begin
gdxErrorHandling('gdxAddSetText could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxClose(pgdx: pointer): Integer; {$I decorate};
begin
gdxErrorHandling('gdxClose could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxDataErrorCount(pgdx: pointer): Integer; {$I decorate};
begin
gdxErrorHandling('gdxDataErrorCount could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxDataErrorRecord(pgdx: pointer; Rn: Integer; var AElements: TgdxUELIndex; var AVals: TgdxValues): Integer; {$I decorate};
begin
gdxErrorHandling('gdxDataErrorRecord could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxDataReadDone(pgdx: pointer): Integer; {$I decorate};
begin
gdxErrorHandling('gdxDataReadDone could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxDataReadFilteredStart(pgdx: pointer; SyNr: Integer; const ADomainNrs: TgdxUELIndex; var NrRecs: Integer): Integer; {$I decorate};
begin
gdxErrorHandling('gdxDataReadFilteredStart could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxDataReadMap(pgdx: pointer; Rn: Integer; var AElements: TgdxUELIndex; var AVals: TgdxValues; var AFDim: Integer): Integer; {$I decorate};
begin
gdxErrorHandling('gdxDataReadMap could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxDataReadMapStart(pgdx: pointer; SyNr: Integer; var NrRecs: Integer): Integer; {$I decorate};
begin
gdxErrorHandling('gdxDataReadMapStart could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxDataReadRaw(pgdx: pointer; var AElements: TgdxUELIndex; var AVals: TgdxValues; var AFDim: Integer): Integer; {$I decorate};
begin
gdxErrorHandling('gdxDataReadRaw could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxDataReadRawStart(pgdx: pointer; SyNr: Integer; var NrRecs: Integer): Integer; {$I decorate};
begin
gdxErrorHandling('gdxDataReadRawStart could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxDataReadSlice(pgdx: pointer; const AFiltElements: TgdxStrIndex; var ADim: Integer; DP: TDataStoreProc): Integer; {$I decorate};
begin
gdxErrorHandling('gdxDataReadSlice could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxDataReadSliceStart(pgdx: pointer; ASyNr: Integer; var ANrElems: TgdxUELIndex): Integer; {$I decorate};
begin
gdxErrorHandling('gdxDataReadSliceStart could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxDataReadStr(pgdx: pointer; var AStrElements: TgdxStrIndex; var AVals: TgdxValues; var AFDim: Integer): Integer; {$I decorate};
begin
gdxErrorHandling('gdxDataReadStr could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxDataReadStrStart(pgdx: pointer; SyNr: Integer; var NrRecs: Integer): Integer; {$I decorate};
begin
gdxErrorHandling('gdxDataReadStrStart could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxDataSliceUELS(pgdx: pointer; const AIndx: TgdxUELIndex; var AUELs: TgdxStrIndex): Integer; {$I decorate};
begin
gdxErrorHandling('gdxDataSliceUELS could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxDataWriteDone(pgdx: pointer): Integer; {$I decorate};
begin
gdxErrorHandling('gdxDataWriteDone could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxDataWriteMap(pgdx: pointer; const AElements: TgdxUELIndex; const AVals: TgdxValues): Integer; {$I decorate};
begin
gdxErrorHandling('gdxDataWriteMap could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxDataWriteMapStart(pgdx: pointer; const AName: ShortString; const Atext: ShortString; ADim: Integer; AType: Integer; AUserInfo: Integer): Integer; {$I decorate};
begin
gdxErrorHandling('gdxDataWriteMapStart could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxDataWriteRaw(pgdx: pointer; const AElements: TgdxUELIndex; const AVals: TgdxValues): Integer; {$I decorate};
begin
gdxErrorHandling('gdxDataWriteRaw could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxDataWriteRawStart(pgdx: pointer; const AName: ShortString; const Atext: ShortString; ADim: Integer; AType: Integer; AUserInfo: Integer): Integer; {$I decorate};
begin
gdxErrorHandling('gdxDataWriteRawStart could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxDataWriteStr(pgdx: pointer; const AStrElements: TgdxStrIndex; const AVals: TgdxValues): Integer; {$I decorate};
begin
gdxErrorHandling('gdxDataWriteStr could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxDataWriteStrStart(pgdx: pointer; const AName: ShortString; const Atext: ShortString; ADim: Integer; AType: Integer; AUserInfo: Integer): Integer; {$I decorate};
begin
gdxErrorHandling('gdxDataWriteStrStart could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxGetDLLVersion(pgdx: pointer; var V: ShortString): Integer; {$I decorate};
begin
gdxErrorHandling('gdxGetDLLVersion could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxErrorCount(pgdx: pointer): Integer; {$I decorate};
begin
gdxErrorHandling('gdxErrorCount could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxErrorStr(pgdx: pointer; N: Integer; var s: ShortString): Integer; {$I decorate};
begin
gdxErrorHandling('gdxErrorStr could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxFileInfo(pgdx: pointer; var FileVer: Integer; var ComprLev: Integer): Integer; {$I decorate};
begin
gdxErrorHandling('gdxFileInfo could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxFileVersion(pgdx: pointer; var FileStr: ShortString; var ProduceStr: ShortString): Integer; {$I decorate};
begin
gdxErrorHandling('gdxFileVersion could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxFilterExists(pgdx: pointer; N: Integer): Integer; {$I decorate};
begin
gdxErrorHandling('gdxFilterExists could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxFilterRegister(pgdx: pointer; V: Integer): Integer; {$I decorate};
begin
gdxErrorHandling('gdxFilterRegister could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxFilterRegisterDone(pgdx: pointer): Integer; {$I decorate};
begin
gdxErrorHandling('gdxFilterRegisterDone could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxFilterRegisterStart(pgdx: pointer; Nr: Integer): Integer; {$I decorate};
begin
gdxErrorHandling('gdxFilterRegisterStart could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxFindSymbol(pgdx: pointer; const AName: ShortString; var AIx: Integer): Integer; {$I decorate};
begin
gdxErrorHandling('gdxFindSymbol could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxGetElemText(pgdx: pointer; N: Integer; var s: ShortString; var Node: Integer): Integer; {$I decorate};
begin
gdxErrorHandling('gdxGetElemText could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxGetLastError(pgdx: pointer): Integer; {$I decorate};
begin
gdxErrorHandling('gdxGetLastError could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxGetSpecialValues(pgdx: pointer; var AVals: TgdxSVals): Integer; {$I decorate};
begin
gdxErrorHandling('gdxGetSpecialValues could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxGetUEL(pgdx: pointer; UelNr: Integer; var s: ShortString): Integer; {$I decorate};
begin
gdxErrorHandling('gdxGetUEL could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxMapValue(pgdx: pointer; D: Double; var sv: Integer): Integer; {$I decorate};
begin
gdxErrorHandling('gdxMapValue could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxOpenRead(pgdx: pointer; const Afn: ShortString; var ErrNr: Integer): Integer; {$I decorate};
begin
gdxErrorHandling('gdxOpenRead could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxOpenWrite(pgdx: pointer; const Afn: ShortString; const AProducer: ShortString; var ErrNr: Integer): Integer; {$I decorate};
begin
gdxErrorHandling('gdxOpenWrite could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxOpenWriteEx(pgdx: pointer; const Afn: ShortString; const AProducer: ShortString; Compr: Integer; var ErrNr: Integer): Integer; {$I decorate};
begin
gdxErrorHandling('gdxOpenWriteEx could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxResetSpecialValues(pgdx: pointer): Integer; {$I decorate};
begin
gdxErrorHandling('gdxResetSpecialValues could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxSetHasText(pgdx: pointer; N: Integer): Integer; {$I decorate};
begin
gdxErrorHandling('gdxSetHasText could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxSetReadSpecialValues(pgdx: pointer; const AVals: TgdxSVals): Integer; {$I decorate};
begin
gdxErrorHandling('gdxSetReadSpecialValues could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxSetSpecialValues(pgdx: pointer; const AVals: TgdxSVals): Integer; {$I decorate};
begin
gdxErrorHandling('gdxSetSpecialValues could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxSetTextNodeNr(pgdx: pointer; N: Integer; Node: Integer): Integer; {$I decorate};
begin
gdxErrorHandling('gdxSetTextNodeNr could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxSetTraceLevel(pgdx: pointer; N: Integer; const s: ShortString): Integer; {$I decorate};
begin
gdxErrorHandling('gdxSetTraceLevel could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxSymbIndxMaxLength(pgdx: pointer; SyNr: Integer; var DimInfo: TgdxUELIndex): Integer; {$I decorate};
begin
gdxErrorHandling('gdxSymbIndxMaxLength could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxSymbMaxLength(pgdx: pointer): Integer; {$I decorate};
begin
gdxErrorHandling('gdxSymbMaxLength could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxSymbolAddComment(pgdx: pointer; SyNr: Integer; const s: ShortString): Integer; {$I decorate};
begin
gdxErrorHandling('gdxSymbolAddComment could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxSymbolGetComment(pgdx: pointer; SyNr: Integer; N: Integer; var s: ShortString): Integer; {$I decorate};
begin
gdxErrorHandling('gdxSymbolGetComment could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxSymbolGetDomain(pgdx: pointer; SyNr: Integer; var DomainIDs: TgdxUELIndex): Integer; {$I decorate};
begin
gdxErrorHandling('gdxSymbolGetDomain could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxSymbolInfo(pgdx: pointer; SyNr: Integer; var AName: ShortString; var ADim: Integer; var ATyp: Integer): Integer; {$I decorate};
begin
gdxErrorHandling('gdxSymbolInfo could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxSymbolInfoX(pgdx: pointer; SyNr: Integer; var ACount: Integer; var AUserInfo: Integer; var AExplTxt: ShortString): Integer; {$I decorate};
begin
gdxErrorHandling('gdxSymbolInfoX could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxSymbolSetDomain(pgdx: pointer; const DomainIDs: TgdxStrIndex): Integer; {$I decorate};
begin
gdxErrorHandling('gdxSymbolSetDomain could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxSystemInfo(pgdx: pointer; var NrSy: Integer; var NrUel: Integer): Integer; {$I decorate};
begin
gdxErrorHandling('gdxSystemInfo could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxUELMaxLength(pgdx: pointer): Integer; {$I decorate};
begin
gdxErrorHandling('gdxUELMaxLength could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxUELRegisterDone(pgdx: pointer): Integer; {$I decorate};
begin
gdxErrorHandling('gdxUELRegisterDone could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxUELRegisterMap(pgdx: pointer; UelNr: Integer; const Elem: ShortString): Integer; {$I decorate};
begin
gdxErrorHandling('gdxUELRegisterMap could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxUELRegisterMapStart(pgdx: pointer): Integer; {$I decorate};
begin
gdxErrorHandling('gdxUELRegisterMapStart could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxUELRegisterRaw(pgdx: pointer; const Elem: ShortString): Integer; {$I decorate};
begin
gdxErrorHandling('gdxUELRegisterRaw could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxUELRegisterRawStart(pgdx: pointer): Integer; {$I decorate};
begin
gdxErrorHandling('gdxUELRegisterRawStart could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxUELRegisterStr(pgdx: pointer; const Elem: ShortString; var UelNr: Integer): Integer; {$I decorate};
begin
gdxErrorHandling('gdxUELRegisterStr could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxUELRegisterStrStart(pgdx: pointer): Integer; {$I decorate};
begin
gdxErrorHandling('gdxUELRegisterStrStart could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxUMFindUEL(pgdx: pointer; const s: ShortString; var EN: Integer; var UMap: Integer): Integer; {$I decorate};
begin
gdxErrorHandling('gdxUMFindUEL could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxUMUelGet(pgdx: pointer; N: Integer; var s: ShortString; var UMap: Integer): Integer; {$I decorate};
begin
gdxErrorHandling('gdxUMUelGet could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxUMUelInfo(pgdx: pointer; var NrElem: Integer; var HighMap: Integer): Integer; {$I decorate};
begin
gdxErrorHandling('gdxUMUelInfo could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

Function  d_gdxCurrentDim(pgdx: pointer): Integer; {$I decorate};
begin
gdxErrorHandling('gdxCurrentDim could not be loaded from ' + LibFileName + ' or has wrong signature!');
Result := 0;
end;

function  gdxGetScreenIndicator: boolean;
begin
Result := ScreenIndicator;
end;

procedure gdxSetScreenIndicator(const ScrInd: boolean);
begin
ScreenIndicator := ScrInd;
end;

function  gdxGetExceptionIndicator: boolean;
begin
Result := ExceptionIndicator;
end;

procedure gdxSetExceptionIndicator(const ExcInd: boolean);
begin
ExceptionIndicator := ExcInd;
end;

function  gdxGetExitIndicator: boolean;
begin
Result := ExitIndicator;
end;

procedure gdxSetExitIndicator(const ExtInd: boolean);
begin
ExitIndicator := ExtInd;
end;

function  gdxGetErrorCount: Integer;
begin
Result := APIErrorCount;
end;

procedure gdxSetErrorCount(const ecnt: Integer);
begin
APIErrorCount := ecnt;
end;

function  gdxGetErrorCallback: TErrorCallback;
begin
Result := @ErrorCallback;
end;

procedure gdxSetErrorCallback(ecb: TErrorCallback);
begin
ErrorCallback := ecb;
end;

Procedure gdxErrorHandling(const Msg: ShortString);
begin
inc(APIErrorCount);
if ScreenIndicator then writeln(Msg);
assert(not ExceptionIndicator, Msg);
if (@ErrorCallback <> nil) and (ErrorCallback(APIErrorCount, Msg) <> 0) then halt;
if ExitIndicator then halt;
end;

function XLibraryLoad(var LoadMsg: ShortString): boolean;
var
   comp: Integer;
   Msg : ShortString;
   sign: Array[0..5] of Integer;

   function LoadEntry(const n: ShortString; const NoArgs: Integer; const d_x: Pointer): pointer;
   begin
   Result := d_x;
   if (comp < 0) or XCheck(n, NoArgs, @sign, Msg)
   then
      begin
      Result := P3GetProcAddress(LibHandle, LowerCase(n));
      if Result = d_x
      then
         Result := P3GetProcAddress(LibHandle, n);
      if Result = d_x
      then
         Result := P3GetProcAddress(LibHandle, UpperCase(n));
      if Result = d_x
      then
         Msg := 'Entry not found: ' + n + ' in ' + LibFileName;
      end;
   if Debug and (Msg <> '') then gdxErrorHandling(Msg);
   end;

begin
Result  := false;
LoadMsg := '';
Msg     := '';
if LibHandle <> nil
then
   begin
   Result := true;
   exit;
   end;

LibHandle := P3LoadLibrary(LibFileName, LoadMsg);
if LibHandle = nil
then
   begin
   LoadMsg := LoadMsg + ': ' + LibFileName;
   exit;
   end;

Assert(LoadMsg = '', 'ALFA: LoadMsg not empty: ' + LoadMsg);
comp := -1;
@gdxSetLoadPath := LoadEntry('gdxSetLoadPath', 0, nil);
@gdxGetLoadPath := LoadEntry('gdxGetLoadPath', 0, nil);
LoadMsg := '';  //not an error
if DLLWrapsObject
then
   begin
   @XCreate := LoadEntry('XCreate', 0, nil);
   if @XCreate = nil then exit;
   @XFree   := LoadEntry('XFree', 0, nil);
   if @XFree = nil then exit;
   end;
@XCheck := LoadEntry('XCheck', 0, nil);
if @XCheck = nil then exit;
@XAPIVersion := LoadEntry('XAPIVersion', 0, nil);
if @XAPIVersion = nil then exit;
if not XAPIVersion(APIversion, Msg, comp)
then
   begin
   LoadMsg := Msg;
   exit;
   end;

sign[0] := 3;
@gdxAcronymCount := LoadEntry('gdxAcronymCount', 0, @d_gdxAcronymCount);
sign[0] := 3;sign[1] := 3;sign[2] := 12;sign[3] := 12;sign[4] := 4;
@gdxAcronymGetInfo := LoadEntry('gdxAcronymGetInfo', 4, @d_gdxAcronymGetInfo);
sign[0] := 3;sign[1] := 13;
@gdxAcronymIndex := LoadEntry('gdxAcronymIndex', 1, @d_gdxAcronymIndex);
sign[0] := 3;sign[1] := 13;sign[2] := 12;
@gdxAcronymName := LoadEntry('gdxAcronymName', 2, @d_gdxAcronymName);
sign[0] := 3;sign[1] := 3;sign[2] := 11;sign[3] := 11;sign[4] := 3;
@gdxAcronymSetInfo := LoadEntry('gdxAcronymSetInfo', 4, @d_gdxAcronymSetInfo);
sign[0] := 13;sign[1] := 3;
@gdxAcronymValue := LoadEntry('gdxAcronymValue', 1, @d_gdxAcronymValue);
sign[0] := 3;sign[1] := 11;sign[2] := 11;
@gdxAddAlias := LoadEntry('gdxAddAlias', 2, @d_gdxAddAlias);
sign[0] := 3;sign[1] := 11;sign[2] := 4;
@gdxAddSetText := LoadEntry('gdxAddSetText', 2, @d_gdxAddSetText);
sign[0] := 3;
@gdxClose := LoadEntry('gdxClose', 0, @d_gdxClose);
sign[0] := 3;
@gdxDataErrorCount := LoadEntry('gdxDataErrorCount', 0, @d_gdxDataErrorCount);
sign[0] := 3;sign[1] := 3;sign[2] := 52;sign[3] := 54;
@gdxDataErrorRecord := LoadEntry('gdxDataErrorRecord', 3, @d_gdxDataErrorRecord);
sign[0] := 3;
@gdxDataReadDone := LoadEntry('gdxDataReadDone', 0, @d_gdxDataReadDone);
sign[0] := 3;sign[1] := 3;sign[2] := 51;sign[3] := 4;
@gdxDataReadFilteredStart := LoadEntry('gdxDataReadFilteredStart', 3, @d_gdxDataReadFilteredStart);
sign[0] := 3;sign[1] := 3;sign[2] := 52;sign[3] := 54;sign[4] := 4;
@gdxDataReadMap := LoadEntry('gdxDataReadMap', 4, @d_gdxDataReadMap);
sign[0] := 3;sign[1] := 3;sign[2] := 4;
@gdxDataReadMapStart := LoadEntry('gdxDataReadMapStart', 2, @d_gdxDataReadMapStart);
sign[0] := 3;sign[1] := 52;sign[2] := 54;sign[3] := 4;
@gdxDataReadRaw := LoadEntry('gdxDataReadRaw', 3, @d_gdxDataReadRaw);
sign[0] := 3;sign[1] := 3;sign[2] := 4;
@gdxDataReadRawStart := LoadEntry('gdxDataReadRawStart', 2, @d_gdxDataReadRawStart);
sign[0] := 3;sign[1] := 55;sign[2] := 4;sign[3] := 59;
@gdxDataReadSlice := LoadEntry('gdxDataReadSlice', 3, @d_gdxDataReadSlice);
sign[0] := 3;sign[1] := 3;sign[2] := 52;
@gdxDataReadSliceStart := LoadEntry('gdxDataReadSliceStart', 2, @d_gdxDataReadSliceStart);
sign[0] := 3;sign[1] := 56;sign[2] := 54;sign[3] := 4;
@gdxDataReadStr := LoadEntry('gdxDataReadStr', 3, @d_gdxDataReadStr);
sign[0] := 3;sign[1] := 3;sign[2] := 4;
@gdxDataReadStrStart := LoadEntry('gdxDataReadStrStart', 2, @d_gdxDataReadStrStart);
sign[0] := 3;sign[1] := 51;sign[2] := 56;
@gdxDataSliceUELS := LoadEntry('gdxDataSliceUELS', 2, @d_gdxDataSliceUELS);
sign[0] := 3;
@gdxDataWriteDone := LoadEntry('gdxDataWriteDone', 0, @d_gdxDataWriteDone);
sign[0] := 3;sign[1] := 51;sign[2] := 53;
@gdxDataWriteMap := LoadEntry('gdxDataWriteMap', 2, @d_gdxDataWriteMap);
sign[0] := 3;sign[1] := 11;sign[2] := 11;sign[3] := 3;sign[4] := 3;sign[5] := 3;
@gdxDataWriteMapStart := LoadEntry('gdxDataWriteMapStart', 5, @d_gdxDataWriteMapStart);
sign[0] := 3;sign[1] := 51;sign[2] := 53;
@gdxDataWriteRaw := LoadEntry('gdxDataWriteRaw', 2, @d_gdxDataWriteRaw);
sign[0] := 3;sign[1] := 11;sign[2] := 11;sign[3] := 3;sign[4] := 3;sign[5] := 3;
@gdxDataWriteRawStart := LoadEntry('gdxDataWriteRawStart', 5, @d_gdxDataWriteRawStart);
sign[0] := 3;sign[1] := 55;sign[2] := 53;
@gdxDataWriteStr := LoadEntry('gdxDataWriteStr', 2, @d_gdxDataWriteStr);
sign[0] := 3;sign[1] := 11;sign[2] := 11;sign[3] := 3;sign[4] := 3;sign[5] := 3;
@gdxDataWriteStrStart := LoadEntry('gdxDataWriteStrStart', 5, @d_gdxDataWriteStrStart);
sign[0] := 3;sign[1] := 12;
@gdxGetDLLVersion := LoadEntry('gdxGetDLLVersion', 1, @d_gdxGetDLLVersion);
sign[0] := 3;
@gdxErrorCount := LoadEntry('gdxErrorCount', 0, @d_gdxErrorCount);
sign[0] := 3;sign[1] := 3;sign[2] := 12;
@gdxErrorStr := LoadEntry('gdxErrorStr', 2, @d_gdxErrorStr);
sign[0] := 3;sign[1] := 4;sign[2] := 4;
@gdxFileInfo := LoadEntry('gdxFileInfo', 2, @d_gdxFileInfo);
sign[0] := 3;sign[1] := 12;sign[2] := 12;
@gdxFileVersion := LoadEntry('gdxFileVersion', 2, @d_gdxFileVersion);
sign[0] := 3;sign[1] := 3;
@gdxFilterExists := LoadEntry('gdxFilterExists', 1, @d_gdxFilterExists);
sign[0] := 3;sign[1] := 3;
@gdxFilterRegister := LoadEntry('gdxFilterRegister', 1, @d_gdxFilterRegister);
sign[0] := 3;
@gdxFilterRegisterDone := LoadEntry('gdxFilterRegisterDone', 0, @d_gdxFilterRegisterDone);
sign[0] := 3;sign[1] := 3;
@gdxFilterRegisterStart := LoadEntry('gdxFilterRegisterStart', 1, @d_gdxFilterRegisterStart);
sign[0] := 3;sign[1] := 11;sign[2] := 4;
@gdxFindSymbol := LoadEntry('gdxFindSymbol', 2, @d_gdxFindSymbol);
sign[0] := 3;sign[1] := 3;sign[2] := 12;sign[3] := 4;
@gdxGetElemText := LoadEntry('gdxGetElemText', 3, @d_gdxGetElemText);
sign[0] := 3;
@gdxGetLastError := LoadEntry('gdxGetLastError', 0, @d_gdxGetLastError);
sign[0] := 3;sign[1] := 58;
@gdxGetSpecialValues := LoadEntry('gdxGetSpecialValues', 1, @d_gdxGetSpecialValues);
sign[0] := 3;sign[1] := 3;sign[2] := 12;
@gdxGetUEL := LoadEntry('gdxGetUEL', 2, @d_gdxGetUEL);
sign[0] := 3;sign[1] := 13;sign[2] := 4;
@gdxMapValue := LoadEntry('gdxMapValue', 2, @d_gdxMapValue);
sign[0] := 3;sign[1] := 11;sign[2] := 4;
@gdxOpenRead := LoadEntry('gdxOpenRead', 2, @d_gdxOpenRead);
sign[0] := 3;sign[1] := 11;sign[2] := 11;sign[3] := 4;
@gdxOpenWrite := LoadEntry('gdxOpenWrite', 3, @d_gdxOpenWrite);
sign[0] := 3;sign[1] := 11;sign[2] := 11;sign[3] := 3;sign[4] := 4;
@gdxOpenWriteEx := LoadEntry('gdxOpenWriteEx', 4, @d_gdxOpenWriteEx);
sign[0] := 3;
@gdxResetSpecialValues := LoadEntry('gdxResetSpecialValues', 0, @d_gdxResetSpecialValues);
sign[0] := 3;sign[1] := 3;
@gdxSetHasText := LoadEntry('gdxSetHasText', 1, @d_gdxSetHasText);
sign[0] := 3;sign[1] := 57;
@gdxSetReadSpecialValues := LoadEntry('gdxSetReadSpecialValues', 1, @d_gdxSetReadSpecialValues);
sign[0] := 3;sign[1] := 57;
@gdxSetSpecialValues := LoadEntry('gdxSetSpecialValues', 1, @d_gdxSetSpecialValues);
sign[0] := 3;sign[1] := 3;sign[2] := 3;
@gdxSetTextNodeNr := LoadEntry('gdxSetTextNodeNr', 2, @d_gdxSetTextNodeNr);
sign[0] := 3;sign[1] := 3;sign[2] := 11;
@gdxSetTraceLevel := LoadEntry('gdxSetTraceLevel', 2, @d_gdxSetTraceLevel);
sign[0] := 3;sign[1] := 3;sign[2] := 52;
@gdxSymbIndxMaxLength := LoadEntry('gdxSymbIndxMaxLength', 2, @d_gdxSymbIndxMaxLength);
sign[0] := 3;
@gdxSymbMaxLength := LoadEntry('gdxSymbMaxLength', 0, @d_gdxSymbMaxLength);
sign[0] := 3;sign[1] := 3;sign[2] := 11;
@gdxSymbolAddComment := LoadEntry('gdxSymbolAddComment', 2, @d_gdxSymbolAddComment);
sign[0] := 3;sign[1] := 3;sign[2] := 3;sign[3] := 12;
@gdxSymbolGetComment := LoadEntry('gdxSymbolGetComment', 3, @d_gdxSymbolGetComment);
sign[0] := 3;sign[1] := 3;sign[2] := 52;
@gdxSymbolGetDomain := LoadEntry('gdxSymbolGetDomain', 2, @d_gdxSymbolGetDomain);
sign[0] := 3;sign[1] := 3;sign[2] := 12;sign[3] := 4;sign[4] := 4;
@gdxSymbolInfo := LoadEntry('gdxSymbolInfo', 4, @d_gdxSymbolInfo);
sign[0] := 3;sign[1] := 3;sign[2] := 4;sign[3] := 4;sign[4] := 12;
@gdxSymbolInfoX := LoadEntry('gdxSymbolInfoX', 4, @d_gdxSymbolInfoX);
sign[0] := 3;sign[1] := 55;
@gdxSymbolSetDomain := LoadEntry('gdxSymbolSetDomain', 1, @d_gdxSymbolSetDomain);
sign[0] := 3;sign[1] := 4;sign[2] := 4;
@gdxSystemInfo := LoadEntry('gdxSystemInfo', 2, @d_gdxSystemInfo);
sign[0] := 3;
@gdxUELMaxLength := LoadEntry('gdxUELMaxLength', 0, @d_gdxUELMaxLength);
sign[0] := 3;
@gdxUELRegisterDone := LoadEntry('gdxUELRegisterDone', 0, @d_gdxUELRegisterDone);
sign[0] := 3;sign[1] := 3;sign[2] := 11;
@gdxUELRegisterMap := LoadEntry('gdxUELRegisterMap', 2, @d_gdxUELRegisterMap);
sign[0] := 3;
@gdxUELRegisterMapStart := LoadEntry('gdxUELRegisterMapStart', 0, @d_gdxUELRegisterMapStart);
sign[0] := 3;sign[1] := 11;
@gdxUELRegisterRaw := LoadEntry('gdxUELRegisterRaw', 1, @d_gdxUELRegisterRaw);
sign[0] := 3;
@gdxUELRegisterRawStart := LoadEntry('gdxUELRegisterRawStart', 0, @d_gdxUELRegisterRawStart);
sign[0] := 3;sign[1] := 11;sign[2] := 4;
@gdxUELRegisterStr := LoadEntry('gdxUELRegisterStr', 2, @d_gdxUELRegisterStr);
sign[0] := 3;
@gdxUELRegisterStrStart := LoadEntry('gdxUELRegisterStrStart', 0, @d_gdxUELRegisterStrStart);
sign[0] := 3;sign[1] := 11;sign[2] := 4;sign[3] := 4;
@gdxUMFindUEL := LoadEntry('gdxUMFindUEL', 3, @d_gdxUMFindUEL);
sign[0] := 3;sign[1] := 3;sign[2] := 12;sign[3] := 4;
@gdxUMUelGet := LoadEntry('gdxUMUelGet', 3, @d_gdxUMUelGet);
sign[0] := 3;sign[1] := 4;sign[2] := 4;
@gdxUMUelInfo := LoadEntry('gdxUMUelInfo', 2, @d_gdxUMUelInfo);
sign[0] := 3;
@gdxCurrentDim := LoadEntry('gdxCurrentDim', 0, @d_gdxCurrentDim);
Assert(LoadMsg = '', 'ALFA: LoadMsg not empty: ' + LoadMsg);
Result := true;
end;

procedure XLibraryUnload;
begin
if LibHandle <> nil
then
   begin
   P3FreeLibrary(LibHandle);
   LibHandle := nil;
   end;

@XCreate                  := nil;
@XFree                    := nil;
@gdxAcronymCount          := nil;
@gdxAcronymGetInfo        := nil;
@gdxAcronymIndex          := nil;
@gdxAcronymName           := nil;
@gdxAcronymSetInfo        := nil;
@gdxAcronymValue          := nil;
@gdxAddAlias              := nil;
@gdxAddSetText            := nil;
@gdxClose                 := nil;
@gdxDataErrorCount        := nil;
@gdxDataErrorRecord       := nil;
@gdxDataReadDone          := nil;
@gdxDataReadFilteredStart := nil;
@gdxDataReadMap           := nil;
@gdxDataReadMapStart      := nil;
@gdxDataReadRaw           := nil;
@gdxDataReadRawStart      := nil;
@gdxDataReadSlice         := nil;
@gdxDataReadSliceStart    := nil;
@gdxDataReadStr           := nil;
@gdxDataReadStrStart      := nil;
@gdxDataSliceUELS         := nil;
@gdxDataWriteDone         := nil;
@gdxDataWriteMap          := nil;
@gdxDataWriteMapStart     := nil;
@gdxDataWriteRaw          := nil;
@gdxDataWriteRawStart     := nil;
@gdxDataWriteStr          := nil;
@gdxDataWriteStrStart     := nil;
@gdxGetDLLVersion         := nil;
@gdxErrorCount            := nil;
@gdxErrorStr              := nil;
@gdxFileInfo              := nil;
@gdxFileVersion           := nil;
@gdxFilterExists          := nil;
@gdxFilterRegister        := nil;
@gdxFilterRegisterDone    := nil;
@gdxFilterRegisterStart   := nil;
@gdxFindSymbol            := nil;
@gdxGetElemText           := nil;
@gdxGetLastError          := nil;
@gdxGetSpecialValues      := nil;
@gdxGetUEL                := nil;
@gdxMapValue              := nil;
@gdxOpenRead              := nil;
@gdxOpenWrite             := nil;
@gdxOpenWriteEx           := nil;
@gdxResetSpecialValues    := nil;
@gdxSetHasText            := nil;
@gdxSetReadSpecialValues  := nil;
@gdxSetSpecialValues      := nil;
@gdxSetTextNodeNr         := nil;
@gdxSetTraceLevel         := nil;
@gdxSymbIndxMaxLength     := nil;
@gdxSymbMaxLength         := nil;
@gdxSymbolAddComment      := nil;
@gdxSymbolGetComment      := nil;
@gdxSymbolGetDomain       := nil;
@gdxSymbolInfo            := nil;
@gdxSymbolInfoX           := nil;
@gdxSymbolSetDomain       := nil;
@gdxSystemInfo            := nil;
@gdxUELMaxLength          := nil;
@gdxUELRegisterDone       := nil;
@gdxUELRegisterMap        := nil;
@gdxUELRegisterMapStart   := nil;
@gdxUELRegisterRaw        := nil;
@gdxUELRegisterRawStart   := nil;
@gdxUELRegisterStr        := nil;
@gdxUELRegisterStrStart   := nil;
@gdxUMFindUEL             := nil;
@gdxUMUelGet              := nil;
@gdxUMUelInfo             := nil;
@gdxCurrentDim            := nil;
@gdxSetLoadPath           := nil;
@gdxGetLoadPath           := nil;
end;

function LibLoader(const Path, Name: ShortString; var Msg: ShortString): boolean;
var
   xName  : ShortString;
   xPath  : ShortString;
begin
if Name <> ''
then
   xName := Name
else
   begin
   xName := gamslibname('gdxdclib');
   xName := OSDllPrefix[OSplatform] + xName  + OSDllExtension[OSplatform];
   end;
if Path = ''
then
   begin
   xPath       := '';
   LibFileName := xName
   end
else
   begin
   xPath       := ExcludeTrailingPathDelimiter(Path);
   LibFileName := xPath + PathDelim + xName;
   end;

Result := XLibraryLoad(Msg);
if @gdxSetLoadPath <> nil
then
   begin
   if Result
   then
      gdxSetLoadPath(xPath)
   else
      gdxSetLoadPath('');
   end;
end;

function gdxGetReady(var Msg: ShortString): boolean;
begin
if LibHandle = nil
then
   Result := LibLoader('', '', Msg)
else
   begin
   Msg := '';
   Result := true
   end
end;

function gdxGetReadyX(var Msg: ShortString): boolean;
begin
if LibHandle = nil
then
   begin
   Result := LibLoader(ExtractFilePath(ParamStr(0)), '', Msg);
   if LibHandle = nil
   then
      Result := LibLoader('', '', Msg);
   end
else
   begin
   Msg := '';
   Result := true
   end
end;

function gdxGetReadyD(const Dir: ShortString; var Msg: ShortString): boolean;
begin
if LibHandle = nil
then
   Result := LibLoader(Dir, '', Msg)
else
   begin
   Msg := '';
   Result := true
   end
end;

function gdxGetReadyL(const LibName: ShortString; var Msg: ShortString): boolean;
begin
if LibHandle = nil
then
   Result := LibLoader(ExtractFilePath(LibName), ExtractFileName(LibName), Msg)
else
   begin
   Msg := '';
   Result := true
   end
end;

procedure gdxCreateHandle(pgdx: pointer; var mygdx: pointer);
begin
if mygdx = nil
then
   mygdx := pgdx
else
   Assert(mygdx = pgdx, 'gdxCreateHandle');
end;

function  gdxGetHandle(pgdx: pointer): pointer;
begin
Result := pgdx;
end;

function gdxCreate(var pgdx: pointer; var Msg: ShortString): boolean;
begin
Assert(DLLWrapsObject, 'gdxdcdef.gdxCreate without an Object');
Result := gdxGetReady(Msg);
if Result
then
   begin
   XCreate(pgdx);
   if pgdx = nil
   then
      begin
      Result := false;
      Msg := 'Library is loaded but error while creating object';
      end
   else
      inc(ObjectCount);
   end
else
   begin
   pgdx := nil;
   if Msg = '' then Msg := 'Unknown error';
   end;
end;

function gdxCreateX(var pgdx: pointer; var Msg: ShortString): boolean;
begin
Assert(DLLWrapsObject, 'gdxdcdef.gdxCreate without an Object');
Result := gdxGetReadyX(Msg);
if Result
then
   begin
   XCreate(pgdx);
   if pgdx = nil
   then
      begin
      Result := false;
      Msg := 'Library is loaded but error while creating object';
      end
   else
      inc(ObjectCount);
   end
else
   begin
   pgdx := nil;
   if Msg = '' then Msg := 'Unknown error';
   end;
end;

function gdxCreateD(var pgdx: pointer; const Dir: ShortString; var Msg: shortString): boolean;
begin
Assert(DLLWrapsObject, 'gdxdcdef.gdxCreateD without an Object');
Result := gdxGetReadyD(Dir, Msg);
if Result
then
   begin
   XCreate(pgdx);
   if pgdx = nil
   then
      begin
      Result := false;
      Msg := 'Library is loaded but error while creating object';
      end
   else
      inc(ObjectCount);
   end
else
   begin
   pgdx := nil;
   if Msg = '' then Msg := 'Unknown error';
   end;
end;

function gdxCreateL(var pgdx: pointer; const LibName: ShortString; var Msg: shortString): boolean;
begin
Assert(DLLWrapsObject, 'gdxdcdef.gdxCreateL without an Object');
Result := gdxGetReadyL(LibName, Msg);
if Result
then
   begin
   XCreate(pgdx);
   if pgdx = nil
   then
      begin
      Result := false;
      Msg := 'Library is loaded but error while creating object';
      end
   else
      inc(ObjectCount);
   end
else
   begin
   pgdx := nil;
   if Msg = '' then Msg := 'Unknown error';
   end;
end;

procedure gdxFree  (var pgdx: pointer);
begin
if @XFree <> nil
then
   begin
   XFree(pgdx); pgdx := nil;
   dec(ObjectCount);
   end;
end;

function gdxLibraryLoaded: boolean;
begin
Result := LibHandle <> nil;
end;

procedure gdxLibraryUnload;
begin
if LibHandle <> nil
then
   begin
   assert(ObjectCount=0, 'Could not unload library, object not freed.');
   XLibraryUnload;
   end;
end;

initialization

Libhandle := nil;
XLibraryUnload;

end.
