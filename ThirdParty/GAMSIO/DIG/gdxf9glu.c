/*  C code generated by apiwrapper */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <ctype.h>
#include <errno.h>

#if defined(_WIN32)
# include <windows.h>
# define GDX_CALLCONV __stdcall
  static char winErr[] = "Windows error";
  typedef HINSTANCE soHandle_t;
#elif defined(CIA_HP7)
# define GDX_CALLCONV
# include <unistd.h>
# include <dl.h>
  typedef shl_t soHandle_t;
#else
# define GDX_CALLCONV
# include <unistd.h>
# include <dlfcn.h>
  typedef void *soHandle_t;
#endif

typedef int (GDX_CALLCONV *errorCallbackFort_t) (int *errCount, const char *msg, int msgLen);
#if defined(_WIN32)
typedef __int64 INT64;
#elif defined(__LP64__) || defined(__axu__) || defined(_FCGLU_LP64_)
typedef signed long int INT64;
#else
typedef signed long long int INT64;
#endif

#include "gamsglobals.h"

static soHandle_t hLibGlobal;  /* global shared library handle */
static int isLoaded = 0;
static int objectCount = 0;
static int screenIndicator = 1;
static int exceptionIndicator = 0;
static int exitIndicator = 0;
static errorCallbackFort_t errorCallbackFort = NULL;
static int APIErrorCount = 0;
static int trimflag  = 1;

typedef char string255[256];
typedef char stringf255[255];
typedef char cBuf512_t[512];
typedef int gdxBoolean_t;
typedef union foo { void *p; INT64 i; } u64_t;


static void convertF2PAS (const char* src, char *dest, int s_len, int p_len)
{
  int i;
  int len;

  len = s_len;
  if (trimflag)
    for (;;) {
      if (len==0) break;
      if (src[len-1] != ' ') break;
      --len;
    }
  if (p_len<len)
    len = p_len;
  for (i=0; i<len; ++i)
    dest[i+1] = src[i];
  dest[0] = len;
} /* convertF2PAS */


static void convertPAS2F (const char *src, char *dest, int s_len)
{
  int i, len;
  unsigned char s0;

  for (i = 0;  i < s_len;  i++)
    dest[i] = ' ';
  s0 = src[0];
  len = s_len;
  if (s0 < len)
    len = s0;
  for (i = 0;  i < len;  i++)
    dest[i] = src[i+1];
} /* convertPAS2F */


static void convertF2C(const char* sf, char *sc, int fSize, int cSize)
{
  int i;
  int count;

  count = fSize;
  while ((count>0) && (sf[count-1]==' '))
    --count;
  if (cSize-1<count)
    count = cSize-1;
  for (i=0; i<count; ++i)
    sc[i] = sf[i];
  sc[count] = '\0';
} /* convertF2C */


static void convertC2F(const char* sc, char *sf, int s_len)
{
  int i, len;
  unsigned char s0;
  for (i=0; i<s_len; ++i)
    sf[i] = ' ';
  s0 = strlen(sc);
  len = s_len;
  if (s0 < len)
    len = s0;
  for (i=0; i<len; ++i)
    sf[i] = sc[i];
} /* convertC2F */

/* pad the buffer with blanks, including whacking the terminating nul */
static void blankPad (char *buf, int len, int siz)
{
  int i;

  if (siz >= len) {
    memset (buf+len, ' ', siz-len);
  }
}

typedef gdxBoolean_t (GDX_CALLCONV *XCreate_t) (void *pgdx);
static XCreate_t XCreate = NULL;
typedef gdxBoolean_t (GDX_CALLCONV *XFree_t)   (void *pgdx);
static XFree_t   XFree = NULL;
typedef int (GDX_CALLCONV *XAPIVersion_t) (int api, char *msg, int *cl);
static XAPIVersion_t XAPIVersion = NULL;
typedef int (GDX_CALLCONV *XCheck_t) (char *ep, int nargs, int s[], char *msg);
static XCheck_t XCheck = NULL;

static void errorHandling (const char *msg)
{
  int msgLen;
  int tmp;

  APIErrorCount++;
  if (screenIndicator) {
    printf("FIX ME in C glu: %s\n", msg);
    exit (1);
  }
  if (errorCallbackFort) {
    msgLen = strlen(msg);
    tmp = APIErrorCount;
    if (errorCallbackFort(&tmp, msg, msgLen))
      exit(1);
  }
  assert(!exceptionIndicator);
  if (exitIndicator)
    exit(1);
}



typedef void (GDX_CALLCONV *gdxSetLoadPath_t) (const char *s);
static gdxSetLoadPath_t gdxSetLoadPath = NULL;
typedef void (GDX_CALLCONV *gdxGetLoadPath_t) (char *s);
static gdxGetLoadPath_t gdxGetLoadPath = NULL;
int  GDX_CALLCONV d_gdxAcronymCount (void *pgdx)
{
  errorHandling("gdxAcronymCount could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxAcronymGetInfo (void *pgdx, int N, char *AName, char *Atext, int *Indx)
{
  errorHandling("gdxAcronymGetInfo could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxAcronymIndex (void *pgdx, double V)
{
  errorHandling("gdxAcronymIndex could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxAcronymName (void *pgdx, double V, char *AName)
{
  errorHandling("gdxAcronymName could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxAcronymSetInfo (void *pgdx, int N, const char *AName, const char *Atext, int Indx)
{
  errorHandling("gdxAcronymSetInfo could not be loaded or has wrong signature!");
  return 0;
}

double  GDX_CALLCONV d_gdxAcronymValue (void *pgdx, int Indx)
{
  errorHandling("gdxAcronymValue could not be loaded or has wrong signature!");
  return 0.0;
}

int  GDX_CALLCONV d_gdxAddAlias (void *pgdx, const char *AName1, const char *AName2)
{
  errorHandling("gdxAddAlias could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxAddSetText (void *pgdx, const char *s, int *N)
{
  errorHandling("gdxAddSetText could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxAutoConvert (void *pgdx, int NV)
{
  errorHandling("gdxAutoConvert could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxClose (void *pgdx)
{
  errorHandling("gdxClose could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxDataErrorCount (void *pgdx)
{
  errorHandling("gdxDataErrorCount could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxDataErrorRecord (void *pgdx, int Rn, int *AElements, double *AVals)
{
  errorHandling("gdxDataErrorRecord could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxDataReadDone (void *pgdx)
{
  errorHandling("gdxDataReadDone could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxDataReadFilteredStart (void *pgdx, int SyNr, const int *ADomainNrs, int *NrRecs)
{
  errorHandling("gdxDataReadFilteredStart could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxDataReadMap (void *pgdx, int Rn, int *AElements, double *AVals, int *AFDim)
{
  errorHandling("gdxDataReadMap could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxDataReadMapStart (void *pgdx, int SyNr, int *NrRecs)
{
  errorHandling("gdxDataReadMapStart could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxDataReadRaw (void *pgdx, int *AElements, double *AVals, int *AFDim)
{
  errorHandling("gdxDataReadRaw could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxDataReadRawStart (void *pgdx, int SyNr, int *NrRecs)
{
  errorHandling("gdxDataReadRawStart could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxDataReadSliceStart (void *pgdx, int ASyNr, int *ANrElems)
{
  errorHandling("gdxDataReadSliceStart could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxDataReadStr (void *pgdx, char **AStrElements, double *AVals, int *AFDim)
{
  errorHandling("gdxDataReadStr could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxDataReadStrStart (void *pgdx, int SyNr, int *NrRecs)
{
  errorHandling("gdxDataReadStrStart could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxDataSliceUELS (void *pgdx, const int *AIndx, char **AUELs)
{
  errorHandling("gdxDataSliceUELS could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxDataWriteDone (void *pgdx)
{
  errorHandling("gdxDataWriteDone could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxDataWriteMap (void *pgdx, const int *AElements, const double *AVals)
{
  errorHandling("gdxDataWriteMap could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxDataWriteMapStart (void *pgdx, const char *AName, const char *Atext, int ADim, int AType, int AUserInfo)
{
  errorHandling("gdxDataWriteMapStart could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxDataWriteRaw (void *pgdx, const int *AElements, const double *AVals)
{
  errorHandling("gdxDataWriteRaw could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxDataWriteRawStart (void *pgdx, const char *AName, const char *Atext, int ADim, int AType, int AUserInfo)
{
  errorHandling("gdxDataWriteRawStart could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxDataWriteStr (void *pgdx, const char **AStrElements, const double *AVals)
{
  errorHandling("gdxDataWriteStr could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxDataWriteStrStart (void *pgdx, const char *AName, const char *Atext, int ADim, int AType, int AUserInfo)
{
  errorHandling("gdxDataWriteStrStart could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxGetDLLVersion (void *pgdx, char *V)
{
  errorHandling("gdxGetDLLVersion could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxErrorCount (void *pgdx)
{
  errorHandling("gdxErrorCount could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxErrorStr (void *pgdx, int N, char *s)
{
  errorHandling("gdxErrorStr could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxFileInfo (void *pgdx, int *FileVer, int *ComprLev)
{
  errorHandling("gdxFileInfo could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxFileVersion (void *pgdx, char *FileStr, char *ProduceStr)
{
  errorHandling("gdxFileVersion could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxFilterExists (void *pgdx, int N)
{
  errorHandling("gdxFilterExists could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxFilterRegister (void *pgdx, int V)
{
  errorHandling("gdxFilterRegister could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxFilterRegisterDone (void *pgdx)
{
  errorHandling("gdxFilterRegisterDone could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxFilterRegisterStart (void *pgdx, int Nr)
{
  errorHandling("gdxFilterRegisterStart could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxFindSymbol (void *pgdx, const char *AName, int *AIx)
{
  errorHandling("gdxFindSymbol could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxGetElemText (void *pgdx, int N, char *s, int *Node)
{
  errorHandling("gdxGetElemText could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxGetLastError (void *pgdx)
{
  errorHandling("gdxGetLastError could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxGetSpecialValues (void *pgdx, double *AVals)
{
  errorHandling("gdxGetSpecialValues could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxGetUEL (void *pgdx, int UelNr, char *s)
{
  errorHandling("gdxGetUEL could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxMapValue (void *pgdx, double D, int *sv)
{
  errorHandling("gdxMapValue could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxOpenRead (void *pgdx, const char *Afn, int *ErrNr)
{
  errorHandling("gdxOpenRead could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxOpenWrite (void *pgdx, const char *Afn, const char *AProducer, int *ErrNr)
{
  errorHandling("gdxOpenWrite could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxOpenWriteEx (void *pgdx, const char *Afn, const char *AProducer, int Compr, int *ErrNr)
{
  errorHandling("gdxOpenWriteEx could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxResetSpecialValues (void *pgdx)
{
  errorHandling("gdxResetSpecialValues could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxSetHasText (void *pgdx, int N)
{
  errorHandling("gdxSetHasText could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxSetReadSpecialValues (void *pgdx, const double *AVals)
{
  errorHandling("gdxSetReadSpecialValues could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxSetSpecialValues (void *pgdx, const double *AVals)
{
  errorHandling("gdxSetSpecialValues could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxSetTextNodeNr (void *pgdx, int N, int Node)
{
  errorHandling("gdxSetTextNodeNr could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxSetTraceLevel (void *pgdx, int N, const char *s)
{
  errorHandling("gdxSetTraceLevel could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxSymbIndxMaxLength (void *pgdx, int SyNr, int *DimInfo)
{
  errorHandling("gdxSymbIndxMaxLength could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxSymbMaxLength (void *pgdx)
{
  errorHandling("gdxSymbMaxLength could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxSymbolAddComment (void *pgdx, int SyNr, const char *s)
{
  errorHandling("gdxSymbolAddComment could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxSymbolGetComment (void *pgdx, int SyNr, int N, char *s)
{
  errorHandling("gdxSymbolGetComment could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxSymbolGetDomain (void *pgdx, int SyNr, int *DomainIDs)
{
  errorHandling("gdxSymbolGetDomain could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxSymbolInfo (void *pgdx, int SyNr, char *AName, int *ADim, int *ATyp)
{
  errorHandling("gdxSymbolInfo could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxSymbolInfoX (void *pgdx, int SyNr, int *ACount, int *AUserInfo, char *AExplTxt)
{
  errorHandling("gdxSymbolInfoX could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxSymbolSetDomain (void *pgdx, const char **DomainIDs)
{
  errorHandling("gdxSymbolSetDomain could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxSystemInfo (void *pgdx, int *NrSy, int *NrUel)
{
  errorHandling("gdxSystemInfo could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxUELMaxLength (void *pgdx)
{
  errorHandling("gdxUELMaxLength could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxUELRegisterDone (void *pgdx)
{
  errorHandling("gdxUELRegisterDone could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxUELRegisterMap (void *pgdx, int UelNr, const char *Elem)
{
  errorHandling("gdxUELRegisterMap could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxUELRegisterMapStart (void *pgdx)
{
  errorHandling("gdxUELRegisterMapStart could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxUELRegisterRaw (void *pgdx, const char *Elem)
{
  errorHandling("gdxUELRegisterRaw could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxUELRegisterRawStart (void *pgdx)
{
  errorHandling("gdxUELRegisterRawStart could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxUELRegisterStr (void *pgdx, const char *Elem, int *UelNr)
{
  errorHandling("gdxUELRegisterStr could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxUELRegisterStrStart (void *pgdx)
{
  errorHandling("gdxUELRegisterStrStart could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxUMFindUEL (void *pgdx, const char *s, int *EN, int *UMap)
{
  errorHandling("gdxUMFindUEL could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxUMUelGet (void *pgdx, int N, char *s, int *UMap)
{
  errorHandling("gdxUMUelGet could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxUMUelInfo (void *pgdx, int *NrElem, int *HighMap)
{
  errorHandling("gdxUMUelInfo could not be loaded or has wrong signature!");
  return 0;
}

int  GDX_CALLCONV d_gdxCurrentDim (void *pgdx)
{
  errorHandling("gdxCurrentDim could not be loaded or has wrong signature!");
  return 0;
}


/* return dirName on success, NULL on failure */
static char *
extractFileDir (const char *fileName, char *dirName, int dirNameLen)
{
  int i, fileNameLen;
  const char *end, *s;
  char *t;

  if (NULL == fileName || NULL == dirName) {
    return NULL;
  }
  fileNameLen = (int) strlen(fileName);

#if defined(_WIN32)
  /* get the last delimiter */
  for (end = fileName + fileNameLen - 1;
       end >= fileName && '\\' != *end && ':' != *end;  end--);
  /* shave off the trailing delimiter if it isn't the first char,
   * it is a backslack, and it is not preceded by a delimiter
   */
  if (end > fileName && '\\' == *end
   && (! ('\\' == *(end-1) || ':' == *(end-1)))
     )
    end--;
#else
  /* non-Windows: implicitly, this is the Unix version */
  /* get the last delimiter */
  for (end = fileName + fileNameLen - 1;
       end >= fileName && '/' != *end;  end--);

  if (end > fileName && '/' == *end)
    end--;
#endif  /* if defined(_WIN32) */

  for (s = fileName, t = dirName;  s <= end;  s++, t++)
    *t = *s;
  *t = '\0';

  return dirName;
} /* extractFileDir */



typedef int (GDX_CALLCONV *gdxAcronymCount_t) (void *pgdx);
static gdxAcronymCount_t gdxAcronymCount = NULL;
typedef int (GDX_CALLCONV *gdxAcronymGetInfo_t) (void *pgdx, int N, char *AName, char *Atext, int *Indx);
static gdxAcronymGetInfo_t gdxAcronymGetInfo = NULL;
typedef int (GDX_CALLCONV *gdxAcronymIndex_t) (void *pgdx, double V);
static gdxAcronymIndex_t gdxAcronymIndex = NULL;
typedef int (GDX_CALLCONV *gdxAcronymName_t) (void *pgdx, double V, char *AName);
static gdxAcronymName_t gdxAcronymName = NULL;
typedef int (GDX_CALLCONV *gdxAcronymSetInfo_t) (void *pgdx, int N, const char *AName, const char *Atext, int Indx);
static gdxAcronymSetInfo_t gdxAcronymSetInfo = NULL;
typedef double (GDX_CALLCONV *gdxAcronymValue_t) (void *pgdx, int Indx);
static gdxAcronymValue_t gdxAcronymValue = NULL;
typedef int (GDX_CALLCONV *gdxAddAlias_t) (void *pgdx, const char *AName1, const char *AName2);
static gdxAddAlias_t gdxAddAlias = NULL;
typedef int (GDX_CALLCONV *gdxAddSetText_t) (void *pgdx, const char *s, int *N);
static gdxAddSetText_t gdxAddSetText = NULL;
typedef int (GDX_CALLCONV *gdxAutoConvert_t) (void *pgdx, int NV);
static gdxAutoConvert_t gdxAutoConvert = NULL;
typedef int (GDX_CALLCONV *gdxClose_t) (void *pgdx);
static gdxClose_t gdxClose = NULL;
typedef int (GDX_CALLCONV *gdxDataErrorCount_t) (void *pgdx);
static gdxDataErrorCount_t gdxDataErrorCount = NULL;
typedef int (GDX_CALLCONV *gdxDataErrorRecord_t) (void *pgdx, int Rn, int *AElements, double *AVals);
static gdxDataErrorRecord_t gdxDataErrorRecord = NULL;
typedef int (GDX_CALLCONV *gdxDataReadDone_t) (void *pgdx);
static gdxDataReadDone_t gdxDataReadDone = NULL;
typedef int (GDX_CALLCONV *gdxDataReadFilteredStart_t) (void *pgdx, int SyNr, const int *ADomainNrs, int *NrRecs);
static gdxDataReadFilteredStart_t gdxDataReadFilteredStart = NULL;
typedef int (GDX_CALLCONV *gdxDataReadMap_t) (void *pgdx, int Rn, int *AElements, double *AVals, int *AFDim);
static gdxDataReadMap_t gdxDataReadMap = NULL;
typedef int (GDX_CALLCONV *gdxDataReadMapStart_t) (void *pgdx, int SyNr, int *NrRecs);
static gdxDataReadMapStart_t gdxDataReadMapStart = NULL;
typedef int (GDX_CALLCONV *gdxDataReadRaw_t) (void *pgdx, int *AElements, double *AVals, int *AFDim);
static gdxDataReadRaw_t gdxDataReadRaw = NULL;
typedef int (GDX_CALLCONV *gdxDataReadRawStart_t) (void *pgdx, int SyNr, int *NrRecs);
static gdxDataReadRawStart_t gdxDataReadRawStart = NULL;
typedef int (GDX_CALLCONV *gdxDataReadSliceStart_t) (void *pgdx, int ASyNr, int *ANrElems);
static gdxDataReadSliceStart_t gdxDataReadSliceStart = NULL;
typedef int (GDX_CALLCONV *gdxDataReadStr_t) (void *pgdx, char **AStrElements, double *AVals, int *AFDim);
static gdxDataReadStr_t gdxDataReadStr = NULL;
typedef int (GDX_CALLCONV *gdxDataReadStrStart_t) (void *pgdx, int SyNr, int *NrRecs);
static gdxDataReadStrStart_t gdxDataReadStrStart = NULL;
typedef int (GDX_CALLCONV *gdxDataSliceUELS_t) (void *pgdx, const int *AIndx, char **AUELs);
static gdxDataSliceUELS_t gdxDataSliceUELS = NULL;
typedef int (GDX_CALLCONV *gdxDataWriteDone_t) (void *pgdx);
static gdxDataWriteDone_t gdxDataWriteDone = NULL;
typedef int (GDX_CALLCONV *gdxDataWriteMap_t) (void *pgdx, const int *AElements, const double *AVals);
static gdxDataWriteMap_t gdxDataWriteMap = NULL;
typedef int (GDX_CALLCONV *gdxDataWriteMapStart_t) (void *pgdx, const char *AName, const char *Atext, int ADim, int AType, int AUserInfo);
static gdxDataWriteMapStart_t gdxDataWriteMapStart = NULL;
typedef int (GDX_CALLCONV *gdxDataWriteRaw_t) (void *pgdx, const int *AElements, const double *AVals);
static gdxDataWriteRaw_t gdxDataWriteRaw = NULL;
typedef int (GDX_CALLCONV *gdxDataWriteRawStart_t) (void *pgdx, const char *AName, const char *Atext, int ADim, int AType, int AUserInfo);
static gdxDataWriteRawStart_t gdxDataWriteRawStart = NULL;
typedef int (GDX_CALLCONV *gdxDataWriteStr_t) (void *pgdx, const char **AStrElements, const double *AVals);
static gdxDataWriteStr_t gdxDataWriteStr = NULL;
typedef int (GDX_CALLCONV *gdxDataWriteStrStart_t) (void *pgdx, const char *AName, const char *Atext, int ADim, int AType, int AUserInfo);
static gdxDataWriteStrStart_t gdxDataWriteStrStart = NULL;
typedef int (GDX_CALLCONV *gdxGetDLLVersion_t) (void *pgdx, char *V);
static gdxGetDLLVersion_t gdxGetDLLVersion = NULL;
typedef int (GDX_CALLCONV *gdxErrorCount_t) (void *pgdx);
static gdxErrorCount_t gdxErrorCount = NULL;
typedef int (GDX_CALLCONV *gdxErrorStr_t) (void *pgdx, int N, char *s);
static gdxErrorStr_t gdxErrorStr = NULL;
typedef int (GDX_CALLCONV *gdxFileInfo_t) (void *pgdx, int *FileVer, int *ComprLev);
static gdxFileInfo_t gdxFileInfo = NULL;
typedef int (GDX_CALLCONV *gdxFileVersion_t) (void *pgdx, char *FileStr, char *ProduceStr);
static gdxFileVersion_t gdxFileVersion = NULL;
typedef int (GDX_CALLCONV *gdxFilterExists_t) (void *pgdx, int N);
static gdxFilterExists_t gdxFilterExists = NULL;
typedef int (GDX_CALLCONV *gdxFilterRegister_t) (void *pgdx, int V);
static gdxFilterRegister_t gdxFilterRegister = NULL;
typedef int (GDX_CALLCONV *gdxFilterRegisterDone_t) (void *pgdx);
static gdxFilterRegisterDone_t gdxFilterRegisterDone = NULL;
typedef int (GDX_CALLCONV *gdxFilterRegisterStart_t) (void *pgdx, int Nr);
static gdxFilterRegisterStart_t gdxFilterRegisterStart = NULL;
typedef int (GDX_CALLCONV *gdxFindSymbol_t) (void *pgdx, const char *AName, int *AIx);
static gdxFindSymbol_t gdxFindSymbol = NULL;
typedef int (GDX_CALLCONV *gdxGetElemText_t) (void *pgdx, int N, char *s, int *Node);
static gdxGetElemText_t gdxGetElemText = NULL;
typedef int (GDX_CALLCONV *gdxGetLastError_t) (void *pgdx);
static gdxGetLastError_t gdxGetLastError = NULL;
typedef int (GDX_CALLCONV *gdxGetSpecialValues_t) (void *pgdx, double *AVals);
static gdxGetSpecialValues_t gdxGetSpecialValues = NULL;
typedef int (GDX_CALLCONV *gdxGetUEL_t) (void *pgdx, int UelNr, char *s);
static gdxGetUEL_t gdxGetUEL = NULL;
typedef int (GDX_CALLCONV *gdxMapValue_t) (void *pgdx, double D, int *sv);
static gdxMapValue_t gdxMapValue = NULL;
typedef int (GDX_CALLCONV *gdxOpenRead_t) (void *pgdx, const char *Afn, int *ErrNr);
static gdxOpenRead_t gdxOpenRead = NULL;
typedef int (GDX_CALLCONV *gdxOpenWrite_t) (void *pgdx, const char *Afn, const char *AProducer, int *ErrNr);
static gdxOpenWrite_t gdxOpenWrite = NULL;
typedef int (GDX_CALLCONV *gdxOpenWriteEx_t) (void *pgdx, const char *Afn, const char *AProducer, int Compr, int *ErrNr);
static gdxOpenWriteEx_t gdxOpenWriteEx = NULL;
typedef int (GDX_CALLCONV *gdxResetSpecialValues_t) (void *pgdx);
static gdxResetSpecialValues_t gdxResetSpecialValues = NULL;
typedef int (GDX_CALLCONV *gdxSetHasText_t) (void *pgdx, int N);
static gdxSetHasText_t gdxSetHasText = NULL;
typedef int (GDX_CALLCONV *gdxSetReadSpecialValues_t) (void *pgdx, const double *AVals);
static gdxSetReadSpecialValues_t gdxSetReadSpecialValues = NULL;
typedef int (GDX_CALLCONV *gdxSetSpecialValues_t) (void *pgdx, const double *AVals);
static gdxSetSpecialValues_t gdxSetSpecialValues = NULL;
typedef int (GDX_CALLCONV *gdxSetTextNodeNr_t) (void *pgdx, int N, int Node);
static gdxSetTextNodeNr_t gdxSetTextNodeNr = NULL;
typedef int (GDX_CALLCONV *gdxSetTraceLevel_t) (void *pgdx, int N, const char *s);
static gdxSetTraceLevel_t gdxSetTraceLevel = NULL;
typedef int (GDX_CALLCONV *gdxSymbIndxMaxLength_t) (void *pgdx, int SyNr, int *DimInfo);
static gdxSymbIndxMaxLength_t gdxSymbIndxMaxLength = NULL;
typedef int (GDX_CALLCONV *gdxSymbMaxLength_t) (void *pgdx);
static gdxSymbMaxLength_t gdxSymbMaxLength = NULL;
typedef int (GDX_CALLCONV *gdxSymbolAddComment_t) (void *pgdx, int SyNr, const char *s);
static gdxSymbolAddComment_t gdxSymbolAddComment = NULL;
typedef int (GDX_CALLCONV *gdxSymbolGetComment_t) (void *pgdx, int SyNr, int N, char *s);
static gdxSymbolGetComment_t gdxSymbolGetComment = NULL;
typedef int (GDX_CALLCONV *gdxSymbolGetDomain_t) (void *pgdx, int SyNr, int *DomainIDs);
static gdxSymbolGetDomain_t gdxSymbolGetDomain = NULL;
typedef int (GDX_CALLCONV *gdxSymbolInfo_t) (void *pgdx, int SyNr, char *AName, int *ADim, int *ATyp);
static gdxSymbolInfo_t gdxSymbolInfo = NULL;
typedef int (GDX_CALLCONV *gdxSymbolInfoX_t) (void *pgdx, int SyNr, int *ACount, int *AUserInfo, char *AExplTxt);
static gdxSymbolInfoX_t gdxSymbolInfoX = NULL;
typedef int (GDX_CALLCONV *gdxSymbolSetDomain_t) (void *pgdx, const char **DomainIDs);
static gdxSymbolSetDomain_t gdxSymbolSetDomain = NULL;
typedef int (GDX_CALLCONV *gdxSystemInfo_t) (void *pgdx, int *NrSy, int *NrUel);
static gdxSystemInfo_t gdxSystemInfo = NULL;
typedef int (GDX_CALLCONV *gdxUELMaxLength_t) (void *pgdx);
static gdxUELMaxLength_t gdxUELMaxLength = NULL;
typedef int (GDX_CALLCONV *gdxUELRegisterDone_t) (void *pgdx);
static gdxUELRegisterDone_t gdxUELRegisterDone = NULL;
typedef int (GDX_CALLCONV *gdxUELRegisterMap_t) (void *pgdx, int UelNr, const char *Elem);
static gdxUELRegisterMap_t gdxUELRegisterMap = NULL;
typedef int (GDX_CALLCONV *gdxUELRegisterMapStart_t) (void *pgdx);
static gdxUELRegisterMapStart_t gdxUELRegisterMapStart = NULL;
typedef int (GDX_CALLCONV *gdxUELRegisterRaw_t) (void *pgdx, const char *Elem);
static gdxUELRegisterRaw_t gdxUELRegisterRaw = NULL;
typedef int (GDX_CALLCONV *gdxUELRegisterRawStart_t) (void *pgdx);
static gdxUELRegisterRawStart_t gdxUELRegisterRawStart = NULL;
typedef int (GDX_CALLCONV *gdxUELRegisterStr_t) (void *pgdx, const char *Elem, int *UelNr);
static gdxUELRegisterStr_t gdxUELRegisterStr = NULL;
typedef int (GDX_CALLCONV *gdxUELRegisterStrStart_t) (void *pgdx);
static gdxUELRegisterStrStart_t gdxUELRegisterStrStart = NULL;
typedef int (GDX_CALLCONV *gdxUMFindUEL_t) (void *pgdx, const char *s, int *EN, int *UMap);
static gdxUMFindUEL_t gdxUMFindUEL = NULL;
typedef int (GDX_CALLCONV *gdxUMUelGet_t) (void *pgdx, int N, char *s, int *UMap);
static gdxUMUelGet_t gdxUMUelGet = NULL;
typedef int (GDX_CALLCONV *gdxUMUelInfo_t) (void *pgdx, int *NrElem, int *HighMap);
static gdxUMUelInfo_t gdxUMUelInfo = NULL;
typedef int (GDX_CALLCONV *gdxCurrentDim_t) (void *pgdx);
static gdxCurrentDim_t gdxCurrentDim = NULL;

static soHandle_t
loadLib (const char *libName, char **errMsg)
{
  soHandle_t h;
  int flag = 0;

#if defined(_WIN32)
  h = LoadLibrary (libName);
  if (NULL == h) {
    *errMsg = winErr;
  }
  else {
    *errMsg = NULL;
  }
#elif defined(CIA_HP7)
  flag = BIND_IMMEDIATE | BIND_VERBOSE | DYNAMIC_PATH;
  h = shl_load (libName, flag, 0L);
  if (NULL == h) {
    *errMsg = strerror(errno);
  }
  else {
    *errMsg = NULL;
  }
#else
  (void) dlerror();
  h = dlopen (libName, RTLD_NOW);
  if (NULL == h) {
    *errMsg = dlerror();
  }
  else {
    *errMsg = NULL;
  }
#endif

  return h;
} /* loadLib */

static int
unLoadLib (soHandle_t h)
{
  int rc;

#if defined(_WIN32)
  rc = FreeLibrary (h);
  return ! rc;
#elif defined(CIA_HP7)
  rc = shl_unload (h);
#else
  rc = dlclose (h);
#endif
  return rc;
} /* unLoadLib */

static void *
loadSym (soHandle_t h, const char *sym, char **errMsg)
{
  void *s;
  const char *from;
  char *to;
  const char *tripSym;
  char lcbuf[257];
  char ucbuf[257];
  char ocbuf[257];
  size_t symLen;
  int trip;
#if defined(CIA_HP7)
  int rc;
#endif

  /* search in this order:
   *  1. original
   *  2. lower_
   *  3. upper_
   *  4. original_
   *  5. lower
   *  6. upper
   */

  symLen = 0;
  for (trip = 1;  trip <= 6;  trip++) {
    switch (trip) {
    case 1:                             /* original */
      tripSym = sym;
      break;
    case 2:                             /* lower_ */
      for (from = sym, to = lcbuf;  *from;  from++, to++) {
        *to = tolower(*from);
      }
      symLen = from - sym;
      *to++ = '_';
      *to = '\0';
      tripSym = lcbuf;
      break;
    case 3:                             /* upper_ */
      for (from = sym, to = ucbuf;  *from;  from++, to++) {
        *to = toupper(*from);
      }
      *to++ = '_';
      *to = '\0';
      tripSym = ucbuf;
      break;
    case 4:                             /* original_ */
      memcpy (ocbuf, sym, symLen);
      ocbuf[symLen] = '_';
      ocbuf[symLen+1] = '\0';
      tripSym = ocbuf;
      break;
    case 5:                             /* lower */
      lcbuf[symLen] = '\0';
      tripSym = lcbuf;
      break;
    case 6:                             /* upper */
      ucbuf[symLen] = '\0';
      tripSym = ucbuf;
      break;
    default:
      tripSym = sym;
    } /* end switch */
#if defined(_WIN32)
    s = GetProcAddress (h, tripSym);
    if (NULL != s) {
      return s;
    }
#elif defined(CIA_HP7)
    rc = shl_findsym (&h, tripSym, TYPE_UNDEFINED, &s);
    if (rc) {                     /* failure */
      *errMsg = strerror(errno);
    }
    else {                        /* success */
      *errMsg = NULL;
      return s;
    }
#else
    (void) dlerror();
    s = dlsym (h, tripSym);
    *errMsg = dlerror();
    if (NULL == *errMsg) {
      return s;
    }
#endif
  } /* end loop over symbol name variations */

  return NULL;
} /* loadSym */

/* TNAME = type name, ENAME = exported name */
#define LOADIT(TNAME,ENAME) symName = ENAME; TNAME = (TNAME##_t) loadSym (hLibGlobal, symName, &errMsg); if (NULL == TNAME) goto symMissing
#define LOADIT_ERR_OK(TNAME,ENAME) symName = ENAME; TNAME = (TNAME##_t) loadSym (hLibGlobal, symName, &errMsg)

#if defined(CIA_LEX) || defined(CIA_WEX) || defined(CIA_SOX)
# define SUFFIX "64"
#else
# define SUFFIX ""
#endif
#if defined(_WIN32)
# define BASENAME "gdxdclib"
# define EXTENSION ".dll"
#elif defined(CIA_HP7)
# define BASENAME "libgdxdclib"
# define EXTENSION ".sl"
#elif defined(CIA_DAR) || defined(CIA_DII)
# define BASENAME "libgdxdclib"
# define EXTENSION ".dylib"
#else
# define BASENAME "libgdxdclib"
# define EXTENSION ".so"
#endif

/* XLibraryLoad: return 0 on success, ~0 on failure */
static int
XLibraryLoad (const char *dllName, char *errBuf, int errBufLen)
{
  char *errMsg;
  char *symName;
  int rc, elen, cl;
  char *ebuf;
  char dllNameBuf[512];

  if (isLoaded)
    return 0;
  if (NULL != dllName && '\0' != *dllName) {
    strncpy(dllNameBuf, dllName, sizeof(dllNameBuf));
    dllNameBuf[sizeof(dllNameBuf)-1] = '\0';
  }
  else {
    strcpy(dllNameBuf, BASENAME SUFFIX EXTENSION);
  }
  hLibGlobal = loadLib (dllNameBuf, &errMsg);
  if (NULL == hLibGlobal) {
    if (NULL != errBuf) {
      elen = errBufLen;  ebuf = errBuf;
      rc = sprintf (ebuf, "%.*s", elen, "Could not load shared library ");
      elen -= rc;  ebuf+= rc;
      rc = sprintf (ebuf, "%.*s", elen, dllNameBuf);
      elen -= rc;  ebuf+= rc;
      rc = sprintf (ebuf, "%.*s", elen, ": ");
      elen -= rc;  ebuf+= rc;
      rc = sprintf (ebuf, "%.*s", elen, errMsg);
      elen -= rc;  ebuf+= rc;
      errBuf[errBufLen-1] = '\0';
    }
    return 1;
  }
  else {
     /* printf ("Loaded shared library %s successfully\n", dllName); */
  }

  LOADIT(XCreate, "XCreate");
  LOADIT(XFree, "XFree");
  LOADIT(XCheck, "CXCheck");
  LOADIT(XAPIVersion, "CXAPIVersion");

  if (!XAPIVersion(7,errBuf,&cl))
    return 1;

  LOADIT_ERR_OK(gdxSetLoadPath, "CgdxSetLoadPath");
  LOADIT_ERR_OK(gdxGetLoadPath, "CgdxGetLoadPath");

  { int s[]={3};
    if(!XCheck("gdxAcronymCount",0,s,errBuf))  gdxAcronymCount=&d_gdxAcronymCount;
    else { LOADIT(gdxAcronymCount,"gdxAcronymCount"); }  }
  { int s[]={3,3,12,12,4};
    if(!XCheck("gdxAcronymGetInfo",4,s,errBuf))  gdxAcronymGetInfo=&d_gdxAcronymGetInfo;
    else { LOADIT(gdxAcronymGetInfo,"gdxAcronymGetInfo"); }  }
  { int s[]={3,13};
    if(!XCheck("gdxAcronymIndex",1,s,errBuf))  gdxAcronymIndex=&d_gdxAcronymIndex;
    else { LOADIT(gdxAcronymIndex,"gdxAcronymIndex"); }  }
  { int s[]={3,13,12};
    if(!XCheck("gdxAcronymName",2,s,errBuf))  gdxAcronymName=&d_gdxAcronymName;
    else { LOADIT(gdxAcronymName,"gdxAcronymName"); }  }
  { int s[]={3,3,11,11,3};
    if(!XCheck("gdxAcronymSetInfo",4,s,errBuf))  gdxAcronymSetInfo=&d_gdxAcronymSetInfo;
    else { LOADIT(gdxAcronymSetInfo,"gdxAcronymSetInfo"); }  }
  { int s[]={13,3};
    if(!XCheck("gdxAcronymValue",1,s,errBuf))  gdxAcronymValue=&d_gdxAcronymValue;
    else { LOADIT(gdxAcronymValue,"gdxAcronymValue"); }  }
  { int s[]={3,11,11};
    if(!XCheck("gdxAddAlias",2,s,errBuf))  gdxAddAlias=&d_gdxAddAlias;
    else { LOADIT(gdxAddAlias,"gdxAddAlias"); }  }
  { int s[]={3,11,4};
    if(!XCheck("gdxAddSetText",2,s,errBuf))  gdxAddSetText=&d_gdxAddSetText;
    else { LOADIT(gdxAddSetText,"gdxAddSetText"); }  }
  { int s[]={3,3};
    if(!XCheck("gdxAutoConvert",1,s,errBuf))  gdxAutoConvert=&d_gdxAutoConvert;
    else { LOADIT(gdxAutoConvert,"gdxAutoConvert"); }  }
  { int s[]={3};
    if(!XCheck("gdxClose",0,s,errBuf))  gdxClose=&d_gdxClose;
    else { LOADIT(gdxClose,"gdxClose"); }  }
  { int s[]={3};
    if(!XCheck("gdxDataErrorCount",0,s,errBuf))  gdxDataErrorCount=&d_gdxDataErrorCount;
    else { LOADIT(gdxDataErrorCount,"gdxDataErrorCount"); }  }
  { int s[]={3,3,52,54};
    if(!XCheck("gdxDataErrorRecord",3,s,errBuf))  gdxDataErrorRecord=&d_gdxDataErrorRecord;
    else { LOADIT(gdxDataErrorRecord,"gdxDataErrorRecord"); }  }
  { int s[]={3};
    if(!XCheck("gdxDataReadDone",0,s,errBuf))  gdxDataReadDone=&d_gdxDataReadDone;
    else { LOADIT(gdxDataReadDone,"gdxDataReadDone"); }  }
  { int s[]={3,3,51,4};
    if(!XCheck("gdxDataReadFilteredStart",3,s,errBuf))  gdxDataReadFilteredStart=&d_gdxDataReadFilteredStart;
    else { LOADIT(gdxDataReadFilteredStart,"gdxDataReadFilteredStart"); }  }
  { int s[]={3,3,52,54,4};
    if(!XCheck("gdxDataReadMap",4,s,errBuf))  gdxDataReadMap=&d_gdxDataReadMap;
    else { LOADIT(gdxDataReadMap,"gdxDataReadMap"); }  }
  { int s[]={3,3,4};
    if(!XCheck("gdxDataReadMapStart",2,s,errBuf))  gdxDataReadMapStart=&d_gdxDataReadMapStart;
    else { LOADIT(gdxDataReadMapStart,"gdxDataReadMapStart"); }  }
  { int s[]={3,52,54,4};
    if(!XCheck("gdxDataReadRaw",3,s,errBuf))  gdxDataReadRaw=&d_gdxDataReadRaw;
    else { LOADIT(gdxDataReadRaw,"gdxDataReadRaw"); }  }
  { int s[]={3,3,4};
    if(!XCheck("gdxDataReadRawStart",2,s,errBuf))  gdxDataReadRawStart=&d_gdxDataReadRawStart;
    else { LOADIT(gdxDataReadRawStart,"gdxDataReadRawStart"); }  }
  { int s[]={3,3,52};
    if(!XCheck("gdxDataReadSliceStart",2,s,errBuf))  gdxDataReadSliceStart=&d_gdxDataReadSliceStart;
    else { LOADIT(gdxDataReadSliceStart,"gdxDataReadSliceStart"); }  }
  { int s[]={3,56,54,4};
    if(!XCheck("gdxDataReadStr",3,s,errBuf))  gdxDataReadStr=&d_gdxDataReadStr;
    else { LOADIT(gdxDataReadStr,"gdxDataReadStr"); }  }
  { int s[]={3,3,4};
    if(!XCheck("gdxDataReadStrStart",2,s,errBuf))  gdxDataReadStrStart=&d_gdxDataReadStrStart;
    else { LOADIT(gdxDataReadStrStart,"gdxDataReadStrStart"); }  }
  { int s[]={3,51,56};
    if(!XCheck("gdxDataSliceUELS",2,s,errBuf))  gdxDataSliceUELS=&d_gdxDataSliceUELS;
    else { LOADIT(gdxDataSliceUELS,"gdxDataSliceUELS"); }  }
  { int s[]={3};
    if(!XCheck("gdxDataWriteDone",0,s,errBuf))  gdxDataWriteDone=&d_gdxDataWriteDone;
    else { LOADIT(gdxDataWriteDone,"gdxDataWriteDone"); }  }
  { int s[]={3,51,53};
    if(!XCheck("gdxDataWriteMap",2,s,errBuf))  gdxDataWriteMap=&d_gdxDataWriteMap;
    else { LOADIT(gdxDataWriteMap,"gdxDataWriteMap"); }  }
  { int s[]={3,11,11,3,3,3};
    if(!XCheck("gdxDataWriteMapStart",5,s,errBuf))  gdxDataWriteMapStart=&d_gdxDataWriteMapStart;
    else { LOADIT(gdxDataWriteMapStart,"gdxDataWriteMapStart"); }  }
  { int s[]={3,51,53};
    if(!XCheck("gdxDataWriteRaw",2,s,errBuf))  gdxDataWriteRaw=&d_gdxDataWriteRaw;
    else { LOADIT(gdxDataWriteRaw,"gdxDataWriteRaw"); }  }
  { int s[]={3,11,11,3,3,3};
    if(!XCheck("gdxDataWriteRawStart",5,s,errBuf))  gdxDataWriteRawStart=&d_gdxDataWriteRawStart;
    else { LOADIT(gdxDataWriteRawStart,"gdxDataWriteRawStart"); }  }
  { int s[]={3,55,53};
    if(!XCheck("gdxDataWriteStr",2,s,errBuf))  gdxDataWriteStr=&d_gdxDataWriteStr;
    else { LOADIT(gdxDataWriteStr,"gdxDataWriteStr"); }  }
  { int s[]={3,11,11,3,3,3};
    if(!XCheck("gdxDataWriteStrStart",5,s,errBuf))  gdxDataWriteStrStart=&d_gdxDataWriteStrStart;
    else { LOADIT(gdxDataWriteStrStart,"gdxDataWriteStrStart"); }  }
  { int s[]={3,12};
    if(!XCheck("gdxGetDLLVersion",1,s,errBuf))  gdxGetDLLVersion=&d_gdxGetDLLVersion;
    else { LOADIT(gdxGetDLLVersion,"gdxGetDLLVersion"); }  }
  { int s[]={3};
    if(!XCheck("gdxErrorCount",0,s,errBuf))  gdxErrorCount=&d_gdxErrorCount;
    else { LOADIT(gdxErrorCount,"gdxErrorCount"); }  }
  { int s[]={3,3,12};
    if(!XCheck("gdxErrorStr",2,s,errBuf))  gdxErrorStr=&d_gdxErrorStr;
    else { LOADIT(gdxErrorStr,"gdxErrorStr"); }  }
  { int s[]={3,4,4};
    if(!XCheck("gdxFileInfo",2,s,errBuf))  gdxFileInfo=&d_gdxFileInfo;
    else { LOADIT(gdxFileInfo,"gdxFileInfo"); }  }
  { int s[]={3,12,12};
    if(!XCheck("gdxFileVersion",2,s,errBuf))  gdxFileVersion=&d_gdxFileVersion;
    else { LOADIT(gdxFileVersion,"gdxFileVersion"); }  }
  { int s[]={3,3};
    if(!XCheck("gdxFilterExists",1,s,errBuf))  gdxFilterExists=&d_gdxFilterExists;
    else { LOADIT(gdxFilterExists,"gdxFilterExists"); }  }
  { int s[]={3,3};
    if(!XCheck("gdxFilterRegister",1,s,errBuf))  gdxFilterRegister=&d_gdxFilterRegister;
    else { LOADIT(gdxFilterRegister,"gdxFilterRegister"); }  }
  { int s[]={3};
    if(!XCheck("gdxFilterRegisterDone",0,s,errBuf))  gdxFilterRegisterDone=&d_gdxFilterRegisterDone;
    else { LOADIT(gdxFilterRegisterDone,"gdxFilterRegisterDone"); }  }
  { int s[]={3,3};
    if(!XCheck("gdxFilterRegisterStart",1,s,errBuf))  gdxFilterRegisterStart=&d_gdxFilterRegisterStart;
    else { LOADIT(gdxFilterRegisterStart,"gdxFilterRegisterStart"); }  }
  { int s[]={3,11,4};
    if(!XCheck("gdxFindSymbol",2,s,errBuf))  gdxFindSymbol=&d_gdxFindSymbol;
    else { LOADIT(gdxFindSymbol,"gdxFindSymbol"); }  }
  { int s[]={3,3,12,4};
    if(!XCheck("gdxGetElemText",3,s,errBuf))  gdxGetElemText=&d_gdxGetElemText;
    else { LOADIT(gdxGetElemText,"gdxGetElemText"); }  }
  { int s[]={3};
    if(!XCheck("gdxGetLastError",0,s,errBuf))  gdxGetLastError=&d_gdxGetLastError;
    else { LOADIT(gdxGetLastError,"gdxGetLastError"); }  }
  { int s[]={3,58};
    if(!XCheck("gdxGetSpecialValues",1,s,errBuf))  gdxGetSpecialValues=&d_gdxGetSpecialValues;
    else { LOADIT(gdxGetSpecialValues,"gdxGetSpecialValues"); }  }
  { int s[]={3,3,12};
    if(!XCheck("gdxGetUEL",2,s,errBuf))  gdxGetUEL=&d_gdxGetUEL;
    else { LOADIT(gdxGetUEL,"gdxGetUEL"); }  }
  { int s[]={3,13,4};
    if(!XCheck("gdxMapValue",2,s,errBuf))  gdxMapValue=&d_gdxMapValue;
    else { LOADIT(gdxMapValue,"gdxMapValue"); }  }
  { int s[]={3,11,4};
    if(!XCheck("gdxOpenRead",2,s,errBuf))  gdxOpenRead=&d_gdxOpenRead;
    else { LOADIT(gdxOpenRead,"gdxOpenRead"); }  }
  { int s[]={3,11,11,4};
    if(!XCheck("gdxOpenWrite",3,s,errBuf))  gdxOpenWrite=&d_gdxOpenWrite;
    else { LOADIT(gdxOpenWrite,"gdxOpenWrite"); }  }
  { int s[]={3,11,11,3,4};
    if(!XCheck("gdxOpenWriteEx",4,s,errBuf))  gdxOpenWriteEx=&d_gdxOpenWriteEx;
    else { LOADIT(gdxOpenWriteEx,"gdxOpenWriteEx"); }  }
  { int s[]={3};
    if(!XCheck("gdxResetSpecialValues",0,s,errBuf))  gdxResetSpecialValues=&d_gdxResetSpecialValues;
    else { LOADIT(gdxResetSpecialValues,"gdxResetSpecialValues"); }  }
  { int s[]={3,3};
    if(!XCheck("gdxSetHasText",1,s,errBuf))  gdxSetHasText=&d_gdxSetHasText;
    else { LOADIT(gdxSetHasText,"gdxSetHasText"); }  }
  { int s[]={3,57};
    if(!XCheck("gdxSetReadSpecialValues",1,s,errBuf))  gdxSetReadSpecialValues=&d_gdxSetReadSpecialValues;
    else { LOADIT(gdxSetReadSpecialValues,"gdxSetReadSpecialValues"); }  }
  { int s[]={3,57};
    if(!XCheck("gdxSetSpecialValues",1,s,errBuf))  gdxSetSpecialValues=&d_gdxSetSpecialValues;
    else { LOADIT(gdxSetSpecialValues,"gdxSetSpecialValues"); }  }
  { int s[]={3,3,3};
    if(!XCheck("gdxSetTextNodeNr",2,s,errBuf))  gdxSetTextNodeNr=&d_gdxSetTextNodeNr;
    else { LOADIT(gdxSetTextNodeNr,"gdxSetTextNodeNr"); }  }
  { int s[]={3,3,11};
    if(!XCheck("gdxSetTraceLevel",2,s,errBuf))  gdxSetTraceLevel=&d_gdxSetTraceLevel;
    else { LOADIT(gdxSetTraceLevel,"gdxSetTraceLevel"); }  }
  { int s[]={3,3,52};
    if(!XCheck("gdxSymbIndxMaxLength",2,s,errBuf))  gdxSymbIndxMaxLength=&d_gdxSymbIndxMaxLength;
    else { LOADIT(gdxSymbIndxMaxLength,"gdxSymbIndxMaxLength"); }  }
  { int s[]={3};
    if(!XCheck("gdxSymbMaxLength",0,s,errBuf))  gdxSymbMaxLength=&d_gdxSymbMaxLength;
    else { LOADIT(gdxSymbMaxLength,"gdxSymbMaxLength"); }  }
  { int s[]={3,3,11};
    if(!XCheck("gdxSymbolAddComment",2,s,errBuf))  gdxSymbolAddComment=&d_gdxSymbolAddComment;
    else { LOADIT(gdxSymbolAddComment,"gdxSymbolAddComment"); }  }
  { int s[]={3,3,3,12};
    if(!XCheck("gdxSymbolGetComment",3,s,errBuf))  gdxSymbolGetComment=&d_gdxSymbolGetComment;
    else { LOADIT(gdxSymbolGetComment,"gdxSymbolGetComment"); }  }
  { int s[]={3,3,52};
    if(!XCheck("gdxSymbolGetDomain",2,s,errBuf))  gdxSymbolGetDomain=&d_gdxSymbolGetDomain;
    else { LOADIT(gdxSymbolGetDomain,"gdxSymbolGetDomain"); }  }
  { int s[]={3,3,12,4,4};
    if(!XCheck("gdxSymbolInfo",4,s,errBuf))  gdxSymbolInfo=&d_gdxSymbolInfo;
    else { LOADIT(gdxSymbolInfo,"gdxSymbolInfo"); }  }
  { int s[]={3,3,4,4,12};
    if(!XCheck("gdxSymbolInfoX",4,s,errBuf))  gdxSymbolInfoX=&d_gdxSymbolInfoX;
    else { LOADIT(gdxSymbolInfoX,"gdxSymbolInfoX"); }  }
  { int s[]={3,55};
    if(!XCheck("gdxSymbolSetDomain",1,s,errBuf))  gdxSymbolSetDomain=&d_gdxSymbolSetDomain;
    else { LOADIT(gdxSymbolSetDomain,"gdxSymbolSetDomain"); }  }
  { int s[]={3,4,4};
    if(!XCheck("gdxSystemInfo",2,s,errBuf))  gdxSystemInfo=&d_gdxSystemInfo;
    else { LOADIT(gdxSystemInfo,"gdxSystemInfo"); }  }
  { int s[]={3};
    if(!XCheck("gdxUELMaxLength",0,s,errBuf))  gdxUELMaxLength=&d_gdxUELMaxLength;
    else { LOADIT(gdxUELMaxLength,"gdxUELMaxLength"); }  }
  { int s[]={3};
    if(!XCheck("gdxUELRegisterDone",0,s,errBuf))  gdxUELRegisterDone=&d_gdxUELRegisterDone;
    else { LOADIT(gdxUELRegisterDone,"gdxUELRegisterDone"); }  }
  { int s[]={3,3,11};
    if(!XCheck("gdxUELRegisterMap",2,s,errBuf))  gdxUELRegisterMap=&d_gdxUELRegisterMap;
    else { LOADIT(gdxUELRegisterMap,"gdxUELRegisterMap"); }  }
  { int s[]={3};
    if(!XCheck("gdxUELRegisterMapStart",0,s,errBuf))  gdxUELRegisterMapStart=&d_gdxUELRegisterMapStart;
    else { LOADIT(gdxUELRegisterMapStart,"gdxUELRegisterMapStart"); }  }
  { int s[]={3,11};
    if(!XCheck("gdxUELRegisterRaw",1,s,errBuf))  gdxUELRegisterRaw=&d_gdxUELRegisterRaw;
    else { LOADIT(gdxUELRegisterRaw,"gdxUELRegisterRaw"); }  }
  { int s[]={3};
    if(!XCheck("gdxUELRegisterRawStart",0,s,errBuf))  gdxUELRegisterRawStart=&d_gdxUELRegisterRawStart;
    else { LOADIT(gdxUELRegisterRawStart,"gdxUELRegisterRawStart"); }  }
  { int s[]={3,11,4};
    if(!XCheck("gdxUELRegisterStr",2,s,errBuf))  gdxUELRegisterStr=&d_gdxUELRegisterStr;
    else { LOADIT(gdxUELRegisterStr,"gdxUELRegisterStr"); }  }
  { int s[]={3};
    if(!XCheck("gdxUELRegisterStrStart",0,s,errBuf))  gdxUELRegisterStrStart=&d_gdxUELRegisterStrStart;
    else { LOADIT(gdxUELRegisterStrStart,"gdxUELRegisterStrStart"); }  }
  { int s[]={3,11,4,4};
    if(!XCheck("gdxUMFindUEL",3,s,errBuf))  gdxUMFindUEL=&d_gdxUMFindUEL;
    else { LOADIT(gdxUMFindUEL,"gdxUMFindUEL"); }  }
  { int s[]={3,3,12,4};
    if(!XCheck("gdxUMUelGet",3,s,errBuf))  gdxUMUelGet=&d_gdxUMUelGet;
    else { LOADIT(gdxUMUelGet,"gdxUMUelGet"); }  }
  { int s[]={3,4,4};
    if(!XCheck("gdxUMUelInfo",2,s,errBuf))  gdxUMUelInfo=&d_gdxUMUelInfo;
    else { LOADIT(gdxUMUelInfo,"gdxUMUelInfo"); }  }
  { int s[]={3};
    if(!XCheck("gdxCurrentDim",0,s,errBuf))  gdxCurrentDim=&d_gdxCurrentDim;
    else { LOADIT(gdxCurrentDim,"gdxCurrentDim"); }  }

  return 0;

 symMissing:
  elen = errBufLen;  ebuf = errBuf;
  rc = sprintf (ebuf, "%.*s", elen, "Could not load symbol '");
  elen -= rc;  ebuf+= rc;
  rc = sprintf (ebuf, "%.*s", elen, symName);
  elen -= rc;  ebuf+= rc;
  rc = sprintf (ebuf, "%.*s", elen, "': ");
  elen -= rc;  ebuf+= rc;
  rc = sprintf (ebuf, "%.*s", elen, errMsg);
  elen -= rc;  ebuf+= rc;
  errBuf[errBufLen-1] = '\0';
  printf ("%s\n", errBuf);
  return 2;
} /* XLibraryLoad */


#if   defined(APIWRAP_LCASE_DECOR)  /* fortran names: lower case, trailing _ */
# define C_GDXACRONYMCOUNT             c_gdxacronymcount_
# define C_GDXACRONYMGETINFO           c_gdxacronymgetinfo_
# define C_GDXACRONYMINDEX             c_gdxacronymindex_
# define C_GDXACRONYMNAME              c_gdxacronymname_
# define C_GDXACRONYMSETINFO           c_gdxacronymsetinfo_
# define C_GDXACRONYMVALUE             c_gdxacronymvalue_
# define C_GDXADDALIAS                 c_gdxaddalias_
# define C_GDXADDSETTEXT               c_gdxaddsettext_
# define C_GDXAUTOCONVERT              c_gdxautoconvert_
# define C_GDXCLOSE                    c_gdxclose_
# define C_GDXDATAERRORCOUNT           c_gdxdataerrorcount_
# define C_GDXDATAERRORRECORD          c_gdxdataerrorrecord_
# define C_GDXDATAREADDONE             c_gdxdatareaddone_
# define C_GDXDATAREADFILTEREDSTART    c_gdxdatareadfilteredstart_
# define C_GDXDATAREADMAP              c_gdxdatareadmap_
# define C_GDXDATAREADMAPSTART         c_gdxdatareadmapstart_
# define C_GDXDATAREADRAW              c_gdxdatareadraw_
# define C_GDXDATAREADRAWSTART         c_gdxdatareadrawstart_
# define C_GDXDATAREADSLICE            c_gdxdatareadslice_
# define C_GDXDATAREADSLICESTART       c_gdxdatareadslicestart_
# define C_GDXDATAREADSTR              c_gdxdatareadstr_
# define C_GDXDATAREADSTRSTART         c_gdxdatareadstrstart_
# define C_GDXDATASLICEUELS            c_gdxdatasliceuels_
# define C_GDXDATAWRITEDONE            c_gdxdatawritedone_
# define C_GDXDATAWRITEMAP             c_gdxdatawritemap_
# define C_GDXDATAWRITEMAPSTART        c_gdxdatawritemapstart_
# define C_GDXDATAWRITERAW             c_gdxdatawriteraw_
# define C_GDXDATAWRITERAWSTART        c_gdxdatawriterawstart_
# define C_GDXDATAWRITESTR             c_gdxdatawritestr_
# define C_GDXDATAWRITESTRSTART        c_gdxdatawritestrstart_
# define C_GDXGETDLLVERSION            c_gdxgetdllversion_
# define C_GDXERRORCOUNT               c_gdxerrorcount_
# define C_GDXERRORSTR                 c_gdxerrorstr_
# define C_GDXFILEINFO                 c_gdxfileinfo_
# define C_GDXFILEVERSION              c_gdxfileversion_
# define C_GDXFILTEREXISTS             c_gdxfilterexists_
# define C_GDXFILTERREGISTER           c_gdxfilterregister_
# define C_GDXFILTERREGISTERDONE       c_gdxfilterregisterdone_
# define C_GDXFILTERREGISTERSTART      c_gdxfilterregisterstart_
# define C_GDXFINDSYMBOL               c_gdxfindsymbol_
# define C_GDXGETELEMTEXT              c_gdxgetelemtext_
# define C_GDXGETLASTERROR             c_gdxgetlasterror_
# define C_GDXGETSPECIALVALUES         c_gdxgetspecialvalues_
# define C_GDXGETUEL                   c_gdxgetuel_
# define C_GDXMAPVALUE                 c_gdxmapvalue_
# define C_GDXOPENREAD                 c_gdxopenread_
# define C_GDXOPENWRITE                c_gdxopenwrite_
# define C_GDXOPENWRITEEX              c_gdxopenwriteex_
# define C_GDXRESETSPECIALVALUES       c_gdxresetspecialvalues_
# define C_GDXSETHASTEXT               c_gdxsethastext_
# define C_GDXSETREADSPECIALVALUES     c_gdxsetreadspecialvalues_
# define C_GDXSETSPECIALVALUES         c_gdxsetspecialvalues_
# define C_GDXSETTEXTNODENR            c_gdxsettextnodenr_
# define C_GDXSETTRACELEVEL            c_gdxsettracelevel_
# define C_GDXSYMBINDXMAXLENGTH        c_gdxsymbindxmaxlength_
# define C_GDXSYMBMAXLENGTH            c_gdxsymbmaxlength_
# define C_GDXSYMBOLADDCOMMENT         c_gdxsymboladdcomment_
# define C_GDXSYMBOLGETCOMMENT         c_gdxsymbolgetcomment_
# define C_GDXSYMBOLGETDOMAIN          c_gdxsymbolgetdomain_
# define C_GDXSYMBOLINFO               c_gdxsymbolinfo_
# define C_GDXSYMBOLINFOX              c_gdxsymbolinfox_
# define C_GDXSYMBOLSETDOMAIN          c_gdxsymbolsetdomain_
# define C_GDXSYSTEMINFO               c_gdxsysteminfo_
# define C_GDXUELMAXLENGTH             c_gdxuelmaxlength_
# define C_GDXUELREGISTERDONE          c_gdxuelregisterdone_
# define C_GDXUELREGISTERMAP           c_gdxuelregistermap_
# define C_GDXUELREGISTERMAPSTART      c_gdxuelregistermapstart_
# define C_GDXUELREGISTERRAW           c_gdxuelregisterraw_
# define C_GDXUELREGISTERRAWSTART      c_gdxuelregisterrawstart_
# define C_GDXUELREGISTERSTR           c_gdxuelregisterstr_
# define C_GDXUELREGISTERSTRSTART      c_gdxuelregisterstrstart_
# define C_GDXUMFINDUEL                c_gdxumfinduel_
# define C_GDXUMUELGET                 c_gdxumuelget_
# define C_GDXUMUELINFO                c_gdxumuelinfo_
# define C_GDXCURRENTDIM               c_gdxcurrentdim_
# define C_GDXCREATE                   c_gdxcreate_
# define C_GDXCREATED                  c_gdxcreated_
# define C_GDXCREATEL                  c_gdxcreatel_
# define C_GDXGETREADY                 c_gdxgetready_
# define C_GDXGETREADYD                c_gdxgetreadyd_
# define C_GDXGETREADYL                c_gdxgetreadyl_
# define C_GDXEXIT                     c_gdxexit_
# define C_GDXFREE                     c_gdxfree_
# define C_GDXGETAPIERRORCOUNT         c_gdxgetapierrorcount_
# define C_GDXGETSCREENINDICATOR       c_gdxgetscreenindicator_
# define C_GDXSETSCREENINDICATOR       c_gdxsetscreenindicator_
# define C_GDXSETERRORCALLBACK         c_gdxseterrorcallback_
#elif defined(APIWRAP_LCASE_NODECOR)/* fortran names: lower case, no _ */
# define C_GDXACRONYMCOUNT             c_gdxacronymcount
# define C_GDXACRONYMGETINFO           c_gdxacronymgetinfo
# define C_GDXACRONYMINDEX             c_gdxacronymindex
# define C_GDXACRONYMNAME              c_gdxacronymname
# define C_GDXACRONYMSETINFO           c_gdxacronymsetinfo
# define C_GDXACRONYMVALUE             c_gdxacronymvalue
# define C_GDXADDALIAS                 c_gdxaddalias
# define C_GDXADDSETTEXT               c_gdxaddsettext
# define C_GDXAUTOCONVERT              c_gdxautoconvert
# define C_GDXCLOSE                    c_gdxclose
# define C_GDXDATAERRORCOUNT           c_gdxdataerrorcount
# define C_GDXDATAERRORRECORD          c_gdxdataerrorrecord
# define C_GDXDATAREADDONE             c_gdxdatareaddone
# define C_GDXDATAREADFILTEREDSTART    c_gdxdatareadfilteredstart
# define C_GDXDATAREADMAP              c_gdxdatareadmap
# define C_GDXDATAREADMAPSTART         c_gdxdatareadmapstart
# define C_GDXDATAREADRAW              c_gdxdatareadraw
# define C_GDXDATAREADRAWSTART         c_gdxdatareadrawstart
# define C_GDXDATAREADSLICE            c_gdxdatareadslice
# define C_GDXDATAREADSLICESTART       c_gdxdatareadslicestart
# define C_GDXDATAREADSTR              c_gdxdatareadstr
# define C_GDXDATAREADSTRSTART         c_gdxdatareadstrstart
# define C_GDXDATASLICEUELS            c_gdxdatasliceuels
# define C_GDXDATAWRITEDONE            c_gdxdatawritedone
# define C_GDXDATAWRITEMAP             c_gdxdatawritemap
# define C_GDXDATAWRITEMAPSTART        c_gdxdatawritemapstart
# define C_GDXDATAWRITERAW             c_gdxdatawriteraw
# define C_GDXDATAWRITERAWSTART        c_gdxdatawriterawstart
# define C_GDXDATAWRITESTR             c_gdxdatawritestr
# define C_GDXDATAWRITESTRSTART        c_gdxdatawritestrstart
# define C_GDXGETDLLVERSION            c_gdxgetdllversion
# define C_GDXERRORCOUNT               c_gdxerrorcount
# define C_GDXERRORSTR                 c_gdxerrorstr
# define C_GDXFILEINFO                 c_gdxfileinfo
# define C_GDXFILEVERSION              c_gdxfileversion
# define C_GDXFILTEREXISTS             c_gdxfilterexists
# define C_GDXFILTERREGISTER           c_gdxfilterregister
# define C_GDXFILTERREGISTERDONE       c_gdxfilterregisterdone
# define C_GDXFILTERREGISTERSTART      c_gdxfilterregisterstart
# define C_GDXFINDSYMBOL               c_gdxfindsymbol
# define C_GDXGETELEMTEXT              c_gdxgetelemtext
# define C_GDXGETLASTERROR             c_gdxgetlasterror
# define C_GDXGETSPECIALVALUES         c_gdxgetspecialvalues
# define C_GDXGETUEL                   c_gdxgetuel
# define C_GDXMAPVALUE                 c_gdxmapvalue
# define C_GDXOPENREAD                 c_gdxopenread
# define C_GDXOPENWRITE                c_gdxopenwrite
# define C_GDXOPENWRITEEX              c_gdxopenwriteex
# define C_GDXRESETSPECIALVALUES       c_gdxresetspecialvalues
# define C_GDXSETHASTEXT               c_gdxsethastext
# define C_GDXSETREADSPECIALVALUES     c_gdxsetreadspecialvalues
# define C_GDXSETSPECIALVALUES         c_gdxsetspecialvalues
# define C_GDXSETTEXTNODENR            c_gdxsettextnodenr
# define C_GDXSETTRACELEVEL            c_gdxsettracelevel
# define C_GDXSYMBINDXMAXLENGTH        c_gdxsymbindxmaxlength
# define C_GDXSYMBMAXLENGTH            c_gdxsymbmaxlength
# define C_GDXSYMBOLADDCOMMENT         c_gdxsymboladdcomment
# define C_GDXSYMBOLGETCOMMENT         c_gdxsymbolgetcomment
# define C_GDXSYMBOLGETDOMAIN          c_gdxsymbolgetdomain
# define C_GDXSYMBOLINFO               c_gdxsymbolinfo
# define C_GDXSYMBOLINFOX              c_gdxsymbolinfox
# define C_GDXSYMBOLSETDOMAIN          c_gdxsymbolsetdomain
# define C_GDXSYSTEMINFO               c_gdxsysteminfo
# define C_GDXUELMAXLENGTH             c_gdxuelmaxlength
# define C_GDXUELREGISTERDONE          c_gdxuelregisterdone
# define C_GDXUELREGISTERMAP           c_gdxuelregistermap
# define C_GDXUELREGISTERMAPSTART      c_gdxuelregistermapstart
# define C_GDXUELREGISTERRAW           c_gdxuelregisterraw
# define C_GDXUELREGISTERRAWSTART      c_gdxuelregisterrawstart
# define C_GDXUELREGISTERSTR           c_gdxuelregisterstr
# define C_GDXUELREGISTERSTRSTART      c_gdxuelregisterstrstart
# define C_GDXUMFINDUEL                c_gdxumfinduel
# define C_GDXUMUELGET                 c_gdxumuelget
# define C_GDXUMUELINFO                c_gdxumuelinfo
# define C_GDXCURRENTDIM               c_gdxcurrentdim
# define C_GDXCREATE                   c_gdxcreate
# define C_GDXCREATED                  c_gdxcreated
# define C_GDXCREATEL                  c_gdxcreatel
# define C_GDXGETREADY                 c_gdxgetready
# define C_GDXGETREADYD                c_gdxgetreadyd
# define C_GDXGETREADYL                c_gdxgetreadyl
# define C_GDXEXIT                     c_gdxexit
# define C_GDXFREE                     c_gdxfree
# define C_GDXGETAPIERRORCOUNT         c_gdxgetapierrorcount
# define C_GDXGETSCREENINDICATOR       c_gdxgetscreenindicator
# define C_GDXSETSCREENINDICATOR       c_gdxsetscreenindicator
# define C_GDXSETERRORCALLBACK         c_gdxseterrorcallback
#elif defined(APIWRAP_UCASE_DECOR)  /* fortran names: upper case, trailing _ */
# define C_GDXACRONYMCOUNT             C_GDXACRONYMCOUNT_
# define C_GDXACRONYMGETINFO           C_GDXACRONYMGETINFO_
# define C_GDXACRONYMINDEX             C_GDXACRONYMINDEX_
# define C_GDXACRONYMNAME              C_GDXACRONYMNAME_
# define C_GDXACRONYMSETINFO           C_GDXACRONYMSETINFO_
# define C_GDXACRONYMVALUE             C_GDXACRONYMVALUE_
# define C_GDXADDALIAS                 C_GDXADDALIAS_
# define C_GDXADDSETTEXT               C_GDXADDSETTEXT_
# define C_GDXAUTOCONVERT              C_GDXAUTOCONVERT_
# define C_GDXCLOSE                    C_GDXCLOSE_
# define C_GDXDATAERRORCOUNT           C_GDXDATAERRORCOUNT_
# define C_GDXDATAERRORRECORD          C_GDXDATAERRORRECORD_
# define C_GDXDATAREADDONE             C_GDXDATAREADDONE_
# define C_GDXDATAREADFILTEREDSTART    C_GDXDATAREADFILTEREDSTART_
# define C_GDXDATAREADMAP              C_GDXDATAREADMAP_
# define C_GDXDATAREADMAPSTART         C_GDXDATAREADMAPSTART_
# define C_GDXDATAREADRAW              C_GDXDATAREADRAW_
# define C_GDXDATAREADRAWSTART         C_GDXDATAREADRAWSTART_
# define C_GDXDATAREADSLICE            C_GDXDATAREADSLICE_
# define C_GDXDATAREADSLICESTART       C_GDXDATAREADSLICESTART_
# define C_GDXDATAREADSTR              C_GDXDATAREADSTR_
# define C_GDXDATAREADSTRSTART         C_GDXDATAREADSTRSTART_
# define C_GDXDATASLICEUELS            C_GDXDATASLICEUELS_
# define C_GDXDATAWRITEDONE            C_GDXDATAWRITEDONE_
# define C_GDXDATAWRITEMAP             C_GDXDATAWRITEMAP_
# define C_GDXDATAWRITEMAPSTART        C_GDXDATAWRITEMAPSTART_
# define C_GDXDATAWRITERAW             C_GDXDATAWRITERAW_
# define C_GDXDATAWRITERAWSTART        C_GDXDATAWRITERAWSTART_
# define C_GDXDATAWRITESTR             C_GDXDATAWRITESTR_
# define C_GDXDATAWRITESTRSTART        C_GDXDATAWRITESTRSTART_
# define C_GDXGETDLLVERSION            C_GDXGETDLLVERSION_
# define C_GDXERRORCOUNT               C_GDXERRORCOUNT_
# define C_GDXERRORSTR                 C_GDXERRORSTR_
# define C_GDXFILEINFO                 C_GDXFILEINFO_
# define C_GDXFILEVERSION              C_GDXFILEVERSION_
# define C_GDXFILTEREXISTS             C_GDXFILTEREXISTS_
# define C_GDXFILTERREGISTER           C_GDXFILTERREGISTER_
# define C_GDXFILTERREGISTERDONE       C_GDXFILTERREGISTERDONE_
# define C_GDXFILTERREGISTERSTART      C_GDXFILTERREGISTERSTART_
# define C_GDXFINDSYMBOL               C_GDXFINDSYMBOL_
# define C_GDXGETELEMTEXT              C_GDXGETELEMTEXT_
# define C_GDXGETLASTERROR             C_GDXGETLASTERROR_
# define C_GDXGETSPECIALVALUES         C_GDXGETSPECIALVALUES_
# define C_GDXGETUEL                   C_GDXGETUEL_
# define C_GDXMAPVALUE                 C_GDXMAPVALUE_
# define C_GDXOPENREAD                 C_GDXOPENREAD_
# define C_GDXOPENWRITE                C_GDXOPENWRITE_
# define C_GDXOPENWRITEEX              C_GDXOPENWRITEEX_
# define C_GDXRESETSPECIALVALUES       C_GDXRESETSPECIALVALUES_
# define C_GDXSETHASTEXT               C_GDXSETHASTEXT_
# define C_GDXSETREADSPECIALVALUES     C_GDXSETREADSPECIALVALUES_
# define C_GDXSETSPECIALVALUES         C_GDXSETSPECIALVALUES_
# define C_GDXSETTEXTNODENR            C_GDXSETTEXTNODENR_
# define C_GDXSETTRACELEVEL            C_GDXSETTRACELEVEL_
# define C_GDXSYMBINDXMAXLENGTH        C_GDXSYMBINDXMAXLENGTH_
# define C_GDXSYMBMAXLENGTH            C_GDXSYMBMAXLENGTH_
# define C_GDXSYMBOLADDCOMMENT         C_GDXSYMBOLADDCOMMENT_
# define C_GDXSYMBOLGETCOMMENT         C_GDXSYMBOLGETCOMMENT_
# define C_GDXSYMBOLGETDOMAIN          C_GDXSYMBOLGETDOMAIN_
# define C_GDXSYMBOLINFO               C_GDXSYMBOLINFO_
# define C_GDXSYMBOLINFOX              C_GDXSYMBOLINFOX_
# define C_GDXSYMBOLSETDOMAIN          C_GDXSYMBOLSETDOMAIN_
# define C_GDXSYSTEMINFO               C_GDXSYSTEMINFO_
# define C_GDXUELMAXLENGTH             C_GDXUELMAXLENGTH_
# define C_GDXUELREGISTERDONE          C_GDXUELREGISTERDONE_
# define C_GDXUELREGISTERMAP           C_GDXUELREGISTERMAP_
# define C_GDXUELREGISTERMAPSTART      C_GDXUELREGISTERMAPSTART_
# define C_GDXUELREGISTERRAW           C_GDXUELREGISTERRAW_
# define C_GDXUELREGISTERRAWSTART      C_GDXUELREGISTERRAWSTART_
# define C_GDXUELREGISTERSTR           C_GDXUELREGISTERSTR_
# define C_GDXUELREGISTERSTRSTART      C_GDXUELREGISTERSTRSTART_
# define C_GDXUMFINDUEL                C_GDXUMFINDUEL_
# define C_GDXUMUELGET                 C_GDXUMUELGET_
# define C_GDXUMUELINFO                C_GDXUMUELINFO_
# define C_GDXCURRENTDIM               C_GDXCURRENTDIM_
# define C_GDXCREATE                   C_GDXCREATE_
# define C_GDXCREATED                  C_GDXCREATED_
# define C_GDXCREATEL                  C_GDXCREATEL_
# define C_GDXGETREADY                 C_GDXGETREADY_
# define C_GDXGETREADYD                C_GDXGETREADYD_
# define C_GDXGETREADYL                C_GDXGETREADYL_
# define C_GDXEXIT                     C_GDXEXIT_
# define C_GDXFREE                     C_GDXFREE_
# define C_GDXGETAPIERRORCOUNT         C_GDXGETAPIERRORCOUNT_
# define C_GDXGETSCREENINDICATOR       C_GDXGETSCREENINDICATOR_
# define C_GDXSETSCREENINDICATOR       C_GDXSETSCREENINDICATOR_
# define C_GDXSETERRORCALLBACK         C_GDXSETERRORCALLBACK_
#elif defined(APIWRAP_UCASE_NODECOR)/* fortran names: upper case, no _ */
# define C_GDXACRONYMCOUNT             C_GDXACRONYMCOUNT
# define C_GDXACRONYMGETINFO           C_GDXACRONYMGETINFO
# define C_GDXACRONYMINDEX             C_GDXACRONYMINDEX
# define C_GDXACRONYMNAME              C_GDXACRONYMNAME
# define C_GDXACRONYMSETINFO           C_GDXACRONYMSETINFO
# define C_GDXACRONYMVALUE             C_GDXACRONYMVALUE
# define C_GDXADDALIAS                 C_GDXADDALIAS
# define C_GDXADDSETTEXT               C_GDXADDSETTEXT
# define C_GDXAUTOCONVERT              C_GDXAUTOCONVERT
# define C_GDXCLOSE                    C_GDXCLOSE
# define C_GDXDATAERRORCOUNT           C_GDXDATAERRORCOUNT
# define C_GDXDATAERRORRECORD          C_GDXDATAERRORRECORD
# define C_GDXDATAREADDONE             C_GDXDATAREADDONE
# define C_GDXDATAREADFILTEREDSTART    C_GDXDATAREADFILTEREDSTART
# define C_GDXDATAREADMAP              C_GDXDATAREADMAP
# define C_GDXDATAREADMAPSTART         C_GDXDATAREADMAPSTART
# define C_GDXDATAREADRAW              C_GDXDATAREADRAW
# define C_GDXDATAREADRAWSTART         C_GDXDATAREADRAWSTART
# define C_GDXDATAREADSLICE            C_GDXDATAREADSLICE
# define C_GDXDATAREADSLICESTART       C_GDXDATAREADSLICESTART
# define C_GDXDATAREADSTR              C_GDXDATAREADSTR
# define C_GDXDATAREADSTRSTART         C_GDXDATAREADSTRSTART
# define C_GDXDATASLICEUELS            C_GDXDATASLICEUELS
# define C_GDXDATAWRITEDONE            C_GDXDATAWRITEDONE
# define C_GDXDATAWRITEMAP             C_GDXDATAWRITEMAP
# define C_GDXDATAWRITEMAPSTART        C_GDXDATAWRITEMAPSTART
# define C_GDXDATAWRITERAW             C_GDXDATAWRITERAW
# define C_GDXDATAWRITERAWSTART        C_GDXDATAWRITERAWSTART
# define C_GDXDATAWRITESTR             C_GDXDATAWRITESTR
# define C_GDXDATAWRITESTRSTART        C_GDXDATAWRITESTRSTART
# define C_GDXGETDLLVERSION            C_GDXGETDLLVERSION
# define C_GDXERRORCOUNT               C_GDXERRORCOUNT
# define C_GDXERRORSTR                 C_GDXERRORSTR
# define C_GDXFILEINFO                 C_GDXFILEINFO
# define C_GDXFILEVERSION              C_GDXFILEVERSION
# define C_GDXFILTEREXISTS             C_GDXFILTEREXISTS
# define C_GDXFILTERREGISTER           C_GDXFILTERREGISTER
# define C_GDXFILTERREGISTERDONE       C_GDXFILTERREGISTERDONE
# define C_GDXFILTERREGISTERSTART      C_GDXFILTERREGISTERSTART
# define C_GDXFINDSYMBOL               C_GDXFINDSYMBOL
# define C_GDXGETELEMTEXT              C_GDXGETELEMTEXT
# define C_GDXGETLASTERROR             C_GDXGETLASTERROR
# define C_GDXGETSPECIALVALUES         C_GDXGETSPECIALVALUES
# define C_GDXGETUEL                   C_GDXGETUEL
# define C_GDXMAPVALUE                 C_GDXMAPVALUE
# define C_GDXOPENREAD                 C_GDXOPENREAD
# define C_GDXOPENWRITE                C_GDXOPENWRITE
# define C_GDXOPENWRITEEX              C_GDXOPENWRITEEX
# define C_GDXRESETSPECIALVALUES       C_GDXRESETSPECIALVALUES
# define C_GDXSETHASTEXT               C_GDXSETHASTEXT
# define C_GDXSETREADSPECIALVALUES     C_GDXSETREADSPECIALVALUES
# define C_GDXSETSPECIALVALUES         C_GDXSETSPECIALVALUES
# define C_GDXSETTEXTNODENR            C_GDXSETTEXTNODENR
# define C_GDXSETTRACELEVEL            C_GDXSETTRACELEVEL
# define C_GDXSYMBINDXMAXLENGTH        C_GDXSYMBINDXMAXLENGTH
# define C_GDXSYMBMAXLENGTH            C_GDXSYMBMAXLENGTH
# define C_GDXSYMBOLADDCOMMENT         C_GDXSYMBOLADDCOMMENT
# define C_GDXSYMBOLGETCOMMENT         C_GDXSYMBOLGETCOMMENT
# define C_GDXSYMBOLGETDOMAIN          C_GDXSYMBOLGETDOMAIN
# define C_GDXSYMBOLINFO               C_GDXSYMBOLINFO
# define C_GDXSYMBOLINFOX              C_GDXSYMBOLINFOX
# define C_GDXSYMBOLSETDOMAIN          C_GDXSYMBOLSETDOMAIN
# define C_GDXSYSTEMINFO               C_GDXSYSTEMINFO
# define C_GDXUELMAXLENGTH             C_GDXUELMAXLENGTH
# define C_GDXUELREGISTERDONE          C_GDXUELREGISTERDONE
# define C_GDXUELREGISTERMAP           C_GDXUELREGISTERMAP
# define C_GDXUELREGISTERMAPSTART      C_GDXUELREGISTERMAPSTART
# define C_GDXUELREGISTERRAW           C_GDXUELREGISTERRAW
# define C_GDXUELREGISTERRAWSTART      C_GDXUELREGISTERRAWSTART
# define C_GDXUELREGISTERSTR           C_GDXUELREGISTERSTR
# define C_GDXUELREGISTERSTRSTART      C_GDXUELREGISTERSTRSTART
# define C_GDXUMFINDUEL                C_GDXUMFINDUEL
# define C_GDXUMUELGET                 C_GDXUMUELGET
# define C_GDXUMUELINFO                C_GDXUMUELINFO
# define C_GDXCURRENTDIM               C_GDXCURRENTDIM
# define C_GDXCREATE                   C_GDXCREATE
# define C_GDXCREATED                  C_GDXCREATED
# define C_GDXCREATEL                  C_GDXCREATEL
# define C_GDXGETREADY                 C_GDXGETREADY
# define C_GDXGETREADYD                C_GDXGETREADYD
# define C_GDXGETREADYL                C_GDXGETREADYL
# define C_GDXEXIT                     C_GDXEXIT
# define C_GDXFREE                     C_GDXFREE
# define C_GDXGETAPIERRORCOUNT         C_GDXGETAPIERRORCOUNT
# define C_GDXGETSCREENINDICATOR       C_GDXGETSCREENINDICATOR
# define C_GDXSETSCREENINDICATOR       C_GDXSETSCREENINDICATOR
# define C_GDXSETERRORCALLBACK         C_GDXSETERRORCALLBACK
#else
#error "No compile define for fortran naming convention"
No_compile_define_for_fortran_naming_convention;
#endif


/* gdxGetReady: return false on failure, true on success */
static int gdxGetReady (char *msgBuf, int msgBufSize)
{
  if (! isLoaded) {
    isLoaded = ! XLibraryLoad (NULL, msgBuf, msgBufSize);
  }
  return isLoaded;
} /* gdxGetReady */

/* gdxGetReadyD: return false on failure to load library, true on success */
static int gdxGetReadyD (const char *dirName, char *msgBuf, int msgBufLen)
{
  int myrc = 0;

  if (! isLoaded) {
    isLoaded = ! XLibraryLoad (NULL, msgBuf, msgBufLen);
    if (isLoaded) {
      if (NULL != gdxSetLoadPath) {
        gdxSetLoadPath(dirName);
      }
      else {                            /* no setLoadPath call found */
        myrc |= 2;
      }
    }
    else {                              /* library load failed */
      myrc |= 1;
    }
  }
  return (myrc & 1) == 0;
} /* gdxGetReadyD */

/* gdxGetReadyL: return false on failure to load library, true on success */
static int gdxGetReadyL (const char *libName, char *msgBuf, int msgBufLen)
{
  char dirName[1024];
  int myrc = 0;
  char *p = NULL;

  if (! isLoaded) {
    isLoaded = ! XLibraryLoad (libName, msgBuf, msgBufLen);
    if (isLoaded) {
      if (NULL != gdxSetLoadPath) {
        /* get the dirname from libname */
        p = extractFileDir (libName, dirName, sizeof(dirName));
        if (NULL != p) {
          gdxSetLoadPath(dirName);
        }
        else {                          /* could not extract dirName */
          myrc |= 4;
        }
      }
      else {                            /* no setLoadPath call found */
        myrc |= 2;
      }
    }
    else {                              /* library load failed */
      myrc |= 1;
    }
  }
  return (myrc & 1) == 0;
} /* gdxGetReadyL */

/* gdxGetReady: return false on failure, true on success */
gdxBoolean_t GDX_CALLCONV
C_GDXGETREADY (char **msgBuf, int msgBufSiz)
{
  int gdxIsReady;
  gdxIsReady = gdxGetReady (*msgBuf, msgBufSiz);
  blankPad (*msgBuf, strlen(*msgBuf), msgBufSiz);
  return gdxIsReady;
} /* gdxGetReady */

/* gdxGetReadyD: return false on failure to load library, true on success */
gdxBoolean_t GDX_CALLCONV
C_GDXGETREADYD (char **dirName, int dirNameSiz, char **msgBuf, int msgBufSiz)
{
  int gdxIsReady;
  char dirNameC[512];
  convertF2C (*dirName, dirNameC, dirNameSiz, sizeof(dirNameC));
  **msgBuf = '\0';
  gdxIsReady = gdxGetReadyD (dirNameC, *msgBuf, msgBufSiz);
  blankPad (*msgBuf, strlen(*msgBuf), msgBufSiz);
  return gdxIsReady;
} /* gdxGetReadyD */

/* gdxGetReadyL: return false on failure to load library, true on success */
gdxBoolean_t GDX_CALLCONV
C_GDXGETREADYL (char **libName, int libNameSiz, char **msgBuf, int msgBufSiz)
{
  int gdxIsReady;
  char libNameC[512];
  convertF2C (*libName, libNameC, libNameSiz, sizeof(libNameC));
  **msgBuf = '\0';
  gdxIsReady = gdxGetReadyL (libNameC, *msgBuf, msgBufSiz);
  blankPad (*msgBuf, strlen(*msgBuf), msgBufSiz);
  return gdxIsReady;
} /* gdxGetReadyL */

/* gdxCreate: return false on failure, true on success */
gdxBoolean_t GDX_CALLCONV
C_GDXCREATE (u64_t *h, char **msgBuf, int msgBufSiz)
{
  int gdxIsReady;

  gdxIsReady = gdxGetReady (*msgBuf, msgBufSiz);
  blankPad (*msgBuf, strlen(*msgBuf), msgBufSiz);
  if (! gdxIsReady) {
    return 0;
  }
  assert(XCreate);
  XCreate(&(h->p));
  if(0 == h->i)
  { strcpy(*msgBuf,"Error while creating object"); return 0; }
  objectCount++;

  return 1;                     /* return true */
} /* gdxCreate */

/* gdxCreateD: return false on failure to load library, true on success */
gdxBoolean_t GDX_CALLCONV
C_GDXCREATED (u64_t *h, char **dirName, int dirNameSiz, char **msgBuf, int msgBufSiz)
{
  int gdxIsReady;
  char dirNameC[512];

  convertF2C (*dirName, dirNameC, dirNameSiz, sizeof(dirNameC));
  **msgBuf = '\0';
  gdxIsReady = gdxGetReadyD (dirNameC, *msgBuf, msgBufSiz);
  blankPad (*msgBuf, strlen(*msgBuf), msgBufSiz);
  if (! gdxIsReady) {
    return 0;
  }
  assert(XCreate);
  XCreate(&(h->p));
  if(0 == h->i)
  { strcpy(*msgBuf,"Error while creating object"); return 0; }
  objectCount++;

  return 1;                     /* return true */
} /* gdxCreateD */

/* gdxCreateL: return false on failure to load library, true on success */
gdxBoolean_t GDX_CALLCONV
C_GDXCREATEL (u64_t *h, char **libName, int libNameSiz, char **msgBuf, int msgBufSiz)
{
  int gdxIsReady;
  char libNameC[512];

  convertF2C (*libName, libNameC, libNameSiz, sizeof(libNameC));
  **msgBuf = '\0';
  gdxIsReady = gdxGetReadyL (libNameC, *msgBuf, msgBufSiz);
  blankPad (*msgBuf, strlen(*msgBuf), msgBufSiz);
  if (! gdxIsReady) {
    return 0;
  }
  assert(XCreate);
  XCreate(&(h->p));
  if(0 == h->i)
  { strcpy(*msgBuf,"Error while creating object"); return 0; }
  objectCount++;

  return 1;                     /* return true */
} /* gdxCreateL */

void GDX_CALLCONV
C_GDXEXIT (int i)
{
  exit (i);
} /* gdxExit */

gdxBoolean_t GDX_CALLCONV
C_GDXFREE (u64_t *h)
{
  assert(XFree);
  XFree(&(h->p));
  objectCount--;
  if (isLoaded && 0 == objectCount) {
    (void) unLoadLib (hLibGlobal);
    isLoaded = 0;
  }
  return 1;
} /* gdxFree */

int GDX_CALLCONV
C_GDXGETSCREENINDICATOR ()
{
  return screenIndicator;
} /* gdxGetScreenIndicator */

void GDX_CALLCONV
C_GDXSETSCREENINDICATOR (int scrInd)
{
  screenIndicator = scrInd;
  return;
} /* gdxSetScreenIndicator */

void GDX_CALLCONV
C_GDXSETERRORCALLBACK(errorCallbackFort_t func)
{
  errorCallbackFort = func;
} /* gdxSetErrorCallback */

int GDX_CALLCONV
C_GDXGETAPIERRORCOUNT ()
{
  return APIErrorCount;
} /* gdxGetAPIErrorCount */


/* start implementation of glue code for functions */

int GDX_CALLCONV
C_GDXACRONYMCOUNT (INT64 iptr_)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxAcronymCount(h_.p);
  return result;
}

int GDX_CALLCONV
C_GDXACRONYMGETINFO (INT64 iptr_, int N, char **AName, int len_AName, char **Atext, int len_Atext, int *Indx)
{
  u64_t h_;
  int result;
  string255 pas_AName;
  string255 pas_Atext;

  h_.i = iptr_;
  result = gdxAcronymGetInfo(h_.p,N,pas_AName,pas_Atext,Indx);
  convertPAS2F(pas_AName, *AName, len_AName);
  convertPAS2F(pas_Atext, *Atext, len_Atext);
  return result;
}

int GDX_CALLCONV
C_GDXACRONYMINDEX (INT64 iptr_, double V)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxAcronymIndex(h_.p,V);
  return result;
}

int GDX_CALLCONV
C_GDXACRONYMNAME (INT64 iptr_, double V, char **AName, int len_AName)
{
  u64_t h_;
  int result;
  string255 pas_AName;

  h_.i = iptr_;
  result = gdxAcronymName(h_.p,V,pas_AName);
  convertPAS2F(pas_AName, *AName, len_AName);
  return result;
}

int GDX_CALLCONV
C_GDXACRONYMSETINFO (INT64 iptr_, int N, const char **AName, int len_AName, const char **Atext, int len_Atext, int Indx)
{
  u64_t h_;
  int result;
  string255 pas_AName;
  string255 pas_Atext;

  h_.i = iptr_;
  convertF2PAS(*AName, pas_AName, len_AName, 255);
  convertF2PAS(*Atext, pas_Atext, len_Atext, 255);
  result = gdxAcronymSetInfo(h_.p,N,pas_AName,pas_Atext,Indx);
  return result;
}

double GDX_CALLCONV
C_GDXACRONYMVALUE (INT64 iptr_, int Indx)
{
  u64_t h_;
  double result;

  h_.i = iptr_;
  result = gdxAcronymValue(h_.p,Indx);
  return result;
}

int GDX_CALLCONV
C_GDXADDALIAS (INT64 iptr_, const char **AName1, int len_AName1, const char **AName2, int len_AName2)
{
  u64_t h_;
  int result;
  string255 pas_AName1;
  string255 pas_AName2;

  h_.i = iptr_;
  convertF2PAS(*AName1, pas_AName1, len_AName1, 255);
  convertF2PAS(*AName2, pas_AName2, len_AName2, 255);
  result = gdxAddAlias(h_.p,pas_AName1,pas_AName2);
  return result;
}

int GDX_CALLCONV
C_GDXADDSETTEXT (INT64 iptr_, const char **s, int len_s, int *N)
{
  u64_t h_;
  int result;
  string255 pas_s;

  h_.i = iptr_;
  convertF2PAS(*s, pas_s, len_s, 255);
  result = gdxAddSetText(h_.p,pas_s,N);
  return result;
}

int GDX_CALLCONV
C_GDXAUTOCONVERT (INT64 iptr_, int NV)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxAutoConvert(h_.p,NV);
  return result;
}

int GDX_CALLCONV
C_GDXCLOSE (INT64 iptr_)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxClose(h_.p);
  return result;
}

int GDX_CALLCONV
C_GDXDATAERRORCOUNT (INT64 iptr_)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxDataErrorCount(h_.p);
  return result;
}

int GDX_CALLCONV
C_GDXDATAERRORRECORD (INT64 iptr_, int Rn, int *AElements, double *AVals)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxDataErrorRecord(h_.p,Rn,AElements,AVals);
  return result;
}

int GDX_CALLCONV
C_GDXDATAREADDONE (INT64 iptr_)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxDataReadDone(h_.p);
  return result;
}

int GDX_CALLCONV
C_GDXDATAREADFILTEREDSTART (INT64 iptr_, int SyNr, const int *ADomainNrs, int *NrRecs)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxDataReadFilteredStart(h_.p,SyNr,ADomainNrs,NrRecs);
  return result;
}

int GDX_CALLCONV
C_GDXDATAREADMAP (INT64 iptr_, int Rn, int *AElements, double *AVals, int *AFDim)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxDataReadMap(h_.p,Rn,AElements,AVals,AFDim);
  return result;
}

int GDX_CALLCONV
C_GDXDATAREADMAPSTART (INT64 iptr_, int SyNr, int *NrRecs)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxDataReadMapStart(h_.p,SyNr,NrRecs);
  return result;
}

int GDX_CALLCONV
C_GDXDATAREADRAW (INT64 iptr_, int *AElements, double *AVals, int *AFDim)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxDataReadRaw(h_.p,AElements,AVals,AFDim);
  return result;
}

int GDX_CALLCONV
C_GDXDATAREADRAWSTART (INT64 iptr_, int SyNr, int *NrRecs)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxDataReadRawStart(h_.p,SyNr,NrRecs);
  return result;
}

int GDX_CALLCONV
C_GDXDATAREADSLICESTART (INT64 iptr_, int ASyNr, int *ANrElems)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxDataReadSliceStart(h_.p,ASyNr,ANrElems);
  return result;
}

int GDX_CALLCONV
C_GDXDATAREADSTR (INT64 iptr_, char **AStrElements, int len_AStrElements, double *AVals, int *AFDim)
{
  u64_t h_;
  int result;
  string255 pas_AStrElements[GLOBAL_MAX_INDEX_DIM];
  int i_,sidim_;

  h_.i = iptr_;
  result = gdxDataReadStr(h_.p,(char **) pas_AStrElements,AVals,AFDim);
  sidim_ = gdxCurrentDim(h_.p);
  for (i_ = 0;  i_ < sidim_;  i_++)
    convertPAS2F(pas_AStrElements[i_], *AStrElements + i_*len_AStrElements, len_AStrElements);
  return result;
}

int GDX_CALLCONV
C_GDXDATAREADSTRSTART (INT64 iptr_, int SyNr, int *NrRecs)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxDataReadStrStart(h_.p,SyNr,NrRecs);
  return result;
}

int GDX_CALLCONV
C_GDXDATASLICEUELS (INT64 iptr_, const int *AIndx, char **AUELs, int len_AUELs)
{
  u64_t h_;
  int result;
  string255 pas_AUELs[GLOBAL_MAX_INDEX_DIM];
  int i_,sidim_;

  h_.i = iptr_;
  result = gdxDataSliceUELS(h_.p,AIndx,(char **) pas_AUELs);
  sidim_ = gdxCurrentDim(h_.p);
  for (i_ = 0;  i_ < sidim_;  i_++)
    convertPAS2F(pas_AUELs[i_], *AUELs + i_*len_AUELs, len_AUELs);
  return result;
}

int GDX_CALLCONV
C_GDXDATAWRITEDONE (INT64 iptr_)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxDataWriteDone(h_.p);
  return result;
}

int GDX_CALLCONV
C_GDXDATAWRITEMAP (INT64 iptr_, const int *AElements, const double *AVals)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxDataWriteMap(h_.p,AElements,AVals);
  return result;
}

int GDX_CALLCONV
C_GDXDATAWRITEMAPSTART (INT64 iptr_, const char **AName, int len_AName, const char **Atext, int len_Atext, int ADim, int AType, int AUserInfo)
{
  u64_t h_;
  int result;
  string255 pas_AName;
  string255 pas_Atext;

  h_.i = iptr_;
  convertF2PAS(*AName, pas_AName, len_AName, 255);
  convertF2PAS(*Atext, pas_Atext, len_Atext, 255);
  result = gdxDataWriteMapStart(h_.p,pas_AName,pas_Atext,ADim,AType,AUserInfo);
  return result;
}

int GDX_CALLCONV
C_GDXDATAWRITERAW (INT64 iptr_, const int *AElements, const double *AVals)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxDataWriteRaw(h_.p,AElements,AVals);
  return result;
}

int GDX_CALLCONV
C_GDXDATAWRITERAWSTART (INT64 iptr_, const char **AName, int len_AName, const char **Atext, int len_Atext, int ADim, int AType, int AUserInfo)
{
  u64_t h_;
  int result;
  string255 pas_AName;
  string255 pas_Atext;

  h_.i = iptr_;
  convertF2PAS(*AName, pas_AName, len_AName, 255);
  convertF2PAS(*Atext, pas_Atext, len_Atext, 255);
  result = gdxDataWriteRawStart(h_.p,pas_AName,pas_Atext,ADim,AType,AUserInfo);
  return result;
}

int GDX_CALLCONV
C_GDXDATAWRITESTR (INT64 iptr_, const char **AStrElements, int len_AStrElements, const double *AVals)
{
  u64_t h_;
  int result;
  string255 pas_AStrElements[GLOBAL_MAX_INDEX_DIM];
  int i_,sidim_;

  h_.i = iptr_;
  sidim_ = gdxCurrentDim(h_.p);
  for (i_ = 0;  i_ < sidim_;  i_++)
    convertF2PAS(*AStrElements + i_*len_AStrElements, pas_AStrElements[i_], len_AStrElements, 255);
  result = gdxDataWriteStr(h_.p,(const char **) pas_AStrElements,AVals);
  return result;
}

int GDX_CALLCONV
C_GDXDATAWRITESTRSTART (INT64 iptr_, const char **AName, int len_AName, const char **Atext, int len_Atext, int ADim, int AType, int AUserInfo)
{
  u64_t h_;
  int result;
  string255 pas_AName;
  string255 pas_Atext;

  h_.i = iptr_;
  convertF2PAS(*AName, pas_AName, len_AName, 255);
  convertF2PAS(*Atext, pas_Atext, len_Atext, 255);
  result = gdxDataWriteStrStart(h_.p,pas_AName,pas_Atext,ADim,AType,AUserInfo);
  return result;
}

int GDX_CALLCONV
C_GDXGETDLLVERSION (INT64 iptr_, char **V, int len_V)
{
  u64_t h_;
  int result;
  string255 pas_V;

  h_.i = iptr_;
  result = gdxGetDLLVersion(h_.p,pas_V);
  convertPAS2F(pas_V, *V, len_V);
  return result;
}

int GDX_CALLCONV
C_GDXERRORCOUNT (INT64 iptr_)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxErrorCount(h_.p);
  return result;
}

int GDX_CALLCONV
C_GDXERRORSTR (INT64 iptr_, int N, char **s, int len_s)
{
  u64_t h_;
  int result;
  string255 pas_s;

  h_.i = iptr_;
  result = gdxErrorStr(h_.p,N,pas_s);
  convertPAS2F(pas_s, *s, len_s);
  return result;
}

int GDX_CALLCONV
C_GDXFILEINFO (INT64 iptr_, int *FileVer, int *ComprLev)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxFileInfo(h_.p,FileVer,ComprLev);
  return result;
}

int GDX_CALLCONV
C_GDXFILEVERSION (INT64 iptr_, char **FileStr, int len_FileStr, char **ProduceStr, int len_ProduceStr)
{
  u64_t h_;
  int result;
  string255 pas_FileStr;
  string255 pas_ProduceStr;

  h_.i = iptr_;
  result = gdxFileVersion(h_.p,pas_FileStr,pas_ProduceStr);
  convertPAS2F(pas_FileStr, *FileStr, len_FileStr);
  convertPAS2F(pas_ProduceStr, *ProduceStr, len_ProduceStr);
  return result;
}

int GDX_CALLCONV
C_GDXFILTEREXISTS (INT64 iptr_, int N)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxFilterExists(h_.p,N);
  return result;
}

int GDX_CALLCONV
C_GDXFILTERREGISTER (INT64 iptr_, int V)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxFilterRegister(h_.p,V);
  return result;
}

int GDX_CALLCONV
C_GDXFILTERREGISTERDONE (INT64 iptr_)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxFilterRegisterDone(h_.p);
  return result;
}

int GDX_CALLCONV
C_GDXFILTERREGISTERSTART (INT64 iptr_, int Nr)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxFilterRegisterStart(h_.p,Nr);
  return result;
}

int GDX_CALLCONV
C_GDXFINDSYMBOL (INT64 iptr_, const char **AName, int len_AName, int *AIx)
{
  u64_t h_;
  int result;
  string255 pas_AName;

  h_.i = iptr_;
  convertF2PAS(*AName, pas_AName, len_AName, 255);
  result = gdxFindSymbol(h_.p,pas_AName,AIx);
  return result;
}

int GDX_CALLCONV
C_GDXGETELEMTEXT (INT64 iptr_, int N, char **s, int len_s, int *Node)
{
  u64_t h_;
  int result;
  string255 pas_s;

  h_.i = iptr_;
  result = gdxGetElemText(h_.p,N,pas_s,Node);
  convertPAS2F(pas_s, *s, len_s);
  return result;
}

int GDX_CALLCONV
C_GDXGETLASTERROR (INT64 iptr_)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxGetLastError(h_.p);
  return result;
}

int GDX_CALLCONV
C_GDXGETSPECIALVALUES (INT64 iptr_, double *AVals)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxGetSpecialValues(h_.p,AVals);
  return result;
}

int GDX_CALLCONV
C_GDXGETUEL (INT64 iptr_, int UelNr, char **s, int len_s)
{
  u64_t h_;
  int result;
  string255 pas_s;

  h_.i = iptr_;
  result = gdxGetUEL(h_.p,UelNr,pas_s);
  convertPAS2F(pas_s, *s, len_s);
  return result;
}

int GDX_CALLCONV
C_GDXMAPVALUE (INT64 iptr_, double D, int *sv)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxMapValue(h_.p,D,sv);
  return result;
}

int GDX_CALLCONV
C_GDXOPENREAD (INT64 iptr_, const char **Afn, int len_Afn, int *ErrNr)
{
  u64_t h_;
  int result;
  string255 pas_Afn;

  h_.i = iptr_;
  convertF2PAS(*Afn, pas_Afn, len_Afn, 255);
  result = gdxOpenRead(h_.p,pas_Afn,ErrNr);
  return result;
}

int GDX_CALLCONV
C_GDXOPENWRITE (INT64 iptr_, const char **Afn, int len_Afn, const char **AProducer, int len_AProducer, int *ErrNr)
{
  u64_t h_;
  int result;
  string255 pas_Afn;
  string255 pas_AProducer;

  h_.i = iptr_;
  convertF2PAS(*Afn, pas_Afn, len_Afn, 255);
  convertF2PAS(*AProducer, pas_AProducer, len_AProducer, 255);
  result = gdxOpenWrite(h_.p,pas_Afn,pas_AProducer,ErrNr);
  return result;
}

int GDX_CALLCONV
C_GDXOPENWRITEEX (INT64 iptr_, const char **Afn, int len_Afn, const char **AProducer, int len_AProducer, int Compr, int *ErrNr)
{
  u64_t h_;
  int result;
  string255 pas_Afn;
  string255 pas_AProducer;

  h_.i = iptr_;
  convertF2PAS(*Afn, pas_Afn, len_Afn, 255);
  convertF2PAS(*AProducer, pas_AProducer, len_AProducer, 255);
  result = gdxOpenWriteEx(h_.p,pas_Afn,pas_AProducer,Compr,ErrNr);
  return result;
}

int GDX_CALLCONV
C_GDXRESETSPECIALVALUES (INT64 iptr_)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxResetSpecialValues(h_.p);
  return result;
}

int GDX_CALLCONV
C_GDXSETHASTEXT (INT64 iptr_, int N)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxSetHasText(h_.p,N);
  return result;
}

int GDX_CALLCONV
C_GDXSETREADSPECIALVALUES (INT64 iptr_, const double *AVals)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxSetReadSpecialValues(h_.p,AVals);
  return result;
}

int GDX_CALLCONV
C_GDXSETSPECIALVALUES (INT64 iptr_, const double *AVals)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxSetSpecialValues(h_.p,AVals);
  return result;
}

int GDX_CALLCONV
C_GDXSETTEXTNODENR (INT64 iptr_, int N, int Node)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxSetTextNodeNr(h_.p,N,Node);
  return result;
}

int GDX_CALLCONV
C_GDXSETTRACELEVEL (INT64 iptr_, int N, const char **s, int len_s)
{
  u64_t h_;
  int result;
  string255 pas_s;

  h_.i = iptr_;
  convertF2PAS(*s, pas_s, len_s, 255);
  result = gdxSetTraceLevel(h_.p,N,pas_s);
  return result;
}

int GDX_CALLCONV
C_GDXSYMBINDXMAXLENGTH (INT64 iptr_, int SyNr, int *DimInfo)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxSymbIndxMaxLength(h_.p,SyNr,DimInfo);
  return result;
}

int GDX_CALLCONV
C_GDXSYMBMAXLENGTH (INT64 iptr_)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxSymbMaxLength(h_.p);
  return result;
}

int GDX_CALLCONV
C_GDXSYMBOLADDCOMMENT (INT64 iptr_, int SyNr, const char **s, int len_s)
{
  u64_t h_;
  int result;
  string255 pas_s;

  h_.i = iptr_;
  convertF2PAS(*s, pas_s, len_s, 255);
  result = gdxSymbolAddComment(h_.p,SyNr,pas_s);
  return result;
}

int GDX_CALLCONV
C_GDXSYMBOLGETCOMMENT (INT64 iptr_, int SyNr, int N, char **s, int len_s)
{
  u64_t h_;
  int result;
  string255 pas_s;

  h_.i = iptr_;
  result = gdxSymbolGetComment(h_.p,SyNr,N,pas_s);
  convertPAS2F(pas_s, *s, len_s);
  return result;
}

int GDX_CALLCONV
C_GDXSYMBOLGETDOMAIN (INT64 iptr_, int SyNr, int *DomainIDs)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxSymbolGetDomain(h_.p,SyNr,DomainIDs);
  return result;
}

int GDX_CALLCONV
C_GDXSYMBOLINFO (INT64 iptr_, int SyNr, char **AName, int len_AName, int *ADim, int *ATyp)
{
  u64_t h_;
  int result;
  string255 pas_AName;

  h_.i = iptr_;
  result = gdxSymbolInfo(h_.p,SyNr,pas_AName,ADim,ATyp);
  convertPAS2F(pas_AName, *AName, len_AName);
  return result;
}

int GDX_CALLCONV
C_GDXSYMBOLINFOX (INT64 iptr_, int SyNr, int *ACount, int *AUserInfo, char **AExplTxt, int len_AExplTxt)
{
  u64_t h_;
  int result;
  string255 pas_AExplTxt;

  h_.i = iptr_;
  result = gdxSymbolInfoX(h_.p,SyNr,ACount,AUserInfo,pas_AExplTxt);
  convertPAS2F(pas_AExplTxt, *AExplTxt, len_AExplTxt);
  return result;
}

int GDX_CALLCONV
C_GDXSYMBOLSETDOMAIN (INT64 iptr_, const char **DomainIDs, int len_DomainIDs)
{
  u64_t h_;
  int result;
  string255 pas_DomainIDs[GLOBAL_MAX_INDEX_DIM];
  int i_,sidim_;

  h_.i = iptr_;
  sidim_ = gdxCurrentDim(h_.p);
  for (i_ = 0;  i_ < sidim_;  i_++)
    convertF2PAS(*DomainIDs + i_*len_DomainIDs, pas_DomainIDs[i_], len_DomainIDs, 255);
  result = gdxSymbolSetDomain(h_.p,(const char **) pas_DomainIDs);
  return result;
}

int GDX_CALLCONV
C_GDXSYSTEMINFO (INT64 iptr_, int *NrSy, int *NrUel)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxSystemInfo(h_.p,NrSy,NrUel);
  return result;
}

int GDX_CALLCONV
C_GDXUELMAXLENGTH (INT64 iptr_)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxUELMaxLength(h_.p);
  return result;
}

int GDX_CALLCONV
C_GDXUELREGISTERDONE (INT64 iptr_)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxUELRegisterDone(h_.p);
  return result;
}

int GDX_CALLCONV
C_GDXUELREGISTERMAP (INT64 iptr_, int UelNr, const char **Elem, int len_Elem)
{
  u64_t h_;
  int result;
  string255 pas_Elem;

  h_.i = iptr_;
  convertF2PAS(*Elem, pas_Elem, len_Elem, 255);
  result = gdxUELRegisterMap(h_.p,UelNr,pas_Elem);
  return result;
}

int GDX_CALLCONV
C_GDXUELREGISTERMAPSTART (INT64 iptr_)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxUELRegisterMapStart(h_.p);
  return result;
}

int GDX_CALLCONV
C_GDXUELREGISTERRAW (INT64 iptr_, const char **Elem, int len_Elem)
{
  u64_t h_;
  int result;
  string255 pas_Elem;

  h_.i = iptr_;
  convertF2PAS(*Elem, pas_Elem, len_Elem, 255);
  result = gdxUELRegisterRaw(h_.p,pas_Elem);
  return result;
}

int GDX_CALLCONV
C_GDXUELREGISTERRAWSTART (INT64 iptr_)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxUELRegisterRawStart(h_.p);
  return result;
}

int GDX_CALLCONV
C_GDXUELREGISTERSTR (INT64 iptr_, const char **Elem, int len_Elem, int *UelNr)
{
  u64_t h_;
  int result;
  string255 pas_Elem;

  h_.i = iptr_;
  convertF2PAS(*Elem, pas_Elem, len_Elem, 255);
  result = gdxUELRegisterStr(h_.p,pas_Elem,UelNr);
  return result;
}

int GDX_CALLCONV
C_GDXUELREGISTERSTRSTART (INT64 iptr_)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxUELRegisterStrStart(h_.p);
  return result;
}

int GDX_CALLCONV
C_GDXUMFINDUEL (INT64 iptr_, const char **s, int len_s, int *EN, int *UMap)
{
  u64_t h_;
  int result;
  string255 pas_s;

  h_.i = iptr_;
  convertF2PAS(*s, pas_s, len_s, 255);
  result = gdxUMFindUEL(h_.p,pas_s,EN,UMap);
  return result;
}

int GDX_CALLCONV
C_GDXUMUELGET (INT64 iptr_, int N, char **s, int len_s, int *UMap)
{
  u64_t h_;
  int result;
  string255 pas_s;

  h_.i = iptr_;
  result = gdxUMUelGet(h_.p,N,pas_s,UMap);
  convertPAS2F(pas_s, *s, len_s);
  return result;
}

int GDX_CALLCONV
C_GDXUMUELINFO (INT64 iptr_, int *NrElem, int *HighMap)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxUMUelInfo(h_.p,NrElem,HighMap);
  return result;
}

int GDX_CALLCONV
C_GDXCURRENTDIM (INT64 iptr_)
{
  u64_t h_;
  int result;

  h_.i = iptr_;
  result = gdxCurrentDim(h_.p);
  return result;
}

