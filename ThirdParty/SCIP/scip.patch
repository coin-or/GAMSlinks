diff -Naur scip.orig/lpi_clp.cpp scip.0326/lpi_clp.cpp
--- scip.orig/lpi_clp.cpp	2008-03-26 20:44:33.000000000 +0100
+++ scip/lpi_clp.cpp		2008-03-26 20:43:15.000000000 +0100
@@ -275,6 +275,13 @@
    return clpname;
 }
 
+/** gets pointer for LP solver - use only with great care */
+void* SCIPlpiGetSolverPointer(
+   SCIP_LPI*             lpi                 /**< pointer to an LP interface structure */
+   )
+{
+   return (void*) lpi->clp;
+}
 /**@} */
 
 
@@ -469,15 +476,23 @@
    assert(nnonz == 0 || beg != 0);
    assert(nnonz == 0 || ind != 0);
    assert(nnonz == 0 || val != 0);
+   assert(nnonz >= 0);
+   assert(ncols >= 0);
 
    invalidateSolution(lpi);
 
    // store number of columns for later
    int numCols = lpi->clp->getNumCols(); 
 
-   // copy beg-array
+   // copy beg-array (if not 0)
    int* mybeg = new int [ncols+1];
-   memcpy((void *) mybeg, beg, ncols * sizeof(int));
+   if ( nnonz == 0 )
+   {
+      for (int j = 0; j < ncols; ++j)
+	 mybeg[j] = 0;
+   }
+   else
+      memcpy((void *) mybeg, beg, ncols * sizeof(int));
    mybeg[ncols] = nnonz;   // add additional entry at end
 
    // add columns
@@ -639,7 +654,7 @@
    int                   lastrow             /**< last row to be deleted */
    )
 {
-   SCIPdebugMessage("calling SCIPlpiDelRows()\n");
+   SCIPdebugMessage("calling SCIPlpiDelRows() (number: %d)\n", lastrow-firstrow+1);
 
    assert(lpi != 0);
    assert(lpi->clp != 0);
@@ -1722,7 +1737,7 @@
    assert(lpi != 0);
    assert(lpi->clp != 0);
 
-   return (! lpi->clp->primalFeasible() );
+   return ( lpi->clp->primalFeasible() );
 }
 
 
@@ -1841,9 +1856,11 @@
        2 - scaled problem optimal - unscaled problem has primal infeasibilities
        3 - scaled problem optimal - unscaled problem has dual infeasibilities
        4 - scaled problem optimal - unscaled problem has primal and dual infeasibilities
+       6 - failed due to empty problem check 
        100 up - translation of enum from ClpEventHandler
    */
-   return( (lpi->clp->status() <= 2) && (! lpi->clp->isAbandoned()) && (lpi->clp->secondaryStatus() <= 1) );
+   SCIPdebugMessage("status: %d   secondary: %d\n", lpi->clp->status(), lpi->clp->secondaryStatus());
+   return( (lpi->clp->status() <= 2) && (! lpi->clp->isAbandoned()) && (lpi->clp->secondaryStatus() <= 1 || lpi->clp->secondaryStatus() == 6) );
 }
 
 
@@ -1978,6 +1995,8 @@
    assert(ray != 0);
 
    const double* clpray = lpi->clp->unboundedRay();
+   if ( clpray == 0 )
+      return SCIP_LPERROR;
    memcpy((void *) ray, clpray, lpi->clp->numberColumns() * sizeof(double));
    delete [] clpray;
    
@@ -1997,6 +2016,8 @@
    assert(dualfarkas != 0);
 
    const double* dualray = lpi->clp->infeasibilityRay();
+   if ( dualray == 0 )
+      return SCIP_LPERROR;
    memcpy((void *) dualfarkas, dualray, lpi->clp->numberRows() * sizeof(double));
    delete [] dualray;
    
diff -Naur scip.orig/lpi.h scip.0326/lpi.h
--- scip.orig/lpi.h	2008-03-26 20:44:33.000000000 +0100
+++ scip.0326/lpi.h	2008-03-26 20:43:15.000000000 +0100
@@ -47,6 +47,17 @@
    void
    );
 
+/** gets pointer for LP solver - use only with great care 
+ *
+ *  The behavior of this function depends on the solver and its use is
+ *  therefore only recommended if you really know what you are
+ *  doing. In general, it returns a pointer to the LP solver object.
+ */
+extern
+void* SCIPlpiGetSolverPointer(
+   SCIP_LPI*             lpi                 /**< pointer to an LP interface structure */
+   );
+
 /**@} */
 
 
