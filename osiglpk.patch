Index: Osi/src/OsiGlpk/OsiGlpkSolverInterface.cpp
===================================================================
--- Osi/src/OsiGlpk/OsiGlpkSolverInterface.cpp	(Revision 971)
+++ Osi/src/OsiGlpk/OsiGlpkSolverInterface.cpp	(Arbeitskopie)
@@ -174,6 +174,7 @@
   If we ever reach the default case, we're deeply confused.
 */
   isIterationLimitReached_ = false ;
+  isTimeLimitReached_ = false ;
   isAbandoned_ = false ;
   isPrimInfeasible_ = false ;
   isDualInfeasible_ = false ;
@@ -193,6 +194,8 @@
     { isObjUpperLimitReached_ = true ;
       break ; }
     case LPX_E_TMLIM:
+    { isTimeLimitReached_ = true ;
+    } // no break here
     case LPX_E_FAULT:
     case LPX_E_SING:
     { isAbandoned_ = true ;
@@ -229,6 +232,7 @@
   iter_used_ = lpx_get_int_parm(model,LPX_K_ITCNT) ;
 
   isIterationLimitReached_ = false ;
+  isTimeLimitReached_ = false;
   isAbandoned_ = false ;
   isObjLowerLimitReached_ = false ;
   isObjUpperLimitReached_ = false ;
@@ -248,6 +252,8 @@
     { isObjUpperLimitReached_ = true ;
       break ; }
     case LPX_E_TMLIM:
+    { isTimeLimitReached_ = true ;
+    } // no break here
     case LPX_E_FAULT:
     case LPX_E_SING:
     { isAbandoned_ = true ;
@@ -274,16 +280,32 @@
 	freeCachedData( OGSI::FREECACHED_RESULTS );
 	if( lpx_get_num_int( model ) ) {
 
-	        // Must have an LP solution before running lpx_integer
- 	        if (lpx_get_status(model) != LPX_OPT)
-	          initialSolve();
-		// What if there's an error there?
-		int err = lpx_integer( model );
+		int err;
+#if (GLP_MAJOR_VERSION > 4) || ((GLP_MAJOR_VERSION == 4) && (GLP_MINOR_VERSION >= 9))
+		// cuts are only used, if lpx_intopt is used
+		// so if someone set the cutoption, we should use lpx_intopt  
+		if (lpx_get_int_parm(model, LPX_K_USECUTS)) 
+			err = lpx_intopt(model);
+		else {
+			// Must have an LP solution before running lpx_integer
+			if (lpx_get_status(model) != LPX_OPT)
+				initialSolve();
+			err = lpx_integer(model);
+		}
+#else
+		// Must have an LP solution before running lpx_integer
+		if (lpx_get_status(model) != LPX_OPT)
+			initialSolve();
+		err = lpx_integer(model);
+#endif
+
 		iter_used_ = lpx_get_int_parm(model, LPX_K_ITCNT);
+		
 		// Uncertain whether GLPK 4.7 keeps iteration count correctly
 		// for MIPs ???
 
 		isIterationLimitReached_ = false;
+		isTimeLimitReached_ = false;
 		isAbandoned_ = false;
 		isPrimInfeasible_ = false;
 		isDualInfeasible_ = false;
@@ -293,6 +315,8 @@
 			isIterationLimitReached_ = true;
 			break;
 
+		case LPX_E_TMLIM:
+			isTimeLimitReached_ = true;
 		case LPX_E_FAULT:
 		case LPX_E_SING:
 			isAbandoned_ = true;
@@ -727,6 +751,11 @@
 	return isIterationLimitReached_;
 }
 
+bool OGSI::isTimeLimitReached() const
+{
+	return isTimeLimitReached_;
+}
+
 //#############################################################################
 // WarmStart related methods
 //#############################################################################
@@ -3010,7 +3039,7 @@
   nameDisc_ = 0;
 
   dualObjectiveLimit_ = DBL_MAX;
-  primalObjectiveLimit_ = DBL_MAX;
+  primalObjectiveLimit_ = -DBL_MAX;
   dualTolerance_ = 1.0e-6;
   primalTolerance_ = 1.0e-6;
   objOffset_ = 0.0 ;
@@ -3023,6 +3052,7 @@
   hotStartRStatSize_ = 0;
 
   isIterationLimitReached_ = false;
+  isTimeLimitReached_ = false;
   isAbandoned_ = false;
   isPrimInfeasible_ = false;
   isDualInfeasible_ = false;
@@ -3136,6 +3166,7 @@
         iter_used_ = 0;
 	isAbandoned_ = false;
 	isIterationLimitReached_ = false;
+	isTimeLimitReached_ = false;
 	isPrimInfeasible_ = false;
 	isDualInfeasible_ = false;
 	delete [] colsol_;
Index: Osi/src/OsiGlpk/OsiGlpkSolverInterface.hpp
===================================================================
--- Osi/src/OsiGlpk/OsiGlpkSolverInterface.hpp	(Revision 971)
+++ Osi/src/OsiGlpk/OsiGlpkSolverInterface.hpp	(Arbeitskopie)
@@ -90,6 +90,11 @@
     virtual bool isDualObjectiveLimitReached() const;
     /// Iteration limit reached?
     virtual bool isIterationLimitReached() const;
+    /** Time limit reached?
+     * To be compatible with OsiSolverInterface,
+     * OsiGlpkSolverInterface also reports that the solution has been abondoned in case that the time limit is reached. 
+     */
+    virtual bool isTimeLimitReached() const;
   //@}
 
   //---------------------------------------------------------------------------
@@ -770,6 +775,8 @@
   // Status information
   /// glpk stopped on iteration limit
   bool isIterationLimitReached_;
+  /// glpk stopped on time limit
+  bool isTimeLimitReached_;
   /// glpk abandoned the problem 
   bool isAbandoned_;
   /*! \brief  glpk stopped on lower objective limit
