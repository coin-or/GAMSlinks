--- Osi/src/OsiGlpk/OsiGlpkSolverInterface.cpp	(Revision 1081)
+++ Osi/src/OsiGlpk/OsiGlpkSolverInterface.cpp	(Arbeitskopie)
@@ -176,9 +176,11 @@
   If we ever reach the default case, we're deeply confused.
 */
   isIterationLimitReached_ = false ;
+  isTimeLimitReached_ = false;
   isAbandoned_ = false ;
   isPrimInfeasible_ = false ;
   isDualInfeasible_ = false ;
+  isFeasible_ = false ;
   isObjLowerLimitReached_ = false ;
   isObjUpperLimitReached_ = false ;
 
@@ -195,6 +197,8 @@
     { isObjUpperLimitReached_ = true ;
       break ; }
     case LPX_E_TMLIM:
+    { isTimeLimitReached_ = true ;
+    } // no break here, so we still report abandoned
     case LPX_E_FAULT:
     case LPX_E_SING:
     { isAbandoned_ = true ;
@@ -207,6 +211,15 @@
       break ; }
     default:
     { assert(false) ; } }
+    
+  switch (lpx_get_status(model))
+  { case LPX_OPT:
+  	case LPX_FEAS:
+  	{ isFeasible_ = true ;
+  		break ; }
+  	default:
+  	{ }
+  }
 	  
   // Record that simplex was most recent
   bbWasLast_ = 0 ;
@@ -231,11 +244,13 @@
   iter_used_ = lpx_get_int_parm(model,LPX_K_ITCNT) ;
 
   isIterationLimitReached_ = false ;
+  isTimeLimitReached_ = false ;
   isAbandoned_ = false ;
   isObjLowerLimitReached_ = false ;
   isObjUpperLimitReached_ = false ;
   isPrimInfeasible_ = false ;
   isDualInfeasible_ = false ;
+  isFeasible_ = false ;
 
   switch (err)
   { case LPX_E_OK:
@@ -250,6 +265,8 @@
     { isObjUpperLimitReached_ = true ;
       break ; }
     case LPX_E_TMLIM:
+    { isTimeLimitReached_ = true ;
+    } // no break here, so we still report abandoned
     case LPX_E_FAULT:
     case LPX_E_SING:
     { isAbandoned_ = true ;
@@ -263,6 +280,15 @@
     default:
     { assert(false) ; } }
 
+  switch (lpx_get_status(model))
+  { case LPX_OPT:
+  	case LPX_FEAS:
+  	{ isFeasible_ = true ;
+  		break ; }
+  	default:
+  	{ }
+  }
+
   // Record that simplex was most recent
   bbWasLast_ = 0 ;
 
@@ -304,7 +330,20 @@
     lpx_set_int_parm(model,LPX_K_USECUTS,0) ;
 #   endif
 #   endif
+#		ifdef OGSI_HAVE_CALLBACK
+		// parameters for glp_intopt call
+		glp_iocp param;
+		glp_init_iocp(&param);
+		if (callback_routine) {
+			param.cb_func=callback_routine;
+			param.cb_info=callback_info;
+		}
+    if (lpx_get_status(model) != LPX_OPT)
+    { initialSolve() ; }
+		err = glp_intopt(model, &param);
+#		else
     err = lpx_intopt(model) ;
+#		endif
 #   else
     if (lpx_get_status(model) != LPX_OPT)
     { initialSolve() ; }
@@ -340,25 +379,17 @@
 */
     iter_used_ = lpx_get_int_parm(model,LPX_K_ITCNT) ;
     isIterationLimitReached_ = false ;
+		isTimeLimitReached_ = false ;
     isAbandoned_ = false ;
     isPrimInfeasible_ = false ;
     isDualInfeasible_ = false ;
+    isFeasible_ = false ;
+    isObjLowerLimitReached_ = false ;
+    isObjUpperLimitReached_ = false ;
 
     switch (err)
     { case LPX_E_OK:
-      { int mip_status = lpx_mip_status(model) ;
-	switch (mip_status)
-	{ case LPX_I_OPT:
-	  { break ; }
-	  case LPX_I_NOFEAS:
-	  { isPrimInfeasible_ = false ;
-	    break ; }
-	  case LPX_I_UNDEF:
-	  case LPX_I_FEAS:
-	  { break ; }
-	  default:
-	  { assert(false) ;
-	    break ; } }
+      { 
 	break ; }
       case LPX_E_NOPFS:
       { isPrimInfeasible_ = true ;
@@ -366,8 +397,9 @@
       case LPX_E_NODFS:
       { isDualInfeasible_ = true ;
 	break ; }
+      case LPX_E_TMLIM:
+      { isTimeLimitReached_ = true ; } // no break
       case LPX_E_ITLIM:
-      case LPX_E_TMLIM:
       { isIterationLimitReached_ = true ;
 	break ; }
       case LPX_E_SING:
@@ -379,6 +411,24 @@
       default:
       { assert(false) ;
 	break ; } }
+	
+	//check this also if err!=LPX_E_OPT, so we know about feasibility in case time/resource limit is reached  
+	int mip_status = lpx_mip_status(model) ;
+	switch (mip_status)
+	{ case LPX_I_OPT:
+	  { isFeasible_ = true ;
+	  	break ; }
+	  case LPX_I_NOFEAS:
+	  { isPrimInfeasible_ = true ;
+	    break ; }
+	  case LPX_I_UNDEF:
+	  { break ; }
+	  case LPX_I_FEAS:
+	  { isFeasible_ = true ;
+	  	break ; }
+	  default:
+	  { assert(false) ;
+	    break ; } }
 /*
   The final action is to note that our last call to glpk was the MIP solver.
 */
@@ -741,6 +791,14 @@
   }
   return true;
 }
+
+#ifdef OGSI_HAVE_CALLBACK
+void OGSI::registerCallback(callback_t callback_routine_, void* callback_info_) {
+	callback_routine=callback_routine_;
+	callback_info=callback_info_;
+}
+#endif
+
 //#############################################################################
 // Methods returning info on how the solution process terminated
 //#############################################################################
@@ -841,6 +899,16 @@
 	return isIterationLimitReached_;
 }
 
+bool OGSI::isTimeLimitReached() const
+{
+	return isTimeLimitReached_;
+}
+
+bool OGSI::isFeasible() const
+{
+	return isFeasible_;
+}
+
 //#############################################################################
 // WarmStart related methods
 //#############################################################################
@@ -3098,6 +3166,11 @@
 #   endif
     assert(retval == LPX_E_OK) ; }
 
+#ifdef OGSI_HAVE_CALLBACK    
+	callback_routine = source.callback_routine;
+  callback_info = source.callback_info;
+#endif
+
   return ; }
 
 
@@ -3141,9 +3214,16 @@
   hotStartRStatSize_ = 0;
 
   isIterationLimitReached_ = false;
+  isTimeLimitReached_ = false;
   isAbandoned_ = false;
   isPrimInfeasible_ = false;
   isDualInfeasible_ = false;
+  isFeasible_ = false;
+  
+#ifdef OGSI_HAVE_CALLBACK
+  callback_routine = NULL;
+  callback_info = NULL;
+#endif
 
   lp_ = lpx_create_prob();
   assert( lp_ != NULL );
@@ -3254,8 +3334,10 @@
         iter_used_ = 0;
 	isAbandoned_ = false;
 	isIterationLimitReached_ = false;
+	isTimeLimitReached_ = false;
 	isPrimInfeasible_ = false;
 	isDualInfeasible_ = false;
+	isFeasible_ = false;
 	delete [] colsol_;
 	delete [] rowsol_;
 	delete [] redcost_;
--- Osi/src/OsiGlpk/OsiGlpkSolverInterface.hpp	(Revision 1081)
+++ Osi/src/OsiGlpk/OsiGlpkSolverInterface.hpp	(Arbeitskopie)
@@ -17,6 +17,17 @@
 #include "CoinPackedMatrix.hpp"
 #include "CoinWarmStartBasis.hpp"
 
+// A define that tells whether methods to check for the timelimit exist in OsiGlpkSolverInterface
+#define OGSI_HAVE_TIMELIMIT
+// A define that tells whether methods to check for the feasibility exist in OsiGlpkSolverInterface
+#define OGSI_HAVE_FEASIBILITY
+// A define that tells whether methods to set callbacks exist in OsiGlpkSolverInterface (currently turned off)
+#if defined(GLP_MAJOR_VERSION) && defined(GLP_MINOR_VERSION)
+#if (GLP_MAJOR_VERSION > 4) || (GLP_MAJOR_VERSION == 4 && GLP_MINOR_VERSION == 20)  
+//#define OGSI_HAVE_CALLBACK
+#endif
+#endif
+
 /** GPLK Solver Interface
 
     Instantiation of OsiGlpkSolverInterface for GPLK
@@ -73,6 +84,13 @@
     bool getStrParam(OsiStrParam key, std::string& value) const;
   //@}
 
+#ifdef OGSI_HAVE_CALLBACK
+		/** Signature of GLPK callback routine.
+		 */ 
+	  typedef void (*callback_t)(glp_tree* tree, void* info);
+    void registerCallback(callback_t callback_routine_, void* callback_info_=NULL);
+#endif
+
   //---------------------------------------------------------------------------
   ///@name Methods returning info on how the solution process terminated
   //@{
@@ -90,6 +108,10 @@
     virtual bool isDualObjectiveLimitReached() const;
     /// Iteration limit reached?
     virtual bool isIterationLimitReached() const;
+    /// Time limit reached?
+    virtual bool isTimeLimitReached() const;
+    /// (Integer) Feasible solution found?
+    virtual bool isFeasible() const;
   //@}
 
   //---------------------------------------------------------------------------
@@ -780,6 +802,8 @@
   // Status information
   /// glpk stopped on iteration limit
   bool isIterationLimitReached_;
+  /// glpk stopped on time limit
+  bool isTimeLimitReached_;
   /// glpk abandoned the problem 
   bool isAbandoned_;
   /*! \brief  glpk stopped on lower objective limit
@@ -798,6 +822,8 @@
   bool isPrimInfeasible_;
   /// glpk declared the problem dual infeasible
   bool isDualInfeasible_;
+  /// glpk declared the problem feasible
+  bool isFeasible_;
 
   /**@name Cached information derived from the GLPK model */
   //@{
@@ -850,6 +876,11 @@
   /// Pointer to row-wise copy of problem matrix coefficients.
   mutable CoinPackedMatrix *matrixByCol_;  
   //@}
+
+#ifdef OGSI_HAVE_CALLBACK  
+  callback_t callback_routine;
+  void* callback_info;
+#endif
   //@}
 };
 
