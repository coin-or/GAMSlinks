--- Bonmin/src/Interfaces/BonOsiTMINLPInterface.cpp	(Revision 604)
+++ Bonmin/src/Interfaces/BonOsiTMINLPInterface.cpp	(Arbeitskopie)
@@ -427,6 +427,8 @@
     firstSolve_(true),
     cut_strengthener_(source.cut_strengthener_)
 {
+	if (source.messageHandler())
+		passInMessageHandler(source.messageHandler());
       messageHandler()->setLogLevel(source.messageHandler()->logLevel());
   // Copy options from old application
   if(IsValid(source.tminlp_)) {
@@ -1609,7 +1611,7 @@
   int n,m, nnz_jac_g, nnz_h_lag;
   TNLP::IndexStyleEnum index_style;
   tminlp_->get_nlp_info( n, m, nnz_jac_g, nnz_h_lag, index_style);
-  int offset = (index_style = TNLP::FORTRAN_STYLE);
+  int offset = (index_style == TNLP::FORTRAN_STYLE);
   if(jRow_ == NULL || jCol_ == NULL || jValues_ == NULL)
     initializeJacobianArrays();
   assert(jRow_ != NULL);
@@ -1621,7 +1623,7 @@
   CoinPackedVector * cuts = new CoinPackedVector[nNonLinear_ + 1];
   double * lb = new double[nNonLinear_ + 1];
   double * ub = new double[nNonLinear_ + 1];
-  int * binding = new int[nNonLinear_ + 1];//store binding constraints at current opt (which are added to OA) -1 if constraint is not binding, otherwise index in subset of binding constraints
+  int * binding = new int[m];//store binding constraints at current opt (which are added to OA) -1 if constraint is not binding, otherwise index in subset of binding constraints
   int numBindings = 0;
 
   const double * rowLower = getRowLower();
@@ -1659,10 +1661,11 @@
       
       numBindings++;
     }
+    else binding[i]=-1;
   }
 
   for(int i = 0 ; i < nnz_jac_g ; i++) {
-    if(constTypes_[jRow_[i] - 1] == TNLP::NON_LINEAR) {
+    if(constTypes_[jRow_[i] - offset] == TNLP::NON_LINEAR) {
       //"clean" coefficient
       if(cleanNnz(jValues_[i],colLower[jCol_[i] - offset], colUpper[jCol_[i]-offset],
 		  rowLower[jRow_[i] - offset], rowUpper[jRow_[i] - offset],
@@ -1678,24 +1681,25 @@
     }
   }
 
-  for(int i = 0; i< numBindings ; i++) {
+  for(int i = 0; i< m ; i++) {
+  	if (binding[i]<0) continue; // or -offset?
+		const int& bindi = binding[i];
     //Compute cut violation
     if(x2 != NULL) {
-      double rhs = cuts[i].dotProduct(x2);
+      double rhs = cuts[bindi].dotProduct(x2);
       double violation = 0.;
-      violation = max(violation, rhs - ub[i]);
-      violation = max(violation, lb[i] - rhs);
+      violation = max(violation, rhs - ub[bindi]);
+      violation = max(violation, lb[bindi] - rhs);
       if(violation == 0.) continue;
     }
     OsiRowCut newCut;
     //    if(lb[i]>-1e20) assert (ub[i]>1e20);
 
     if (IsValid(cut_strengthener_)) {
-      const int& bindi = binding[i];
       bool retval =
 	cut_strengthener_->ComputeCuts(cs, GetRawPtr(tminlp_),
 				       GetRawPtr(problem_), bindi,
-				       cuts[i], lb[i], ub[i], g[bindi],
+				       cuts[bindi], lb[bindi], ub[bindi], g[bindi],
 				       rowLower[bindi], rowUpper[bindi],
 				       n, x, infty);
       if (!retval) {
@@ -1707,9 +1711,9 @@
       newCut.setGloballyValidAsInteger(1);
     }
     newCut.setEffectiveness(99.99e99);
-    newCut.setLb(lb[i]);
-    newCut.setUb(ub[i]);
-    newCut.setRow(cuts[i]);
+    newCut.setLb(lb[bindi]);
+    newCut.setUb(ub[bindi]);
+    newCut.setRow(cuts[bindi]);
     //    CftValidator validator;
     //    validator(newCut);
     cs.insert(newCut);
--- Bonmin/src/Algorithms/BonBonminSetup.cpp	(Revision 604)
+++ Bonmin/src/Algorithms/BonBonminSetup.cpp	(Arbeitskopie)
@@ -331,6 +331,7 @@
     continuousSolver_ = new OsiClpSolverInterface;
     int lpLogLevel;
     options_->GetIntegerValue("lp_log_level",lpLogLevel,"bonmin.");
+    continuousSolver_->passInMessageHandler(nonlinearSolver_->messageHandler());
     continuousSolver_->messageHandler()->setLogLevel(lpLogLevel);
     nonlinearSolver_->extractLinearRelaxation(*continuousSolver_);
     // say bound dubious, does cuts at solution
